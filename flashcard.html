<!DOCTYPE html>
<html lang="en">
<!-- âœ… PRODUCTION VERSION - Cloud-First Storage Fix - Dec 4 2025 -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Universal Flashcards v2.5 - Cloud Sync</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='0.9em' font-size='90'%3EðŸ“š%3C/text%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* Remove tap highlight on mobile */
            -webkit-tap-highlight-color: transparent;
            /* Smooth scrolling on iOS */
            -webkit-overflow-scrolling: touch;
        }

        /* Root variables for safe area (notched devices) */
        :root {
            --safe-area-inset-top: env(safe-area-inset-top, 0px);
            --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
            --safe-area-inset-left: env(safe-area-inset-left, 0px);
            --safe-area-inset-right: env(safe-area-inset-right, 0px);
        }

        /* Prevent pull-to-refresh on mobile */
        html, body {
            overscroll-behavior-y: contain;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            /* Add safe area padding for notched devices */
            padding-top: max(20px, var(--safe-area-inset-top));
            padding-bottom: max(20px, var(--safe-area-inset-bottom));
            padding-left: max(20px, var(--safe-area-inset-left));
            padding-right: max(20px, var(--safe-area-inset-right));
            overflow-y: auto;
        }

        .container {
            width: 100%;
            max-width: 600px;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            margin-top: 20px;
            margin-bottom: 40px;
        }

        /* ============================================ */
        /* MOBILE TOUCH OPTIMIZATIONS */
        /* ============================================ */

        /* Better touch responsiveness for all interactive elements */
        button,
        input[type="button"],
        input[type="submit"],
        input[type="file"],
        .btn,
        .nav-button,
        .reveal-btn,
        .audio-btn,
        .audio-btn-lang2,
        .transcript-btn,
        .transcript-pair,
        a {
            touch-action: manipulation; /* Prevents double-tap zoom delay */
            -webkit-user-select: none;
            user-select: none;
            cursor: pointer;
        }

        /* Allow text selection in inputs and text areas */
        input[type="text"],
        input[type="password"],
        input[type="email"],
        input[type="search"],
        textarea {
            touch-action: manipulation;
            -webkit-user-select: text;
            user-select: text;
        }

        /* Active state feedback for touch */
        button:active,
        .btn:active,
        .nav-button:active,
        .reveal-btn:active,
        .audio-btn:active,
        .audio-btn-lang2:active {
            transform: scale(0.97);
            opacity: 0.9;
        }

        /* Management Side Panel */
        .management-panel {
            position: fixed;
            top: 0;
            left: -400px;
            width: 400px;
            max-width: 85vw;
            height: 100vh;
            background: white;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.3);
            transition: left 0.3s ease-out;
            z-index: 10000;
            overflow-y: auto;
            padding: 20px;
        }

        .management-panel.open {
            left: 0;
        }

        .management-panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 9999;
        }

        .management-panel-overlay.open {
            opacity: 1;
            visibility: visible;
        }

        .management-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 3px solid #667eea;
        }

        .management-panel-title {
            font-size: 1.5em;
            font-weight: 700;
            color: #667eea;
        }

        .management-panel-close {
            background: #ef4444;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2em;
            transition: all 0.3s;
        }

        .management-panel-close:hover {
            background: #dc2626;
            transform: scale(1.1);
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2em;
        }

        .upload-section {
            margin-bottom: 30px;
            text-align: center;
        }

        .upload-label {
            display: inline-block;
            padding: 12px 30px;
            background: #667eea;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
            font-weight: 600;
        }

        .upload-label:hover {
            background: #5568d3;
        }

        #csvFile {
            display: none;
        }

        .file-info {
            margin-top: 10px;
            color: #666;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .file-info strong {
            color: #667eea;
            font-size: 1.1em;
        }

        .flashcard-container {
            display: none;
            margin-bottom: 30px;
            position: relative;
        }

        .flashcard {
            position: relative;
            width: 100%;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .card-lang1-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px 20px;
            text-align: center;
            position: relative;
        }

        .card-label {
            font-size: 0.7em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            opacity: 0.9;
        }

        .card-content {
            font-size: 2em;
            font-weight: 700;
            text-align: center;
            word-wrap: break-word;
            margin: 12px 0;
        }

        .card-divider {
            border: none;
            border-top: 2px dashed rgba(255, 255, 255, 0.3);
            margin: 12px 0;
        }

        .card-lang2-section {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 20px;
            text-align: center;
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: all 0.4s ease-in-out;
            position: relative;
        }

        .card-lang2-section.revealed {
            max-height: 250px;
            opacity: 1;
            padding: 25px 20px;
        }

        .reveal-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: all 0.3s;
            margin-top: 8px;
        }

        .reveal-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .card-detail {
            font-size: 0.9em;
            margin-top: 15px;
            opacity: 0.9;
            font-style: italic;
            text-align: center;
        }

        .navigation {
            display: none;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }

        .nav-button {
            padding: 12px 30px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: background 0.3s;
        }

        .nav-button:hover:not(:disabled) {
            background: #5568d3;
        }

        .nav-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .progress {
            text-align: center;
            color: #667eea;
            font-weight: 600;
            font-size: 1.1em;
        }

        .hint {
            text-align: center;
            color: #999;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .show-meanings-toggle {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            padding: 12px;
            background: #f0f9ff;
            border-radius: 10px;
        }

        .show-meanings-toggle label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-weight: 600;
            color: #667eea;
            user-select: none;
        }

        .show-meanings-toggle input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .control-buttons {
            display: none;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .control-btn {
            padding: 10px 20px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: background 0.3s;
        }

        .control-btn:hover {
            background: #059669;
        }

        .control-btn.active {
            background: #f59e0b;
        }

        .autoplay-btn {
            background: #8b5cf6;
        }

        .autoplay-btn:hover {
            background: #7c3aed;
        }

        .autoplay-btn.playing {
            background: #ef4444;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .autoplay-settings {
            display: none;
            background: #f9fafb;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #e5e7eb;
        }

        .category-manager {
            display: none;
            background: #fef3c7;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #f59e0b;
        }

        .category-manager h4 {
            margin: 0 0 10px 0;
            color: #d97706;
        }

        .category-section {
            margin: 10px 0;
        }

        .category-input-group {
            display: flex;
            gap: 8px;
            margin: 8px 0;
        }

        .category-input-group input,
        .category-input-group select {
            padding: 6px 10px;
            border: 2px solid #fbbf24;
            border-radius: 6px;
            font-size: 0.9em;
        }

        .category-input-group button {
            padding: 6px 15px;
            background: #f59e0b;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .category-input-group button:hover {
            background: #d97706;
        }

        .category-list {
            background: white;
            border: 2px solid #fbbf24;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
        }

        .category-item {
            padding: 8px;
            margin: 4px 0;
            background: #fffbeb;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .category-item:hover {
            background: #fef3c7;
        }

        .subcategory-item {
            margin-left: 20px;
            padding: 6px;
            font-size: 0.9em;
            background: #fefce8;
        }

        .category-badge {
            display: inline-block;
            padding: 2px 8px;
            background: #fbbf24;
            color: #78350f;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .btn-small {
            padding: 3px 8px;
            font-size: 0.8em;
            margin-left: 5px;
        }

        .advanced-settings {
            display: none;
            background: #dbeafe;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #3b82f6;
        }

        .advanced-settings h4 {
            margin: 0 0 10px 0;
            color: #1e40af;
        }

        .timer-display {
            background: #fee2e2;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            margin: 10px 0;
            font-size: 1.2em;
            font-weight: bold;
            color: #991b1b;
            display: none;
        }

        .session-stats {
            background: #d1fae5;
            padding: 0;
            border-radius: 10px;
            margin: 15px 0;
            display: none;
            overflow: hidden;
            border: 2px solid #10b981;
        }

        .session-stats-header {
            padding: 12px 15px;
            background: #10b981;
            color: white;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            transition: background 0.3s;
        }

        .session-stats-header:hover {
            background: #059669;
        }

        .session-stats-header h4 {
            margin: 0;
            font-size: 1em;
        }

        .session-stats-toggle {
            font-size: 1.2em;
            transition: transform 0.3s;
        }

        .session-stats-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .session-stats-content {
            padding: 15px;
            max-height: 300px;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding 0.3s ease-out;
        }

        .session-stats-content.collapsed {
            max-height: 0;
            padding: 0 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #a7f3d0;
        }

        .stat-label {
            color: #047857;
            font-weight: 600;
        }

        .stat-value {
            color: #065f46;
            font-weight: bold;
        }

        .focus-mode {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1f2937;
            z-index: 9999;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .focus-mode .container {
            background: #374151;
            max-width: 800px;
        }

        .focus-mode .flashcard {
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
        }

        .focus-exit-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ef4444;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            z-index: 10000;
        }

        .focus-exit-btn:hover {
            background: #dc2626;
        }

        .autoplay-settings label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 0.9em;
            color: #374151;
        }

        .voice-settings {
            display: none;
            background: #fef3c7;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #fbbf24;
        }

        .voice-settings h4 {
            margin: 0 0 10px 0;
            color: #d97706;
        }

        .voice-settings label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            font-size: 0.9em;
            color: #92400e;
        }

        .voice-settings select {
            flex: 1;
            padding: 6px 10px;
            border: 2px solid #fbbf24;
            border-radius: 6px;
            background: white;
            font-size: 0.9em;
            cursor: pointer;
        }

        .voice-settings input[type="range"] {
            flex: 1;
            cursor: pointer;
            accent-color: #f59e0b;
        }

        .autoplay-settings input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #8b5cf6;
        }

        .autoplay-settings input[type="range"] {
            flex: 1;
            cursor: pointer;
            accent-color: #8b5cf6;
        }

        .delay-value {
            font-weight: 600;
            color: #8b5cf6;
            min-width: 50px;
            text-align: right;
        }

        .learned-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #10b981;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: 600;
            z-index: 10;
        }

        .unlearned-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ef4444;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: 600;
            z-index: 10;
        }

        .stats {
            display: none;
            background: #f0f9ff;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
        }

        .stats-item {
            display: inline-block;
            margin: 0 15px;
            color: #667eea;
            font-weight: 600;
        }

        .stats-value {
            font-size: 1.5em;
            display: block;
        }

        .audio-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .audio-btn:hover {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .audio-btn-lang2 {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .audio-btn-lang2:hover {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .review-info {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 10px;
            text-align: center;
        }

        .format-selector {
            background: #f8fafc;
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            border: 3px solid #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .format-selector h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .format-option {
            transition: all 0.3s;
        }

        .format-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }

        .format-preset-btn {
            padding: 15px;
            background: white;
            border: 2px solid #0284c7;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-size: 0.9em;
        }

        .format-preset-btn:hover {
            background: #0284c7;
            color: white;
            transform: scale(1.05);
        }

        .format-preset-btn strong {
            display: block;
            margin-bottom: 8px;
        }

        .column-mapper {
            background: #f0f9ff;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border: 3px solid #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
            overflow: visible;
        }

        .column-mapper h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .column-mapper p {
            color: #666;
            font-size: 0.95em;
        }

        #dataPreviewTable {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        #dataPreviewTable th {
            padding: 18px 12px;
            text-align: center;
            font-weight: 600;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            user-select: none;
            border: 4px solid #e5e7eb;
            background: #f9fafb;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        #dataPreviewTable th:hover {
            background: #fef3c7;
            border-color: #fbbf24;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        #dataPreviewTable th::before {
            content: 'ðŸ‘† Click to Select Type';
            display: block;
            font-size: 0.7em;
            font-weight: normal;
            color: #f59e0b;
            margin-bottom: 5px;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        #dataPreviewTable th.selected {
            background: #667eea;
            color: white;
            border: 4px solid #667eea;
        }

        #dataPreviewTable th.type-lang1 {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: 4px solid #10b981;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        #dataPreviewTable th.type-lang1::before {
            content: 'âœ“ Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-lang1Extended {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            border: 4px solid #f59e0b;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
        }

        #dataPreviewTable th.type-lang1Extended::before {
            content: 'âœ“ Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-lang1Extended1 {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            border: 4px solid #f59e0b;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
        }

        #dataPreviewTable th.type-lang1Extended1::before {
            content: 'âœ“ Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-lang1Extended2 {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            border: 4px solid #f59e0b;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
        }

        #dataPreviewTable th.type-lang1Extended2::before {
            content: 'âœ“ Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-lang1Extended3 {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            border: 4px solid #f59e0b;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
        }

        #dataPreviewTable th.type-lang1Extended3::before {
            content: 'âœ“ Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-lang2 {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border: 4px solid #3b82f6;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        #dataPreviewTable th.type-lang2::before {
            content: 'âœ“ Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-lang2Extended {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
            color: white;
            border: 4px solid #ec4899;
            box-shadow: 0 4px 12px rgba(236, 72, 153, 0.4);
        }

        #dataPreviewTable th.type-lang2Extended::before {
            content: 'âœ“ Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-lang2Extended1 {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
            color: white;
            border: 4px solid #ec4899;
            box-shadow: 0 4px 12px rgba(236, 72, 153, 0.4);
        }

        #dataPreviewTable th.type-lang2Extended1::before {
            content: 'âœ“ Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-lang2Extended2 {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
            color: white;
            border: 4px solid #ec4899;
            box-shadow: 0 4px 12px rgba(236, 72, 153, 0.4);
        }

        #dataPreviewTable th.type-lang2Extended2::before {
            content: 'âœ“ Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-lang2Extended3 {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
            color: white;
            border: 4px solid #ec4899;
            box-shadow: 0 4px 12px rgba(236, 72, 153, 0.4);
        }

        #dataPreviewTable th.type-lang2Extended3::before {
            content: 'âœ“ Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-ignore {
            background: #94a3b8;
            color: white;
            border: 4px solid #94a3b8;
            opacity: 0.5;
        }

        #dataPreviewTable th.type-ignore::before {
            content: 'âœ— Ignored';
            color: white;
            animation: none;
        }

        #dataPreviewTable td {
            padding: 10px 12px;
            border-bottom: 1px solid #e5e7eb;
            max-width: 250px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #dataPreviewTable tr:last-child td {
            border-bottom: none;
        }

        #dataPreviewTable tr:nth-child(even) {
            background: #f9fafb;
        }

        .column-type-selector {
            position: fixed;
            background: white;
            border: 4px solid #667eea;
            border-radius: 12px;
            padding: 12px;
            z-index: 10000;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: none;
            width: 280px;
            max-height: 400px;
            overflow-y: scroll !important;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .column-type-selector.active {
            animation: slideDown 0.2s ease-out;
        }

        .column-type-selector::-webkit-scrollbar {
            width: 16px;
        }

        .column-type-selector::-webkit-scrollbar-track {
            background: #cbd5e1;
            border-radius: 10px;
            border: 2px solid #94a3b8;
        }

        .column-type-selector::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
            border: 3px solid #cbd5e1;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .column-type-selector::-webkit-scrollbar-thumb:hover {
            background: #4f46e5;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        .type-option {
            padding: 10px 12px;
            margin: 4px 0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 2px solid transparent;
        }

        .type-option small {
            display: block;
            font-size: 0.8em;
            line-height: 1.2;
        }

        .type-option:hover {
            transform: translateX(2px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .type-option:active {
            transform: translateX(0);
        }

        .type-option[style*="color: #10b981"]:hover {
            background: #d1fae5;
            border-color: #10b981;
        }

        .type-option[style*="color: #f59e0b"]:hover {
            background: #fef3c7;
            border-color: #f59e0b;
        }

        .type-option[style*="color: #3b82f6"]:hover {
            background: #dbeafe;
            border-color: #3b82f6;
        }

        .type-option[style*="color: #ec4899"]:hover {
            background: #fce7f3;
            border-color: #ec4899;
        }

        .type-option[style*="color: #94a3b8"]:hover {
            background: #f1f5f9;
            border-color: #94a3b8;
        }

        .instructions {
            background: #f7f7f7;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 0.9em;
            color: #666;
        }

        .instructions h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .instructions code {
            background: #e0e0e0;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }

        /* Practice Mode Styles */
        .practice-mode-btn {
            display: none;
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: 700;
            margin: 20px 0;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .practice-mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
        }

        .practice-mode-btn.active {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            animation: pulse-practice 2s infinite;
        }

        @keyframes pulse-practice {
            0%, 100% { box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3); }
            50% { box-shadow: 0 4px 20px rgba(239, 68, 68, 0.6); }
        }

        body.practice-mode {
            align-items: center;
            padding: 10px;
        }

        body.practice-mode .container {
            margin-top: 0;
            max-width: 700px;
        }

        body.practice-mode .upload-section,
        body.practice-mode .category-browser,
        body.practice-mode .category-section,
        body.practice-mode .format-selector,
        body.practice-mode .column-mapper,
        body.practice-mode .file-info,
        body.practice-mode .category-manager,
        body.practice-mode h1,
        body.practice-mode .settings-toggle-btn,
        body.practice-mode #categoryMgmtToggleBtn,
        body.practice-mode #testAutoOpenBtn {
            display: none !important;
        }

        body.practice-mode .flashcard-container {
            margin-bottom: 20px;
        }

        body.practice-mode .flashcard {
            transform: scale(1.05);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        }

        .practice-mode-controls {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            gap: 10px;
        }

        body.practice-mode .practice-mode-controls {
            display: flex;
        }

        .floating-control-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #667eea;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .floating-control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .floating-control-btn.stop {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            border-color: #dc2626;
        }

        /* Settings Menu Styles */
        .settings-menu {
            display: none;
            background: #f8fafc;
            border-radius: 15px;
            padding: 15px;
            margin: 20px 0;
            border: 2px solid #e2e8f0;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            scroll-behavior: smooth;
            position: relative;
        }

        .settings-menu::-webkit-scrollbar {
            width: 10px;
        }

        .settings-menu::-webkit-scrollbar-track {
            background: #e2e8f0;
            border-radius: 10px;
        }

        .settings-menu::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
        }

        .settings-menu::-webkit-scrollbar-thumb:hover {
            background: #5568d3;
        }

        .settings-toggle-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: space-between;
            margin: 15px 0;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .settings-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .settings-toggle-btn.active {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        .toggle-icon {
            font-size: 1.2em;
            transition: transform 0.3s;
        }

        .settings-toggle-btn.active .toggle-icon {
            transform: rotate(180deg);
        }

        .accordion-item {
            background: white;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
            border: 2px solid #e2e8f0;
            transition: all 0.3s;
        }

        .accordion-item:hover {
            border-color: #cbd5e1;
        }

        .accordion-header {
            padding: 15px 20px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: #334155;
            user-select: none;
            transition: all 0.3s;
        }

        .accordion-header:hover {
            background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
        }

        .accordion-header.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .accordion-icon {
            font-size: 1.2em;
            transition: transform 0.3s;
        }

        .accordion-header.active .accordion-icon {
            transform: rotate(180deg);
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding 0.4s ease-out;
            padding: 0 20px;
        }

        .accordion-content.active {
            max-height: 2000px;
            padding: 20px;
            transition: max-height 0.5s ease-in, padding 0.4s ease-in;
        }

        .quick-actions {
            display: none;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            margin: 12px 0;
        }

        .quick-action-btn {
            padding: 8px 12px;
            background: white;
            border: 2px solid #667eea;
            color: #667eea;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        .quick-action-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }

        .quick-action-btn.active {
            background: #667eea;
            color: white;
        }

        /* Repeat dropdown menu */
        .repeat-dropdown {
            position: relative;
            display: inline-block;
        }

        .repeat-dropdown-menu {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 0;
            background: white;
            border: 2px solid #8b5cf6;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 200px;
            margin-bottom: 5px;
        }

        .repeat-dropdown-menu.show {
            display: block;
        }

        .repeat-dropdown-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #f3f4f6;
            transition: background 0.2s;
            font-size: 0.9em;
        }

        .repeat-dropdown-item:last-child {
            border-bottom: none;
            border-radius: 0 0 6px 6px;
        }

        .repeat-dropdown-item:first-child {
            border-radius: 6px 6px 0 0;
        }

        .repeat-dropdown-item:hover {
            background: #f3e8ff;
            color: #8b5cf6;
        }

        /* Fix accordion content labels */
        .accordion-content label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            font-size: 0.95em;
            color: #334155;
        }

        .accordion-content label span {
            flex: 1;
        }

        .accordion-content label select,
        .accordion-content label input[type="range"] {
            flex: 2;
        }

        /* Modal Popup Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease-out;
            overflow-y: auto;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            overflow-x: visible;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.3s ease-out;
            position: relative;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 3px solid #667eea;
        }

        .modal-header h3 {
            margin: 0;
            color: #667eea;
            font-size: 1.5em;
        }

        .modal-close {
            background: #ef4444;
            color: white;
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            font-weight: bold;
        }

        .modal-close:hover {
            background: #dc2626;
            transform: scale(1.1);
        }

        .modal-body {
            padding: 10px 0;
            padding-bottom: 450px;
        }

        .modal-body > p {
            color: #666;
            margin-bottom: 20px;
            font-size: 0.95em;
        }

        .type-choice-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .type-choice-card {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 3px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .type-choice-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }

        .type-choice-card[data-type="lang1"]:hover {
            border-color: #10b981;
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
        }

        .type-choice-card[data-type="lang1Extended"]:hover {
            border-color: #f59e0b;
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
        }

        .type-choice-card[data-type="lang2"]:hover {
            border-color: #3b82f6;
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
        }

        .type-choice-card[data-type="lang2Extended"]:hover {
            border-color: #ec4899;
            background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%);
        }

        .type-choice-card[data-type="ignore"]:hover {
            border-color: #94a3b8;
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
        }

        .type-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .type-name {
            font-size: 1.1em;
            font-weight: 600;
            color: #334155;
            margin-bottom: 8px;
        }

        .type-desc {
            font-size: 0.85em;
            color: #64748b;
            line-height: 1.4;
        }

        /* Dropdown Selector Styles (inside modal) */
        .column-type-selector {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 5px;
            background: white;
            border: 4px solid #667eea;
            border-radius: 12px;
            padding: 12px;
            z-index: 20000;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: none;
            width: 280px;
            max-height: 400px;
            overflow-y: scroll !important;
        }

        .column-type-selector.active {
            display: block !important;
        }

        .column-type-selector::-webkit-scrollbar {
            width: 16px;
        }

        .column-type-selector::-webkit-scrollbar-track {
            background: #cbd5e1;
            border-radius: 10px;
            border: 2px solid #94a3b8;
        }

        .column-type-selector::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
            border: 3px solid #cbd5e1;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .column-type-selector::-webkit-scrollbar-thumb:hover {
            background: #4f46e5;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        .type-option {
            padding: 10px 12px;
            margin: 4px 0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 2px solid transparent;
        }

        .type-option small {
            display: block;
            font-size: 0.8em;
            line-height: 1.2;
        }

        .type-option:hover {
            transform: translateX(2px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .type-option[style*="color: #10b981"]:hover {
            background: #d1fae5;
            border-color: #10b981;
        }

        .type-option[style*="color: #f59e0b"]:hover {
            background: #fef3c7;
            border-color: #f59e0b;
        }

        .type-option[style*="color: #3b82f6"]:hover {
            background: #dbeafe;
            border-color: #3b82f6;
        }

        .type-option[style*="color: #ec4899"]:hover {
            background: #fce7f3;
            border-color: #ec4899;
        }

        .type-option[style*="color: #94a3b8"]:hover {
            background: #f1f5f9;
            border-color: #94a3b8;
        }

        .category-browser {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .card-lang1-section {
                padding: 20px 15px;
            }

            .card-lang2-section.revealed {
                padding: 20px 15px;
                max-height: 300px;
            }

            .card-content {
                font-size: 1.8em;
            }

            .practice-mode-controls {
                top: 10px;
                right: 10px;
                flex-direction: column;
            }

            .floating-control-btn {
                padding: 10px 18px;
                font-size: 0.9em;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.3em;
            }

            .card-lang1-section {
                padding: 18px 12px;
            }

            .card-lang2-section.revealed {
                padding: 18px 12px;
                max-height: 280px;
            }

            .card-content {
                font-size: 1.5em;
            }

            .card-label {
                font-size: 0.65em;
            }

            .reveal-btn {
                padding: 7px 15px;
                font-size: 0.8em;
            }

            .nav-button {
                padding: 10px 15px;
                font-size: 0.85em;
            }

            .audio-btn, .audio-btn-lang2 {
                width: 40px;
                height: 40px;
                font-size: 1.2em;
            }

            body.practice-mode .container {
                max-width: 100%;
            }

            .practice-mode-controls {
                top: 5px;
                right: 5px;
                gap: 5px;
            }

            .floating-control-btn {
                padding: 8px 12px;
                font-size: 0.8em;
            }

            .practice-mode-btn {
                padding: 15px;
                font-size: 1em;
            }

            #categoryBrowserList {
                grid-template-columns: 1fr !important;
            }

            /* Modal responsive adjustments */
            .modal-content {
                width: 95%;
                padding: 20px;
            }

            .type-choice-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .type-choice-card {
                padding: 15px;
            }

            .type-icon {
                font-size: 2.5em;
            }

            .modal-header h3 {
                font-size: 1.2em;
            }
        }

        /* ============================================ */
        /* COMPREHENSIVE MOBILE ENHANCEMENTS - v3.3 */
        /* ============================================ */

        /* Tablet and Mobile (768px and below) */
        @media (max-width: 768px) {
            /* Prevent horizontal overflow */
            html, body {
                max-width: 100vw;
                overflow-x: hidden;
            }

            body {
                padding: 10px 5px;
            }

            .container {
                width: calc(100vw - 20px);
                max-width: 100%;
                margin-left: auto;
                margin-right: auto;
                padding: 20px 15px;
            }

            /* Better touch targets */
            button, .btn, input[type="button"], input[type="submit"] {
                min-height: 44px;
                padding: 12px 16px;
            }

            /* Side panel mobile */
            .management-panel {
                max-width: 90vw !important;
                width: 90vw !important;
            }

            /* Modals full width */
            .modal-content {
                width: 95% !important;
                max-width: 95vw !important;
                padding: 20px 15px;
            }

            /* Input fields - prevent zoom on iOS */
            input[type="text"],
            input[type="password"],
            input[type="number"],
            textarea,
            select {
                font-size: 16px !important;
            }

            /* Navigation responsive */
            #navigation {
                flex-wrap: wrap;
                gap: 8px;
            }

            /* Quick actions grid */
            #quickActions {
                grid-template-columns: 1fr 1fr !important;
            }

            /* Category browser */
            #categoryBrowserList {
                grid-template-columns: 1fr !important;
            }

            /* Flashcard mobile */
            .card-content {
                font-size: 1.6em !important;
            }

            /* Audio buttons */
            .audio-btn, .audio-btn-lang2 {
                width: 48px !important;
                height: 48px !important;
            }
        }

        /* Small Mobile (480px and below) */
        @media (max-width: 480px) {
            .container {
                padding: 15px 10px;
            }

            h1 {
                font-size: 1.3em !important;
            }

            .card-content {
                font-size: 1.4em !important;
            }

            #quickActions {
                grid-template-columns: 1fr !important;
            }

            .nav-button {
                width: 100%;
            }
        }

        /* Landscape mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            body {
                padding: 10px;
            }

            .container {
                margin-top: 5px;
                margin-bottom: 20px;
                padding: 15px;
            }

            .card-lang1-section,
            .card-lang2-section {
                max-height: 120px;
                overflow-y: auto;
                padding: 10px;
            }

            .card-content {
                font-size: 1.2em !important;
            }

            .management-panel {
                max-height: 100vh;
                overflow-y: auto;
            }
        }

        /* Extra small devices (iPhone SE, small Android) */
        @media (max-width: 375px) {
            body {
                padding: 10px 5px;
            }

            .container {
                padding: 12px 8px;
                border-radius: 15px;
            }

            h1 {
                font-size: 1.2em !important;
            }

            .card-content {
                font-size: 1.3em !important;
                padding: 10px;
            }

            .card-label {
                font-size: 0.6em !important;
            }

            .nav-button {
                padding: 8px 12px !important;
                font-size: 0.8em !important;
            }

            .audio-btn, .audio-btn-lang2 {
                width: 42px !important;
                height: 42px !important;
                font-size: 1.1em !important;
            }

            .reveal-btn {
                padding: 8px 12px !important;
                font-size: 0.75em !important;
            }

            /* Management panel takes full width on very small screens */
            .management-panel {
                max-width: 95vw !important;
                width: 95vw !important;
            }

            /* Modal adjustments */
            .modal-content {
                padding: 15px 10px !important;
            }

            .transcript-text {
                font-size: 0.95em !important;
            }
        }

        /* File Manager Styles */
        .file-manager {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            margin-top: 10px;
        }

        .file-manager-header {
            color: #0ea5e9;
            margin-bottom: 20px;
            font-size: 1.2em;
        }

        .file-manager-layout {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            min-height: 400px;
        }

        .file-tree {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-height: 600px;
            overflow-y: auto;
        }

        .tree-category {
            margin-bottom: 10px;
        }

        .tree-category-name {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            background: #e0f2fe;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            color: #0284c7;
            transition: all 0.2s;
        }

        .tree-category-name:hover {
            background: #bae6fd;
        }

        .tree-category-name.selected {
            background: #0ea5e9;
            color: white;
        }

        .tree-subcategory {
            padding-left: 20px;
            margin-top: 5px;
        }

        .tree-subcategory-name {
            display: flex;
            align-items: center;
            padding: 6px 10px;
            background: #f0f9ff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            color: #0369a1;
            margin-bottom: 3px;
            transition: all 0.2s;
        }

        .tree-subcategory-name:hover {
            background: #e0f2fe;
        }

        .tree-subcategory-name.selected {
            background: #0ea5e9;
            color: white;
        }

        .tree-icon {
            margin-right: 8px;
            font-size: 1.1em;
        }

        .file-editor {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        .file-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e2e8f0;
        }

        .file-editor-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #0284c7;
        }

        .file-editor-actions {
            display: flex;
            gap: 10px;
        }

        .file-editor-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 0.9em;
        }

        .btn-add {
            background: #10b981;
            color: white;
        }

        .btn-add:hover {
            background: #059669;
        }

        .btn-export {
            background: #3b82f6;
            color: white;
        }

        .btn-export:hover {
            background: #2563eb;
        }

        .flashcard-list {
            flex: 1;
            overflow-y: auto;
            max-height: 500px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
        }

        .search-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }

        .search-input {
            flex: 1;
            padding: 10px 15px;
            border: 2px solid #cbd5e1;
            border-radius: 6px;
            font-size: 0.95em;
        }

        .search-input:focus {
            outline: none;
            border-color: #0ea5e9;
        }

        .bulk-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f1f5f9;
            border-radius: 6px;
            align-items: center;
        }

        .bulk-actions.hidden {
            display: none;
        }

        .selection-count {
            font-weight: 600;
            color: #0284c7;
            margin-right: auto;
        }

        .excel-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }

        .excel-table thead {
            background: #f1f5f9;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .excel-table th {
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            color: #334155;
            border-bottom: 2px solid #cbd5e1;
            border-right: 1px solid #e2e8f0;
            font-size: 0.9em;
        }

        .excel-table th:last-child {
            border-right: none;
        }

        .excel-table td {
            padding: 10px 8px;
            border-bottom: 1px solid #e2e8f0;
            border-right: 1px solid #e2e8f0;
            font-size: 0.9em;
            color: #334155;
        }

        .excel-table td:last-child {
            border-right: none;
        }

        .excel-table tbody tr:hover {
            background: #f0f9ff;
        }

        .excel-table tbody tr.selected {
            background: #dbeafe;
        }

        .checkbox-cell {
            width: 40px;
            text-align: center;
        }

        .line-number-cell {
            width: 50px;
            font-weight: 600;
            color: #64748b;
            text-align: center;
        }

        .content-cell {
            min-width: 150px;
        }

        .content-cell strong {
            display: block;
            margin-bottom: 4px;
            color: #1e293b;
        }

        .content-cell small {
            color: #64748b;
            font-style: italic;
        }

        .editable-cell {
            cursor: text;
            padding: 10px 8px !important;
            transition: all 0.2s;
        }

        .editable-cell:hover {
            background: #f0f9ff;
            outline: 1px solid #bae6fd;
        }

        .editable-cell:focus {
            background: #fff;
            outline: 2px solid #0ea5e9;
            outline-offset: -2px;
        }

        .editable-cell:empty:before {
            content: attr(data-placeholder);
            color: #cbd5e1;
            font-style: italic;
        }

        .actions-cell {
            width: 100px;
            text-align: center;
        }

        .line-actions {
            display: flex;
            gap: 5px;
            justify-content: center;
        }

        .line-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .btn-edit {
            background: #3b82f6;
            color: white;
        }

        .btn-edit:hover {
            background: #2563eb;
        }

        .btn-delete {
            background: #ef4444;
            color: white;
        }

        .btn-delete:hover {
            background: #dc2626;
        }

        .add-flashcard-form {
            display: none;
            background: #fef3c7;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid #f59e0b;
        }

        .add-flashcard-form.active {
            display: block;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #78350f;
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #fbbf24;
            border-radius: 6px;
            font-size: 1em;
        }

        .form-actions {
            display: flex;
            gap: 10px;
        }

        .btn-save {
            flex: 1;
            padding: 10px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .btn-save:hover {
            background: #059669;
        }

        .btn-cancel {
            flex: 1;
            padding: 10px;
            background: #6b7280;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .btn-cancel:hover {
            background: #4b5563;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #94a3b8;
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 10px;
        }

        /* Modal Popup for Table View */
        .table-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 11000;
            padding: 20px;
        }

        .table-modal-overlay.active {
            display: flex;
        }

        .table-modal-content {
            background: white;
            border-radius: 12px;
            width: 95%;
            max-width: 1400px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .table-modal-header {
            padding: 20px 30px;
            border-bottom: 2px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .table-modal-title {
            font-size: 1.5em;
            font-weight: 600;
            color: #0284c7;
        }

        .table-modal-actions {
            display: flex;
            gap: 10px;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 1em;
        }

        .modal-btn-close {
            background: #ef4444;
            color: white;
        }

        .modal-btn-close:hover {
            background: #dc2626;
        }

        .table-modal-body {
            padding: 20px 30px;
            overflow-y: auto;
            flex: 1;
        }

        /* Category Selector in Modal */
        .modal-category-selector {
            background: #f8fafc;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid #e2e8f0;
        }

        .modal-category-selector h4 {
            margin: 0 0 10px 0;
            color: #0284c7;
            font-size: 1em;
        }

        .category-button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .category-btn {
            padding: 8px 16px;
            border: 2px solid #cbd5e1;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 0.9em;
        }

        .category-btn:hover {
            background: #e0f2fe;
            border-color: #0ea5e9;
        }

        .category-btn.active {
            background: #0ea5e9;
            color: white;
            border-color: #0284c7;
        }

        .subcategory-btn {
            padding: 6px 12px;
            border: 2px solid #e0f2fe;
            background: #f0f9ff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .subcategory-btn:hover {
            background: #bae6fd;
            border-color: #0ea5e9;
        }

        .subcategory-btn.active {
            background: #0ea5e9;
            color: white;
            border-color: #0284c7;
        }

        @media (max-width: 768px) {
            .file-manager-layout {
                grid-template-columns: 1fr;
            }

            .file-tree {
                max-height: 300px;
            }

            .flashcard-line {
                grid-template-columns: 30px 1fr 60px;
                font-size: 0.9em;
            }

            .line-content:last-of-type {
                display: none;
            }

            .table-modal-content {
                width: 100%;
                max-height: 95vh;
            }

            .table-modal-header {
                padding: 15px 20px;
            }

            .table-modal-body {
                padding: 15px 20px;
            }
        }

        /* Category Browser Scrollbar Styling */
        #categoryBrowserListContainer {
            scrollbar-width: thin;
            scrollbar-color: #667eea #e0e7ff;
        }

        #categoryBrowserListContainer::-webkit-scrollbar {
            width: 8px;
        }

        #categoryBrowserListContainer::-webkit-scrollbar-track {
            background: #e0e7ff;
            border-radius: 10px;
        }

        #categoryBrowserListContainer::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
        }

        #categoryBrowserListContainer::-webkit-scrollbar-thumb:hover {
            background: #5568d3;
        }

        /* Category collapse button styling */
        .category-collapse-btn:hover {
            color: #764ba2 !important;
            transform: scale(1.2) !important;
        }

        .category-collapse-btn:active {
            transform: scale(0.95) !important;
        }

        /* Pagination button styling */
        #categoryPagination button:hover:not(:disabled) {
            background: #764ba2 !important;
            transform: scale(1.05);
        }

        #categoryPagination button:disabled {
            background: #ccc !important;
            cursor: not-allowed;
            opacity: 0.6;
        }

        /* Smart controls button hover effects */
        #categorySmartControls button:hover {
            transform: scale(1.05);
            opacity: 0.9;
        }

        /* Group collapse button styling */
        .group-collapse-btn:hover {
            color: #10b981 !important;
            transform: scale(1.3) !important;
        }

        .group-collapse-btn:active {
            transform: scale(0.9) !important;
        }

        /* Mobile responsive adjustments */
        @media (max-width: 600px) {
            #categoryBrowserList {
                grid-template-columns: 1fr !important;
            }

            #categoryBrowserListContainer {
                max-height: 300px !important;
            }

            .category-collapse-btn {
                font-size: 1.3em !important;
            }
        }

        /* ===== MINIMIZE MODE (YouTube-style PIP) ===== */
        .minimize-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            z-index: 100;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .minimize-btn:hover {
            background: rgba(102, 126, 234, 1);
            transform: scale(1.05);
        }

        .flashcard-container.minimized {
            position: fixed !important;
            bottom: 20px !important;
            right: 20px !important;
            width: clamp(320px, 30vw, 450px) !important;
            height: auto !important;
            max-height: min(70vh, 600px) !important;
            min-height: 200px !important;
            z-index: 9999 !important;
            margin: 0 !important;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4) !important;
            border-radius: 16px !important;
            overflow-y: auto !important;
            overflow-x: hidden !important;
            transition: all 0.3s ease !important;
            background: white !important;
        }

        .flashcard-container.minimized .flashcard {
            height: auto !important;
            min-height: auto !important;
            padding: 10px 12px !important;
            display: flex !important;
            flex-direction: column !important;
            box-sizing: border-box !important;
        }

        .flashcard-container.minimized .card-lang1-section,
        .flashcard-container.minimized .card-lang2-section {
            padding: 10px !important;
            margin: 2px 0 !important;
            box-sizing: border-box !important;
        }

        .flashcard-container.minimized .card-content {
            font-size: clamp(1em, 1.1em, 1.3em) !important;
            margin: 5px 0 !important;
            line-height: 1.3 !important;
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            max-width: 100% !important;
        }

        .flashcard-container.minimized .card-label {
            font-size: 0.75em !important;
            margin-bottom: 3px !important;
        }

        .flashcard-container.minimized .card-detail {
            font-size: 0.8em !important;
            margin-top: 3px !important;
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
        }

        .flashcard-container.minimized .card-divider {
            margin: 6px 0 !important;
        }

        .flashcard-container.minimized .reveal-btn {
            padding: 6px 12px !important;
            font-size: 0.8em !important;
            margin-top: 6px !important;
            white-space: normal !important;
            word-wrap: break-word !important;
        }

        .flashcard-container.minimized .audio-btn,
        .flashcard-container.minimized .audio-btn-lang2 {
            font-size: 1em !important;
            padding: 5px 8px !important;
        }

        .flashcard-container.minimized .learned-badge {
            font-size: 0.65em !important;
            padding: 2px 6px !important;
        }

        .flashcard-container.minimized .review-info {
            font-size: 0.65em !important;
            word-wrap: break-word !important;
        }

        /* Scrollbar styling for minimized mode */
        .flashcard-container.minimized::-webkit-scrollbar {
            width: 6px !important;
        }

        .flashcard-container.minimized::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.05) !important;
            border-radius: 10px !important;
        }

        .flashcard-container.minimized::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5) !important;
            border-radius: 10px !important;
        }

        .flashcard-container.minimized::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.8) !important;
        }

        .flashcard-container.minimized .hint {
            display: none !important;
        }

        .navigation.hidden {
            display: none !important;
        }

        .restore-btn {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(239, 68, 68, 0.9);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 5px 12px;
            cursor: pointer;
            font-size: 0.75em;
            font-weight: 600;
            z-index: 101;
            transition: all 0.3s ease;
        }

        .restore-btn:hover {
            background: rgba(239, 68, 68, 1);
        }

        .flashcard-container:not(.minimized) .restore-btn {
            display: none !important;
        }

        .flashcard-container.minimized .minimize-btn {
            display: none !important;
        }

        /* ===== MOBILE RESPONSIVE FOR MINIMIZE MODE ===== */
        @media (max-width: 768px) {
            .flashcard-container.minimized {
                width: calc(100vw - 40px) !important;
                max-width: 400px !important;
                bottom: 10px !important;
                right: 10px !important;
                max-height: min(60vh, 500px) !important;
            }

            .flashcard-container.minimized .card-content {
                font-size: 1em !important;
            }

            .minimize-btn {
                padding: 6px 12px !important;
                font-size: 0.8em !important;
            }

            .restore-btn {
                padding: 4px 10px !important;
                font-size: 0.7em !important;
            }
        }

        @media (max-width: 480px) {
            .flashcard-container.minimized {
                width: calc(100vw - 20px) !important;
                bottom: 5px !important;
                right: 5px !important;
                left: 5px !important;
                margin: 0 auto !important;
                max-height: min(50vh, 400px) !important;
            }

            .flashcard-container.minimized .card-content {
                font-size: 0.95em !important;
            }

            .flashcard-container.minimized .card-label {
                font-size: 0.7em !important;
            }

            .flashcard-container.minimized .card-detail {
                font-size: 0.75em !important;
            }

            .minimize-btn {
                padding: 5px 10px !important;
                font-size: 0.75em !important;
            }

            .restore-btn {
                padding: 3px 8px !important;
                font-size: 0.65em !important;
            }
        }
    </style>
    <style>
        /* Cloud Sync Login Modal */
        .login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .login-box {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .login-box h2 {
            color: #667eea;
            text-align: center;
            margin-bottom: 10px;
        }

        .login-box p {
            text-align: center;
            color: #666;
            font-size: 0.9em;
            margin-bottom: 30px;
        }

        .login-input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 1em;
        }

        .login-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .login-btn:hover {
            opacity: 0.9;
        }

        .skip-btn {
            width: 100%;
            padding: 10px;
            background: #94a3b8;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.9em;
            cursor: pointer;
        }

        .skip-btn:hover {
            background: #64748b;
        }

        .login-info {
            background: #f0f9ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.85em;
            color: #555;
        }

        .sync-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 10px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            font-size: 0.9em;
            z-index: 1000;
        }

        .sync-status.synced {
            color: #10b981;
            border-left: 4px solid #10b981;
        }

        .account-button {
            display: none !important; /* Hidden - now in hamburger menu */
        }

        .sync-status.syncing {
            color: #f59e0b;
            border-left: 4px solid #f59e0b;
        }

        .sync-status.error {
            color: #ef4444;
            border-left: 4px solid #ef4444;
        }

        /* ============================================ */
        /* VIEW MODE TOGGLE - Card vs Transcript Mode */
        /* ============================================ */
        .view-mode-toggle {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .view-mode-btn {
            padding: 12px 24px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .view-mode-btn:hover {
            background: #f0f4ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .view-mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* ============================================ */
        /* TRANSCRIPT VIEW - Conversation Mode */
        /* ============================================ */
        .transcript-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            max-height: 600px;
            overflow-y: auto;
        }

        .transcript-header {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            margin-bottom: 15px;
            font-weight: 700;
            font-size: 1.1em;
            text-align: center;
        }

        .transcript-pair {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 10px;
            background: #f8f9fa;
            transition: all 0.3s;
            cursor: pointer;
        }

        .transcript-pair:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }

        .transcript-pair.playing {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-left: 4px solid #f59e0b;
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
        }

        .transcript-text {
            padding: 10px;
            line-height: 1.6;
            font-size: 1.1em;
        }

        .transcript-text.source {
            font-weight: 600;
            color: #333;
        }

        .transcript-text.target {
            color: #666;
        }

        .transcript-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .transcript-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .transcript-btn.play {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .transcript-btn.pause {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }

        .transcript-btn.stop {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        .transcript-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .transcript-progress {
            text-align: center;
            margin: 15px 0;
            font-size: 1.1em;
            color: #667eea;
            font-weight: 600;
        }

        .transcript-empty {
            text-align: center;
            padding: 60px 20px;
            color: #999;
            font-size: 1.2em;
        }

        /* Mobile responsive for transcript */
        @media (max-width: 768px) {
            .transcript-header,
            .transcript-pair {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .transcript-text {
                font-size: 1em;
            }

            .view-mode-btn {
                font-size: 0.9em;
                padding: 10px 18px;
            }
        }
    </style>
</head>
<body>
    <!-- Cloud Sync Login Modal -->
    <div class="login-overlay" id="loginOverlay">
        <div class="login-box">
            <h2 id="loginTitle">â˜ï¸ Cloud Sync Login</h2>
            <p id="loginSubtitle">Access your categories from any device</p>

            <div class="login-info">
                <strong>ðŸ” Secure & Private:</strong><br>
                â€¢ Your data is encrypted with your password<br>
                â€¢ Categories sync across all your devices<br>
                â€¢ No email required, just username + password
            </div>

            <input type="text" id="username" class="login-input" placeholder="Username" autocomplete="username" onkeypress="handleLoginKeyPress(event)">
            <input type="password" id="password" class="login-input" placeholder="Password" autocomplete="current-password" onkeypress="handleLoginKeyPress(event)">
            <input type="password" id="confirmPassword" class="login-input" placeholder="Confirm Password" autocomplete="new-password" style="display: none;" onkeypress="handleLoginKeyPress(event)">

            <button class="login-btn" id="loginBtn" onclick="window.cloudLogin()">ðŸ”“ Login</button>
            <button class="login-btn" id="signupBtn" onclick="window.cloudSignup()" style="display: none;">ðŸ“ Sign Up</button>

            <div style="text-align: center; margin: 10px 0; color: #666; font-size: 0.9em;">
                <span id="toggleText">Don't have an account? <a href="#" onclick="window.toggleLoginMode(); return false;" style="color: #667eea; text-decoration: none; font-weight: bold;">Sign Up</a></span>
            </div>

            <button class="skip-btn" onclick="window.skipLogin()">Skip (Use Local Only)</button>
        </div>
    </div>

    <!-- Sync Status Indicator -->
    <div class="sync-status" id="syncStatus" style="display: none;">
        <span id="syncStatusText">â˜ï¸ Synced</span>
    </div>

    <!-- Account Button (Shows when logged in) -->
    <div class="account-button" id="accountButton" style="display: none;">
        <button onclick="window.openAccountSettings()" style="background: #667eea; color: white; border: none; padding: 10px 20px; border-radius: 10px; cursor: pointer; font-weight: bold; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);">
            ðŸ‘¤ Account
        </button>
    </div>

    <!-- Account Management Modal -->
    <div class="login-overlay" id="accountModal" style="display: none;">
        <div class="login-box" style="max-width: 500px;">
            <h2 style="color: #667eea; margin-bottom: 20px;">ðŸ‘¤ Account Management</h2>

            <div style="background: #f0f9ff; padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                <p style="margin: 5px 0;"><strong>Username:</strong> <span id="accountUsername">-</span></p>
                <p style="margin: 5px 0;"><strong>Status:</strong> <span id="accountStatus" style="color: #10b981;">âœ… Connected</span></p>
                <p style="margin: 5px 0;"><strong>Sync:</strong> <span id="accountSyncStatus">â˜ï¸ Synced</span></p>
            </div>

            <div style="margin: 20px 0;">
                <button onclick="window.showChangePassword()" style="width: 100%; padding: 12px; background: #667eea; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer; margin: 5px 0; font-weight: 600;">
                    ðŸ”‘ Change Password
                </button>
                <button onclick="window.logoutAccount()" style="width: 100%; padding: 12px; background: #f59e0b; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer; margin: 5px 0; font-weight: 600;">
                    ðŸšª Logout
                </button>
                <button onclick="window.showDeleteAccount()" style="width: 100%; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer; margin: 5px 0; font-weight: 600;">
                    ðŸ—‘ï¸ Delete Account
                </button>
            </div>

            <div id="changePasswordSection" style="display: none; background: #fef3c7; padding: 15px; border-radius: 10px; margin: 15px 0;">
                <h3 style="color: #92400e; margin-bottom: 10px;">Change Password</h3>
                <input type="password" id="currentPassword" placeholder="Current Password" style="width: 100%; padding: 10px; margin: 5px 0; border: 2px solid #fbbf24; border-radius: 5px;">
                <input type="password" id="newPassword" placeholder="New Password" style="width: 100%; padding: 10px; margin: 5px 0; border: 2px solid #fbbf24; border-radius: 5px;">
                <input type="password" id="confirmNewPassword" placeholder="Confirm New Password" style="width: 100%; padding: 10px; margin: 5px 0; border: 2px solid #fbbf24; border-radius: 5px;">
                <button onclick="window.changePassword()" style="width: 100%; padding: 10px; background: #10b981; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 10px; font-weight: 600;">
                    âœ… Confirm Change
                </button>
                <button onclick="window.cancelChangePassword()" style="width: 100%; padding: 10px; background: #6b7280; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 5px;">
                    Cancel
                </button>
            </div>

            <div id="deleteAccountSection" style="display: none; background: #fee2e2; padding: 15px; border-radius: 10px; margin: 15px 0;">
                <h3 style="color: #991b1b; margin-bottom: 10px;">âš ï¸ Delete Account</h3>
                <p style="color: #991b1b; margin-bottom: 10px;">This will permanently delete all your data from the cloud. This action cannot be undone!</p>
                <input type="password" id="deletePassword" placeholder="Enter Password to Confirm" style="width: 100%; padding: 10px; margin: 5px 0; border: 2px solid #ef4444; border-radius: 5px;">
                <button onclick="window.confirmDeleteAccount()" style="width: 100%; padding: 10px; background: #ef4444; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 10px; font-weight: 600;">
                    ðŸ—‘ï¸ Yes, Delete My Account
                </button>
                <button onclick="window.cancelDeleteAccount()" style="width: 100%; padding: 10px; background: #6b7280; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 5px;">
                    Cancel
                </button>
            </div>

            <button onclick="window.closeAccountSettings()" style="width: 100%; padding: 12px; background: #6b7280; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer; margin-top: 10px; font-weight: 600;">
                Close
            </button>
        </div>
    </div>

    <!-- Table Modal Popup -->
    <div class="table-modal-overlay" id="tableModal">
        <div class="table-modal-content">
            <div class="table-modal-header">
                <div class="table-modal-title" id="modalTitle">Loading...</div>
                <div class="table-modal-actions">
                    <button class="modal-btn" style="background: #10b981; color: white;" onclick="saveAllChanges()">
                        ðŸ’¾ Save All Changes
                    </button>
                    <button class="modal-btn" style="background: #3b82f6; color: white;" onclick="exportModalCSV()">
                        ðŸ“¥ Export CSV
                    </button>
                    <button class="modal-btn modal-btn-close" onclick="closeTableModal()">
                        âœ• Close
                    </button>
                </div>
            </div>
            <div class="table-modal-body" id="modalTableContainer">
                <!-- Table content will be loaded here -->
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Header with Hamburger Menu -->
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 30px;">
            <!-- Hamburger Menu Button -->
            <button id="hamburgerMenuBtn" onclick="toggleManagementPanel()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 12px 15px; border-radius: 10px; cursor: pointer; font-size: 1.5em; line-height: 1; box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3); transition: all 0.3s;" title="Open Management Panel">
                â˜°
            </button>

            <!-- Title -->
            <h1 style="margin: 0; flex: 1; text-align: center;">ðŸ“š Universal Flashcards <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 3px 12px; border-radius: 15px; font-size: 0.7em; vertical-align: middle;">v2.5</span> ðŸŒ</h1>

            <!-- Spacer to balance layout -->
            <div style="width: 60px;"></div>
        </div>

        <!-- Category Browser (Collapsible & Scrollable) - Practice existing vocabulary -->
        <div class="category-browser" id="categoryBrowser" style="background: #f0f9ff; padding: 15px; border-radius: 15px; margin-bottom: 20px; border: 3px solid #667eea;">
            <!-- Header with collapse button -->
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                <div style="cursor: pointer;" onclick="toggleCategoryBrowser()">
                    <h3 style="color: #667eea; margin: 0; display: inline-block;">ðŸ“š Your Vocabulary Categories</h3>
                    <span id="categoryCount" style="font-size: 0.85em; color: #999; margin-left: 10px;"></span>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button onclick="event.stopPropagation(); renderCategoryBrowser();" style="background: #10b981; color: white; border: none; padding: 8px 15px; border-radius: 8px; cursor: pointer; font-size: 1em; transition: all 0.3s;" onmouseenter="this.style.background='#059669'" onmouseleave="this.style.background='#10b981'" title="Refresh categories">
                        ðŸ”„ Refresh
                    </button>
                    <button id="categoryBrowserToggle" onclick="event.stopPropagation(); toggleCategoryBrowser();" style="background: #667eea; color: white; border: none; padding: 8px 15px; border-radius: 8px; cursor: pointer; font-size: 1em; transition: all 0.3s;">
                        â–¼ Hide
                    </button>
                </div>
            </div>
            <div id="categoryBrowserContent" style="overflow: hidden; transition: max-height 0.3s ease-out; max-height: 2000px;">
                <p style="color: #666; font-size: 0.9em; margin-bottom: 15px;">Browse and practice your saved vocabulary organized by categories</p>

                <!-- Search Box -->
                <div style="margin-bottom: 15px;">
                    <input type="text" id="categorySearchBox" placeholder="ðŸ” Search categories..." style="width: 100%; padding: 12px; border: 2px solid #667eea; border-radius: 8px; font-size: 1em; outline: none;" onkeyup="filterCategories()">
                </div>

                <!-- Pagination Controls -->
                <div id="categoryPagination" style="display: none; text-align: center; margin-bottom: 15px; padding: 12px; background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 8px; border: 2px solid #667eea;">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 15px; flex-wrap: wrap;">
                        <span id="paginationInfo" style="color: #667eea; font-weight: 600; font-size: 0.95em;"></span>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="previousPage()" id="prevPageBtn" style="padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; transition: all 0.2s;" onmouseenter="this.style.background='#5568d3'" onmouseleave="this.style.background='#667eea'">
                                â—€ Previous
                            </button>
                            <span id="pageNumbers" style="padding: 8px 16px; font-weight: 600; color: #667eea; background: white; border-radius: 6px;"></span>
                            <button onclick="nextPage()" id="nextPageBtn" style="padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; transition: all 0.2s;" onmouseenter="this.style.background='#5568d3'" onmouseleave="this.style.background='#667eea'">
                                Next â–¶
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Scrollable container -->
                <div id="categoryBrowserListContainer" style="max-height: 600px; overflow-y: auto; overflow-x: hidden;">
                    <table id="categoryBrowserList" style="width: 100%; border-collapse: collapse;">
                        <!-- Will be populated dynamically -->
                    </table>
                </div>
                <div id="noCategoriesMessage" style="text-align: center; color: #999; padding: 20px; display: none;">
                    No categories yet. Upload a file to get started!
                </div>
            </div>
        </div>

        <!-- Upload Section (Always Visible) -->
        <div class="upload-section" id="uploadSection">
            <label for="csvFile" class="upload-label">
                ðŸ“ Choose Vocabulary File
            </label>
            <input type="file" id="csvFile" accept="*">
            <div class="file-info" id="fileInfo"></div>
            <button class="upload-label" id="clearFileBtn" style="background: #ef4444; display: none; margin-top: 10px;">
                ðŸ—‘ï¸ Remove Current File
            </button>
        </div>

        <!-- Category Suggestion Box (MOVED OUTSIDE - Always visible when suggestion exists) -->
        <div class="category-section" id="suggestedCategorySection" style="display: none; background: #fef3c7; padding: 20px; border-radius: 12px; margin: 20px 0; border: 3px solid #f59e0b; box-shadow: 0 6px 12px rgba(245, 158, 11, 0.3);">
            <strong style="color: #92400e; font-size: 1.2em; display: block; margin-bottom: 10px;">ðŸ’¡ Suggested Categories</strong>
            <p style="color: #78350f; font-size: 0.95em; margin: 0 0 15px 0;">Based on your filename and content analysis:</p>

            <div style="background: white; padding: 15px; border-radius: 10px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                <div style="margin-bottom: 12px;">
                    <label style="display: block; color: #92400e; font-weight: 600; margin-bottom: 6px;">ðŸ“ Category:</label>
                    <input type="text" id="suggestedCategoryInput" style="width: 100%; padding: 10px; border: 2px solid #fbbf24; border-radius: 8px; font-size: 1em;">
                </div>
                <div>
                    <label style="display: block; color: #92400e; font-weight: 600; margin-bottom: 6px;">ðŸ“‹ Subcategory (optional):</label>
                    <input type="text" id="suggestedSubcategoryInput" style="width: 100%; padding: 10px; border: 2px solid #fbbf24; border-radius: 8px; font-size: 1em;">
                    <small style="color: #78350f; font-style: italic; display: block; margin-top: 5px;">Leave empty if no subcategory needed</small>
                </div>
            </div>

            <div style="display: flex; gap: 12px;">
                <button onclick="applySuggestedCategory()" style="flex: 1; padding: 12px 18px; background: #10b981; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1.05em; transition: all 0.2s;">
                    âœ“ Accept & Apply
                </button>
                <button onclick="rejectSuggestion()" style="flex: 1; padding: 12px 18px; background: #94a3b8; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1.05em; transition: all 0.2s;">
                    âœ— Use Default Instead
                </button>
            </div>
        </div>

        <!-- Main Area Management Sections (Hidden by default, toggled from sidebar) -->

        <!-- Manage Categories Section (in main area) -->
        <div id="mainManageCategories" style="display: none; margin-bottom: 20px;">
            <div style="background: white; padding: 20px; border-radius: 15px; border: 3px solid #f59e0b;">
                <h3 style="color: #d97706; margin-bottom: 15px;">ðŸ“š Manage Categories</h3>

                <div class="category-manager" id="categoryManagerSection" style="display: block;">
                    <h4 style="color: #d97706;">Category Management</h4>

                    <div class="category-section">
                        <strong>Current File:</strong>
                        <span id="currentFileDisplay">No file loaded</span>
                        <span class="category-badge" id="currentCategoryBadge">Default</span>
                    </div>
                    <div class="category-section">
                        <label style="display: block; margin-bottom: 5px;">Assign to Category:</label>
                        <div class="category-input-group">
                            <select id="categorySelect" style="flex: 1;">
                                <option value="Default">Default</option>
                            </select>
                            <select id="subcategorySelect" style="flex: 1;">
                                <option value="">No Subcategory</option>
                            </select>
                            <button onclick="assignCategory()">Assign</button>
                        </div>
                    </div>
                    <hr style="border: 1px solid #e2e8f0; margin: 15px 0;">
                    <div class="category-section">
                        <strong>Create New Category:</strong>
                        <div class="category-input-group">
                            <input type="text" id="newCategoryName" placeholder="e.g., Spanish Basics" style="flex: 1;">
                            <button onclick="createCategory()">+ Add Category</button>
                        </div>
                    </div>
                    <div class="category-section">
                        <strong>Add Subcategory:</strong>
                        <div class="category-input-group">
                            <select id="parentCategorySelect" style="flex: 1;">
                                <option value="Default">Default</option>
                            </select>
                            <input type="text" id="newSubcategoryName" placeholder="e.g., A1 Vocabulary" style="flex: 1;">
                            <button onclick="createSubcategory()">+ Add Sub</button>
                        </div>
                    </div>
                    <div class="category-section">
                        <strong>All Categories:</strong>
                        <div class="category-list" id="categoryList">
                            <div class="category-item">
                                <span>ðŸ“ Default</span>
                                <span style="font-size: 0.8em; color: #78350f;">Built-in</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- File Manager Modal Popup -->
        <div class="modal-overlay" id="mainFileManager" style="display: none;" onclick="if(event.target === this) toggleMainSection('fileManager')">
            <div class="modal-content" style="max-width: 900px; width: 95%;" onclick="event.stopPropagation();">
                <div class="modal-header">
                    <h3>ðŸ“‚ File Manager - Browse & Edit Categories</h3>
                    <button class="modal-close" onclick="toggleMainSection('fileManager')">âœ•</button>
                </div>

                <div class="modal-body" style="padding-bottom: 20px;">
                    <div class="file-manager">
                    <div class="file-manager-layout">
                        <!-- Left: Category Tree Browser -->
                        <div class="file-tree">
                            <h5 style="color: #0284c7; margin-bottom: 15px; font-size: 1em;">ðŸ“ Categories</h5>
                            <div id="fileTreeContent">
                                <!-- Will be populated dynamically -->
                            </div>
                        </div>

                        <!-- Right: File Editor -->
                        <div class="file-editor">
                            <div id="fileEditorContent">
                                <div class="file-editor-header">
                                    <div class="file-editor-title" id="editorTitle">Default</div>
                                    <div class="file-editor-actions">
                                        <button class="file-editor-btn" onclick="manualLoadData()" style="background: #10b981; font-size: 1.1em;">
                                            ðŸ”„ Load Data
                                        </button>
                                        <button class="file-editor-btn btn-add" onclick="showAddFlashcardForm()">
                                            âž• Add Flashcard
                                        </button>
                                        <button class="file-editor-btn btn-export" onclick="exportCategoryToCSV()">
                                            ðŸ’¾ Export CSV
                                        </button>
                                    </div>
                                </div>

                                <!-- Add Flashcard Form (Hidden by default) -->
                                <div class="add-flashcard-form" id="addFlashcardForm">
                                    <h5 style="color: #78350f; margin-bottom: 15px;">âž• Add New Flashcard</h5>
                                    <div class="form-group">
                                        <label>Source Language Word/Phrase:</label>
                                        <input type="text" id="newGerman" placeholder="e.g., Hola">
                                    </div>
                                    <div class="form-group">
                                        <label>Source Example (Optional):</label>
                                        <input type="text" id="newGermanExample" placeholder="e.g., Hola, Â¿cÃ³mo estÃ¡s?">
                                    </div>
                                    <div class="form-group">
                                        <label>Target Language Translation:</label>
                                        <input type="text" id="newEnglish" placeholder="e.g., Hello">
                                    </div>
                                    <div class="form-group">
                                        <label>Target Example (Optional):</label>
                                        <input type="text" id="newEnglishExample" placeholder="e.g., Hello, how are you?">
                                    </div>
                                    <div class="form-actions">
                                        <button class="btn-save" onclick="saveNewFlashcard()">ðŸ’¾ Save</button>
                                        <button class="btn-cancel" onclick="hideAddFlashcardForm()">âŒ Cancel</button>
                                    </div>
                                </div>

                                <!-- Search Bar -->
                                <div class="search-bar">
                                    <input type="text" id="flashcardSearch" class="search-input" placeholder="ðŸ” Search flashcards... (Source or Target)">
                                    <button class="file-editor-btn" onclick="clearSearch()" style="background: #6b7280;">Clear</button>
                                </div>

                                <!-- Bulk Actions Bar (Hidden by default) -->
                                <div class="bulk-actions hidden" id="bulkActionsBar">
                                    <span class="selection-count" id="selectionCount">0 selected</span>
                                    <button class="file-editor-btn" style="background: #ef4444;" onclick="deleteSelected()">ðŸ—‘ï¸ Delete Selected</button>
                                    <button class="file-editor-btn" style="background: #6b7280;" onclick="deselectAll()">Clear Selection</button>
                                </div>

                                <!-- Flashcard List (Excel-like Table) -->
                                <div class="flashcard-list" id="flashcardListContainer">
                                    <!-- Will be populated dynamically -->
                                </div>
                            </div>
                        </div>
                    </div>
                    </div><!-- End file-manager -->
                </div><!-- End modal-body -->
            </div><!-- End modal-content -->
        </div><!-- End File Manager Modal -->

        <!-- Management Panel Overlay -->
        <div class="management-panel-overlay" id="managementPanelOverlay" onclick="toggleManagementPanel()"></div>

        <!-- Management Side Panel -->
        <div class="management-panel" id="managementPanel">
            <!-- Panel Header -->
            <div class="management-panel-header">
                <span class="management-panel-title">âš™ï¸ Management</span>
                <button class="management-panel-close" onclick="toggleManagementPanel()">âœ•</button>
            </div>

            <!-- Panel Content -->
            <div class="management-panel-content">
                <!-- Menu Buttons -->
                <div style="margin-bottom: 15px;">
                    <button onclick="toggleMainSection('categorySuggestion')" style="display: block; width: 100%; padding: 14px; background: #3b82f6; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1em; margin-bottom: 10px; transition: all 0.3s;">
                        ðŸ’¡ Show Category Suggestion
                    </button>
                </div>

                <div style="margin-bottom: 15px;">
                    <button onclick="toggleMainSection('manageCategories')" style="display: block; width: 100%; padding: 14px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1em; margin-bottom: 10px; transition: all 0.3s;">
                        ðŸ“š Manage Categories
                    </button>
                </div>

                <div style="margin-bottom: 15px;">
                    <button onclick="toggleMainSection('fileManager')" style="display: block; width: 100%; padding: 14px; background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1em; transition: all 0.3s;">
                        ðŸ“‚ File Manager - Browse & Edit Categories
                    </button>
                </div>

                <div style="margin-bottom: 15px;">
                    <button onclick="toggleMainSection('categoryBrowser')" style="display: block; width: 100%; padding: 14px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1em; transition: all 0.3s;">
                        ðŸ—‚ï¸ Toggle Category Browser
                    </button>
                </div>

                <div style="margin-bottom: 15px;">
                    <button onclick="remapLoadedFlashcards()" style="display: block; width: 100%; padding: 14px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1em; transition: all 0.3s;">
                        ðŸŽ¯ Remap Columns
                    </button>
                </div>

                <div style="margin-bottom: 15px;">
                    <button onclick="toggleMainSection('settingsMenu')" style="display: block; width: 100%; padding: 14px; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1em; transition: all 0.3s;">
                        âš™ï¸ Toggle Settings & Options
                    </button>
                </div>

                <div style="margin-bottom: 15px;">
                    <button onclick="toggleMainSection('uploadSection')" style="display: block; width: 100%; padding: 14px; background: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1em; transition: all 0.3s;">
                        ðŸ“ Toggle File Upload Section
                    </button>
                </div>

                <!-- Account Button (Shows when logged in) -->
                <div id="accountButtonPanel" style="display: none; margin-bottom: 15px;">
                    <button onclick="window.openAccountSettings()" style="display: block; width: 100%; padding: 14px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1em; transition: all 0.3s;">
                        ðŸ‘¤ Account Settings
                    </button>
                </div>

            </div><!-- End management-panel-content -->
        </div><!-- End management-panel -->

        <!-- Format Selection Interface -->
        <div class="format-selector" id="formatSelector" style="display: none;">
            <h3>ðŸ“‹ Choose How to Load Your File</h3>
            <p style="margin-bottom: 20px; color: #666;">Select the best method for your CSV format:</p>

            <!-- Option 1: Predefined Formats -->
            <div class="format-option" style="background: #e0f2fe; border: 3px solid #0284c7; padding: 20px; border-radius: 12px; margin-bottom: 15px; cursor: pointer;" onclick="selectPredefinedFormat()">
                <h4 style="color: #0284c7; margin: 0 0 10px 0;">âš¡ Option 1: Quick Predefined Format</h4>
                <p style="margin: 0 0 15px 0; font-size: 0.9em; color: #666;">Choose from common CSV formats. Fastest option!</p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;" id="predefinedFormats">
                    <button class="format-preset-btn" data-format="3col-standard">
                        <strong>ðŸ“Œ 3-Column Standard</strong><br>
                        <span style="font-size: 0.85em;">Source, Source Example, Target</span>
                    </button>
                    <button class="format-preset-btn" data-format="3col-reverse">
                        <strong>ðŸ“Œ 3-Column Reverse</strong><br>
                        <span style="font-size: 0.85em;">Target, Target Example, Source</span>
                    </button>
                    <button class="format-preset-btn" data-format="4col-full">
                        <strong>ðŸ“Œ 4-Column Full</strong><br>
                        <span style="font-size: 0.85em;">Source, Source Ex., Target, Target Ex.</span>
                    </button>
                    <button class="format-preset-btn" data-format="2col-simple">
                        <strong>ðŸ“Œ 2-Column Simple</strong><br>
                        <span style="font-size: 0.85em;">Source, Target (no examples)</span>
                    </button>
                </div>
            </div>

            <!-- Option 2: Manual Mapping -->
            <div class="format-option" style="background: #fef3c7; border: 3px solid #f59e0b; padding: 20px; border-radius: 12px; margin-bottom: 15px; cursor: pointer;" onclick="selectManualMapping()">
                <h4 style="color: #f59e0b; margin: 0 0 10px 0;">ðŸŽ¯ Option 2: Manual Column Mapping</h4>
                <p style="margin: 0; font-size: 0.9em; color: #666;">Manually assign each column. Full control for custom formats.</p>
            </div>

            <!-- Option 3: Auto-Detection -->
            <div class="format-option" style="background: #dbeafe; border: 3px solid #667eea; padding: 20px; border-radius: 12px; cursor: pointer;" onclick="selectAutoDetection()">
                <h4 style="color: #667eea; margin: 0 0 10px 0;">ðŸ¤– Option 3: Smart Auto-Detection</h4>
                <p style="margin: 0; font-size: 0.9em; color: #666;">AI-powered detection analyzes your data automatically. Works for most formats.</p>
            </div>
        </div>

        <!-- Manual Column Mapping Modal Popup -->
        <div class="modal-overlay" id="columnMapperModal" style="display: none;">
            <div class="modal-content" style="max-width: 95%; width: 1400px;">
                <div class="modal-header">
                    <h3>ðŸŽ¯ Manual Column Mapping</h3>
                    <button class="modal-close" onclick="closeColumnMapperModal()">âœ•</button>
                </div>
                <div class="modal-body">
                    <p style="margin-bottom: 20px; color: #666; font-size: 0.95em;">
                        Click on each column header to assign its type. Preview shows first 10 rows of your data.
                    </p>

                    <!-- Data Preview Table -->
                    <div style="overflow-x: auto; overflow-y: visible; margin-bottom: 20px;">
                        <table id="dataPreviewTable" style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                            <!-- Will be populated dynamically -->
                        </table>
                    </div>

                    <!-- Type Selection Buttons -->
                    <div style="background: #f0f9ff; padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                        <strong style="color: #667eea;">ðŸ“‹ Available Column Types:</strong>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-top: 10px;">
                            <div style="padding: 10px; background: white; border-radius: 6px; border: 2px solid #10b981;">
                                <strong style="color: #10b981;">ðŸ“– Source Language</strong>
                                <div style="font-size: 0.8em; color: #666; margin-top: 3px;">Main vocab shown immediately</div>
                            </div>
                            <div style="padding: 10px; background: white; border-radius: 6px; border: 2px solid #f59e0b;">
                                <strong style="color: #f59e0b;">ðŸ“ Source Example</strong>
                                <div style="font-size: 0.8em; color: #666; margin-top: 3px;">Hidden until revealed</div>
                            </div>
                            <div style="padding: 10px; background: white; border-radius: 6px; border: 2px solid #10b981;">
                                <strong style="color: #10b981;">ðŸŽ¯ Target Language</strong>
                                <div style="font-size: 0.8em; color: #666; margin-top: 3px;">Main translation shown immediately</div>
                            </div>
                            <div style="padding: 10px; background: white; border-radius: 6px; border: 2px solid #f59e0b;">
                                <strong style="color: #f59e0b;">ðŸ“ Target Example</strong>
                                <div style="font-size: 0.8em; color: #666; margin-top: 3px;">Hidden until revealed</div>
                            </div>
                            <div style="padding: 10px; background: white; border-radius: 6px; border: 2px solid #94a3b8;">
                                <strong style="color: #64748b;">ðŸš« Ignore</strong>
                                <div style="font-size: 0.8em; color: #666; margin-top: 3px;">Skip this column</div>
                            </div>
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button class="control-btn" id="applyMappingBtnModal" style="flex: 1; background: #10b981;" onclick="processWithManualMapping()">
                            âœ“ Apply & Load Cards
                        </button>
                        <button class="control-btn" style="flex: 1; background: #94a3b8;" onclick="closeColumnMapperModal()">
                            âœ• Cancel
                        </button>
                    </div>
                </div>
            </div>
        </div>


        <!-- Instructions (Collapsible) -->
        <div class="instructions" id="instructions" style="cursor: pointer;" onclick="this.style.display='none'">
            <h3>ðŸ“‹ CSV Format Instructions - v2.2 Enhanced (Click to hide):</h3>
            <p><strong>âœ¨ NEW: Smart Format Detection!</strong> Auto-detects columns AND separators!</p>
            <p style="margin-top: 10px;"><strong>Supported Separators:</strong></p>
            <p>âœ… Comma (,) | âœ… Semicolon (;) | âœ… Pipe (|) | âœ… Tab - All auto-detected!</p>
            <p style="margin-top: 10px;"><strong>Supported Formats:</strong></p>
            <p><strong>Basic:</strong> <code>Source,Target</code> or <code>Target,Source</code></p>
            <p><strong>Extended (NEW!):</strong> <code>Source,Long Source Text,Target,Long Target Text</code></p>
            <p style="margin-top: 10px;"><strong>Examples:</strong></p>
            <code>Hola,Hello</code> (comma)<br>
            <code>Hola;Hello</code> (semicolon - auto-detected!)<br>
            <code>Hola|Â¿CÃ³mo estÃ¡s?|Hello|How are you?</code> (pipe + extended)<br>
            <p style="margin-top: 10px;">âœ… Any separator | âœ… Any column order | âœ… Extended text supported</p>
        </div>

        <!-- Stats (Always Visible When File Loaded) -->
        <div class="stats" id="stats">
            <div class="stats-item">
                <span class="stats-value" id="learnedCount">0</span>
                <span>Learned</span>
            </div>
            <div class="stats-item">
                <span class="stats-value" id="remainingCount">0</span>
                <span>Remaining</span>
            </div>
            <div class="stats-item">
                <span class="stats-value" id="totalCount">0</span>
                <span>Total</span>
            </div>
        </div>

        <!-- Settings Menu Toggle Button -->
        <button class="settings-toggle-btn" id="settingsToggleBtn">
            <span>âš™ï¸ Settings & Options</span>
            <span class="toggle-icon">â–¼</span>
        </button>

        <!-- Settings Menu (Collapsible Accordion) -->
        <div class="settings-menu" id="settingsMenu">

            <!-- Voice & Speech Settings Accordion -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>ðŸŽ™ï¸ Voice & Speech Settings <span style="font-size: 0.8em; color: #888;">(v2.4 Enhanced)</span></span>
                    <span class="accordion-icon">â–¼</span>
                </div>
                <div class="accordion-content">
                    <div style="background: #f0f8ff; padding: 10px; border-radius: 5px; margin-bottom: 15px; font-size: 0.9em; border-left: 3px solid #667eea;">
                        <strong>ðŸ”Š = Google voices (recommended, highest quality)</strong><br>
                        <strong>ðŸŽ™ï¸ = Microsoft voices (high quality)</strong><br>
                        <span style="color: #666;">Tip: Google voices provide the most natural pronunciation for learning!</span>
                    </div>

                    <!-- Quick Gender Selection -->
                    <div style="background: #fff; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #e0e0e0;">
                        <div style="font-weight: 600; margin-bottom: 10px; color: #667eea;">ðŸ‘¤ Quick Voice Selection:</div>
                        <label style="margin-bottom: 10px;">
                            <span style="display: block; margin-bottom: 5px;"><strong>Source Language Narrator:</strong></span>
                            <select id="germanGenderSelect" style="width: 100%; padding: 10px; border: 2px solid #667eea; border-radius: 5px; font-size: 14px; background: white;">
                                <option value="female">ðŸ‘© Female Voice (Recommended)</option>
                                <option value="male">ðŸ‘¨ Male Voice</option>
                            </select>
                        </label>
                        <label style="margin-top: 10px;">
                            <span style="display: block; margin-bottom: 5px;"><strong>Target Language Narrator:</strong></span>
                            <select id="englishGenderSelect" style="width: 100%; padding: 10px; border: 2px solid #667eea; border-radius: 5px; font-size: 14px; background: white;">
                                <option value="male">ðŸ‘¨ Male Voice (Recommended)</option>
                                <option value="female">ðŸ‘© Female Voice</option>
                            </select>
                        </label>
                    </div>

                    <!-- Specific Voice Selection (Always Visible) -->
                    <div style="background: #fafafa; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 2px solid #e0e0e0;">
                        <div style="font-weight: 600; margin-bottom: 10px; color: #667eea;">ðŸ”§ Choose Specific Voice:</div>
                        <label>
                            <span><strong>Source Language Voice:</strong></span>
                            <select id="sourceVoiceSelect" style="width: 100%; padding: 8px; margin-top: 5px; border: 2px solid #667eea; border-radius: 5px; font-size: 14px;"></select>
                            <div id="sourceVoiceInfo" style="font-size: 0.85em; color: #666; margin-top: 5px; font-style: italic;">Loading voices...</div>
                        </label>
                        <label style="margin-top: 15px;">
                            <span><strong>Target Language Voice:</strong></span>
                            <select id="targetVoiceSelect" style="width: 100%; padding: 8px; margin-top: 5px; border: 2px solid #667eea; border-radius: 5px; font-size: 14px;"></select>
                            <div id="targetVoiceInfo" style="font-size: 0.85em; color: #666; margin-top: 5px; font-style: italic;">Loading voices...</div>
                        </label>
                    </div>
                    <label style="margin-top: 15px;">
                        <span>Speech Rate:</span>
                        <input type="range" id="speechRate" min="0.5" max="1.5" step="0.1" value="1.0">
                        <span class="delay-value" id="speechRateValue">1.0x</span>
                        <div style="font-size: 0.8em; color: #888; margin-top: 3px;">Slower (0.5x) â† â†’ Faster (1.5x)</div>
                    </label>
                    <label>
                        <span>Pitch:</span>
                        <input type="range" id="speechPitch" min="0.5" max="2" step="0.1" value="1.0">
                        <span class="delay-value" id="speechPitchValue">1.0</span>
                        <div style="font-size: 0.8em; color: #888; margin-top: 3px;">Lower (0.5) â† â†’ Higher (2.0)</div>
                    </label>
                </div>
            </div>

            <!-- Auto-Play Settings Accordion -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>â–¶ Auto-Play Settings</span>
                    <span class="accordion-icon">â–¼</span>
                </div>
                <div class="accordion-content">
                    <label>
                        <input type="checkbox" id="autoplayEnglish">
                        <span>Pronounce Target translation (after Source)</span>
                    </label>
                    <label>
                        <span>Delay between Source & Target:</span>
                        <input type="range" id="delayBetween" min="500" max="20000" step="500" value="4000">
                        <span class="delay-value" id="delayBetweenValue">4.0s</span>
                    </label>
                    <label>
                        <span>Delay before next card:</span>
                        <input type="range" id="delayNext" min="1000" max="20000" step="500" value="4000">
                        <span class="delay-value" id="delayNextValue">4.0s</span>
                    </label>
                    <hr style="border: 1px solid #e2e8f0; margin: 15px 0;">
                    <label>
                        <input type="checkbox" id="recordSession">
                        <span>ðŸŽ™ï¸ Record Session Audio</span>
                    </label>
                    <div id="recordingControls" style="display: none; margin: 15px 0; padding: 15px; background: #fee2e2; border-radius: 8px; border: 2px solid #ef4444;">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <span style="color: #dc2626; font-weight: 600;">âº Recording in progress...</span>
                            <span id="recordingTime" style="color: #dc2626; font-weight: bold;">0:00</span>
                        </div>
                        <button class="control-btn" id="stopRecordingBtn" style="background: #ef4444; width: 100%;">
                            â¹ Stop Recording
                        </button>
                    </div>
                    <div id="recordedAudioSection" style="display: none; margin: 15px 0; padding: 15px; background: #d1fae5; border-radius: 8px; border: 2px solid #10b981;">
                        <strong style="color: #065f46;">âœ“ Recording Saved!</strong>
                        <div style="margin-top: 10px; display: flex; gap: 10px;">
                            <button class="control-btn" id="downloadRecordingBtn" style="background: #10b981; flex: 1;">
                                â¬‡ Download Audio
                            </button>
                            <button class="control-btn" id="playRecordingBtn" style="background: #3b82f6; flex: 1;">
                                â–¶ Play Recording
                            </button>
                        </div>
                        <audio id="recordedAudio" controls style="width: 100%; margin-top: 10px; display: none;"></audio>
                    </div>
                </div>
            </div>

            <!-- Advanced Features Accordion -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>ðŸŽ¯ Advanced Features</span>
                    <span class="accordion-icon">â–¼</span>
                </div>
                <div class="accordion-content">
                    <label>
                        <input type="checkbox" id="loopMode">
                        <span>ðŸ” Loop Mode - Restart automatically when finished</span>
                    </label>
                    <label style="display: block; margin-bottom: 10px;">
                        <span style="font-weight: 600; display: block; margin-bottom: 5px;">ðŸ—£ï¸ Repeat Source Language:</span>
                        <select id="repeatSourceCount" style="margin-left: 10px; padding: 4px; min-width: 100px;">
                            <option value="1">1 time</option>
                            <option value="2">2 times</option>
                            <option value="3">3 times</option>
                            <option value="4">4 times</option>
                            <option value="5">5 times</option>
                        </select>
                    </label>
                    <label style="display: block; margin-bottom: 10px;">
                        <span style="font-weight: 600; display: block; margin-bottom: 5px;">ðŸ—£ï¸ Repeat Target Language:</span>
                        <select id="repeatTargetCount" style="margin-left: 10px; padding: 4px; min-width: 100px;">
                            <option value="1">1 time</option>
                            <option value="2">2 times</option>
                            <option value="3">3 times</option>
                            <option value="4">4 times</option>
                            <option value="5">5 times</option>
                        </select>
                    </label>
                    <label>
                        <input type="checkbox" id="studyTimer">
                        <span>â° Study Timer:</span>
                        <select id="studyDuration" style="margin-left: 10px; padding: 4px;">
                            <option value="5">5 minutes</option>
                            <option value="10">10 minutes</option>
                            <option value="15">15 minutes</option>
                            <option value="20">20 minutes</option>
                            <option value="30">30 minutes</option>
                            <option value="45">45 minutes</option>
                            <option value="60">60 minutes</option>
                        </select>
                    </label>
                    <label>
                        <input type="checkbox" id="sleepTimer">
                        <span>ðŸ“š Sleep Timer:</span>
                        <select id="sleepDuration" style="margin-left: 10px; padding: 4px;">
                            <option value="10">10 minutes</option>
                            <option value="15">15 minutes</option>
                            <option value="20">20 minutes</option>
                            <option value="30">30 minutes</option>
                            <option value="45">45 minutes</option>
                        </select>
                    </label>
                </div>
            </div>

            <!-- Display Options Accordion -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>ðŸ‘ï¸ Display Options</span>
                    <span class="accordion-icon">â–¼</span>
                </div>
                <div class="accordion-content">
                    <label style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
                        <input type="checkbox" id="alwaysShowMeanings">
                        <span>Always show Target meanings</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
                        <input type="checkbox" id="readExtendedContent">
                        <span>ðŸ“– Read Extended Examples/Sentences in Auto-Play</span>
                    </label>
                    <button class="control-btn" id="focusModeBtn" style="width: 100%; margin-top: 10px; background: #6366f1;">
                        ðŸŽ¯ Enter Focus Mode
                    </button>
                    <button class="control-btn" id="resetBtn" style="width: 100%; margin-top: 10px; background: #ef4444;">
                        â†º Reset All Progress
                    </button>
                </div>
            </div>

            <!-- Export & Backup Accordion -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>ðŸ’¾ Export & Backup</span>
                    <span class="accordion-icon">â–¼</span>
                </div>
                <div class="accordion-content">
                    <div style="background: #f0fdf4; padding: 10px; border-radius: 5px; margin-bottom: 15px; font-size: 0.9em; border-left: 3px solid #10b981;">
                        <strong>ðŸ“¦ Backup & Restore Your Data</strong><br>
                        <span style="color: #666;">Export all categories to ZIP with full metadata, or restore from backup.</span>
                    </div>

                    <button onclick="exportAllCategories()" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1em; transition: all 0.3s; margin-bottom: 10px;">
                        ðŸ“¥ Export All Categories as ZIP
                    </button>

                    <label for="importZipInput" style="display: block; width: 100%; padding: 14px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1em; text-align: center; transition: all 0.3s; margin-bottom: 10px;">
                        ðŸ“¤ Import from ZIP Backup
                    </label>
                    <input type="file" id="importZipInput" accept=".zip" style="display: none;" onchange="importBackupZip(this.files[0])">

                    <!-- Compress & Re-upload Data Button (Only shown when logged in) -->
                    <button id="compressDataBtn" onclick="compressAndReuploadData()" style="display: none; width: 100%; padding: 14px; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1em; transition: all 0.3s; margin-bottom: 10px;">
                        ðŸ—œï¸ Compress & Re-upload Cloud Data
                    </button>

                    <div style="font-size: 0.85em; color: #888; margin-top: 10px;">
                        <strong>âœ¨ Full Backup Includes:</strong><br>
                        â€¢ Categories & Subcategories<br>
                        â€¢ Groups & Custom Names<br>
                        â€¢ Progress (Learned status)<br>
                        â€¢ Complete metadata structure<br>
                        <br>
                        <strong>ðŸ’¡ Tip:</strong> Export before major changes for easy recovery!
                    </div>
                </div>
            </div>

        </div>

        <!-- Timer Display (Shows During Auto-Play) -->
        <div class="timer-display" id="timerDisplay">
            <span id="timerText">Time Remaining: 00:00</span>
        </div>

        <!-- Session Stats (Shows During Auto-Play) - Collapsible -->
        <div class="session-stats" id="sessionStats">
            <div class="session-stats-header" onclick="toggleSessionStats()">
                <h4>ðŸ“Š Session Statistics</h4>
                <span class="session-stats-toggle" id="sessionStatsToggle">â–¼</span>
            </div>
            <div class="session-stats-content" id="sessionStatsContent">
                <div class="stat-row">
                    <span class="stat-label">Cards Reviewed:</span>
                    <span class="stat-value" id="cardsReviewed">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Time Studying:</span>
                    <span class="stat-value" id="timeStudying">00:00</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Cards per Minute:</span>
                    <span class="stat-value" id="cardsPerMinute">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Session Started:</span>
                    <span class="stat-value" id="sessionStart">--:--</span>
                </div>
            </div>
        </div>

        <!-- Practice Mode Button -->
        <button class="practice-mode-btn" id="practiceModeBtn" onclick="togglePracticeMode()">
            ðŸŽ¯ Start Practice Mode - Focus Only on Flashcards
        </button>

        <!-- View Mode Toggle - Card vs Transcript (hidden until flashcards loaded) -->
        <div class="view-mode-toggle" id="viewModeToggle" style="display: none;">
            <button class="view-mode-btn active" id="cardModeBtn" onclick="switchViewMode('card')">
                ðŸƒ Card Mode
            </button>
            <button class="view-mode-btn" id="transcriptModeBtn" onclick="switchViewMode('transcript')">
                ðŸ“œ Transcript Mode
            </button>
        </div>

        <!-- Quick Actions (Control buttons) -->
        <div class="quick-actions" id="quickActions" style="margin: 20px 0;">
            <button class="quick-action-btn autoplay-btn" id="autoplayBtn">â–¶ Auto-Play</button>
            <button class="quick-action-btn" id="shuffleBtn">ðŸ”€ Shuffle</button>
            <button class="quick-action-btn" id="learnedBtn">âœ“ Mark Learned</button>
            <button class="quick-action-btn" id="unlearnedBtn" style="display: none;">âœ— Mark Unlearned</button>
            <button class="quick-action-btn" id="showLearnedBtn">ðŸ‘ Show All</button>
            <button class="quick-action-btn" id="remapColumnsBtn" style="background: #f59e0b;">ðŸŽ¯ Remap Columns</button>
            <div class="repeat-dropdown" style="display: inline-block;">
                <button class="quick-action-btn" id="repeatBtn" style="background: #8b5cf6; color: white;">ðŸ” Repeat</button>
                <div class="repeat-dropdown-menu" id="repeatDropdown">
                    <div class="repeat-dropdown-item" data-action="all">ðŸ”„ Repeat All Cards</div>
                    <div class="repeat-dropdown-item" data-action="learned">âœ“ Repeat Learned Only</div>
                    <div class="repeat-dropdown-item" data-action="unlearned">âœ— Repeat Unlearned Only</div>
                    <div class="repeat-dropdown-item" data-action="current">ðŸ”Š Replay Current Card</div>
                </div>
            </div>
            <button class="quick-action-btn" id="resetCardBtn" style="background: #06b6d4; color: white;" onclick="resetToBeginning('card')" title="Reset to first card">â†º Reset</button>
            <button class="quick-action-btn" id="minimizeBtn" style="background: #06b6d4; color: white;" onclick="window.toggleMinimizeMode()" title="Minimize flashcard to corner">â¬‡ï¸ Minimize</button>
            <button class="quick-action-btn" id="deleteRecordBtn" style="background: #ef4444; color: white;">ðŸ—‘ï¸ Delete</button>
        </div>

        <!-- Floating Practice Mode Controls -->
        <div class="practice-mode-controls" id="practiceModeControls">
            <button class="floating-control-btn stop" onclick="togglePracticeMode()">
                â¹ï¸ Stop Practice
            </button>
            <button class="floating-control-btn" onclick="document.getElementById('settingsToggleBtn').click()">
                âš™ï¸ Settings
            </button>
        </div>

        <div class="flashcard-container" id="flashcardContainer">
            <div class="flashcard" id="flashcard">
                <div class="card-lang1-section">
                    <button class="audio-btn" id="audioBtn" title="Pronounce Source word">ðŸ”Š</button>
                    <div class="learned-badge" id="learnedBadge" style="display: none;">âœ“ Learned</div>
                    <div class="unlearned-badge" id="unlearnedBadge" style="display: none;">âœ— Unlearned</div>
                    <div class="card-label">ðŸ“– Source Language</div>
                    <div class="card-content" id="germanWord"></div>
                    <div class="card-detail" id="detailFront"></div>
                    <div class="review-info" id="reviewInfo"></div>
                    <hr class="card-divider">
                    <button class="reveal-btn" id="revealBtn">ðŸ‘ Show Target Meaning</button>
                </div>
                <div class="card-lang2-section" id="englishSection">
                    <div class="card-label">ðŸŽ¯ Target Language Translation</div>
                    <div class="card-content" id="englishWord"></div>
                    <div class="card-detail" id="detailBack"></div>
                    <button class="audio-btn-lang2" id="audioBtnEnglish" title="Pronounce Target word">ðŸ”Š</button>
                </div>
            </div>
            <div class="hint">ðŸ‘† Click "Show Target Meaning" or Space to reveal | ðŸ”Š P for Source | E for Target pronunciation</div>
        </div>

        <!-- Transcript View Container (Conversation Mode) -->
        <div id="transcriptView" style="display: none;">
            <!-- Transcript Controls -->
            <div class="transcript-controls">
                <button class="transcript-btn play" id="transcriptPlayBtn" onclick="toggleTranscriptPlayback()">
                    â–¶ï¸ Play All
                </button>
                <button class="transcript-btn pause" id="transcriptPauseBtn" onclick="pauseTranscriptPlayback()" style="display: none;">
                    â¸ï¸ Pause
                </button>
                <button class="transcript-btn stop" id="transcriptStopBtn" onclick="stopTranscriptPlayback()">
                    â¹ï¸ Stop
                </button>
                <button class="transcript-btn" onclick="shuffleTranscript()">
                    ðŸ”€ Shuffle
                </button>
                <button class="transcript-btn" onclick="remapTranscriptColumns()">
                    ðŸŽ¯ Remap Columns
                </button>
                <div class="repeat-dropdown" style="display: inline-block;">
                    <button class="transcript-btn" id="transcriptRepeatBtn" style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);">
                        ðŸ” Repeat
                    </button>
                    <div class="repeat-dropdown-menu" id="transcriptRepeatDropdown">
                        <div class="repeat-dropdown-item" data-action="all">ðŸ”„ Repeat All Cards</div>
                        <div class="repeat-dropdown-item" data-action="learned">âœ“ Repeat Learned Only</div>
                        <div class="repeat-dropdown-item" data-action="unlearned">âœ— Repeat Unlearned Only</div>
                        <div class="repeat-dropdown-item" data-action="current">ðŸ”Š Replay Current Card</div>
                    </div>
                </div>
                <button class="transcript-btn" onclick="resetToBeginning('transcript')" style="background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);" title="Reset to first card">
                    â†º Reset
                </button>
                <button class="transcript-btn" onclick="deleteCurrentTranscriptCard()" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);">
                    ðŸ—‘ï¸ Delete Current
                </button>
            </div>

            <!-- Transcript Navigation -->
            <div class="navigation" id="transcriptNavigation">
                <button class="nav-button" id="transcriptPrevBtn">â† Previous</button>
                <div class="progress" id="transcriptProgressNav">
                    <input type="number" id="transcriptCurrentInput" min="1" value="1"
                           style="width: 60px; text-align: center; font-size: 1.1em; font-weight: bold; border: 2px solid #667eea; border-radius: 5px; padding: 5px; background: white;"
                           title="Enter card number to jump to" />
                    <span style="font-weight: bold;"> / </span>
                    <span id="transcriptTotalCards">1</span>
                </div>
                <button class="nav-button" id="transcriptNextBtn">Next â†’</button>
            </div>

            <!-- Transcript Progress -->
            <div class="transcript-progress" id="transcriptProgress">
                Ready to play - Press Space or click Play
            </div>

            <!-- Transcript Container -->
            <div class="transcript-container" id="transcriptContainer">
                <div class="transcript-empty">
                    ðŸ“œ Load a CSV file to see transcript mode<br>
                    <small style="color: #ccc;">Switch to Transcript Mode to see all sentences at once</small>
                </div>
            </div>
        </div>

        <div class="navigation" id="navigation">
            <button class="nav-button" id="prevBtn">â† Previous</button>
            <div class="progress" id="progress">
                <input type="number" id="currentCardInput" min="1" value="1"
                       style="width: 60px; text-align: center; font-size: 1.1em; font-weight: bold; border: 2px solid #667eea; border-radius: 5px; padding: 5px; background: white;"
                       title="Enter card number to jump to" />
                <span style="font-weight: bold;"> / </span>
                <span id="totalCards">1</span>
            </div>
            <button class="nav-button" id="nextBtn">Next â†’</button>
        </div>
    </div>

    <!-- Firebase SDK (Must load BEFORE main script) -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

    <!-- CryptoJS for encryption (Must load BEFORE main script) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

    <!-- Pako for compression (Must load BEFORE main script) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

    <!-- JSZip for creating ZIP files (Must load BEFORE main script) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script>
        let flashcards = [];
        let currentIndex = 0;
        let showOnlyUnlearned = false;
        let filterMode = 'all'; // 'all', 'unlearned', 'learned'
        let filteredCards = [];
        let currentFileName = '';
        let alwaysShowMeanings = false;
        let readExtendedContent = false; // New: toggle for reading extended examples/sentences

        // Language code detection for TTS (supports cloud voices without installation)
        let detectedSourceLang = 'de-DE'; // Default: German
        let detectedTargetLang = 'en-US'; // Default: English

        // Column mapping variables
        let rawFileData = null;
        let detectedSeparator = ',';
        let columnMapping = null; // null = auto-detect, or {col0: 'lang1', col1: 'lang1Extended', ...}

        // Category management
        let categories = {};
        let fileCategories = {};
        let currentFileCategory = { category: 'Default', subcategory: '' };
        let categoryGroups = {}; // Maps category names to custom group names: { "German": "German Learning", ... }

        // Auto-play variables
        let isAutoPlaying = false;
        let autoplayTimeout = null;
        let autoplayEnglishEnabled = false;
        let delayBetweenLangs = 4000; // milliseconds
        let delayBeforeNext = 4000; // milliseconds

        // Advanced feature variables
        let loopModeEnabled = false;
        let repeatSourceCount = 1;
        let repeatTargetCount = 1;
        let currentSourceRepeat = 0;
        let currentTargetRepeat = 0;
        let studyTimerEnabled = false;
        let sleepTimerEnabled = false;
        let timerInterval = null;
        let timerEndTime = null;

        // Session stats variables
        let sessionStartTime = null;
        let cardsReviewedCount = 0;
        let statsInterval = null;

        // Recording variables
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStartTime = null;
        let recordingTimerInterval = null;
        let recordedAudioBlob = null;
        let isRecording = false;

        // Cloud Sync Variables
        let cloudUser = null; // {username, passwordHash}
        let firebaseDB = null;
        let isCloudEnabled = false;
        let isCloudFirstMode = false; // When true, saves directly to cloud instead of localStorage
        let cloudDataCache = {}; // In-memory cache of flashcard data (for cloud-first mode)
        let pendingCloudSync = new Set(); // Track files that need to be synced to cloud (for retry logic)
        let progressDataCache = {}; // Track position for each file (synced with Firebase)

        // ========================================
        // TRANSCRIPT MODE VARIABLES (New Feature)
        // ========================================
        let flashcardViewMode = 'card'; // 'card' or 'transcript' (renamed to avoid conflict with category browser)
        let transcriptPlaying = false;
        let transcriptCurrentIndex = 0;
        let transcriptUtterance = null;
        let transcriptSourceRepeat = 0; // Track current source repeat count
        let transcriptTargetRepeat = 0; // Track current target repeat count
        let transcriptTimeout = null; // For delays between languages and cards

        // ===== FIREBASE CONFIGURATION =====
        // ðŸ”’ SECURITY NOTE: This API key is SAFE to be public!
        //
        // Firebase API keys are designed to be included in client-side code.
        // According to Google's official documentation:
        // "Unlike how API keys are typically used, API keys for Firebase services
        // are not used to control access to backend resources."
        //
        // Actual security is provided by:
        // 1. Firebase Security Rules (configured in Firebase Console)
        // 2. Client-side encryption (all data encrypted with user password)
        // 3. Password hashing (SHA-256, stored securely)
        //
        // See FIREBASE_SECURITY_SETUP_GUIDE.md for complete security details.
        // ===================================
        const firebaseConfig = {
            apiKey: "AIzaSyCci_5AhIKW3VPnFu8LFBDJQxYQvPbOUlE",
            authDomain: "flashcard-sync-15835.firebaseapp.com",
            databaseURL: "https://flashcard-sync-15835-default-rtdb.firebaseio.com",
            projectId: "flashcard-sync-15835",
            storageBucket: "flashcard-sync-15835.firebasestorage.app",
            messagingSenderId: "220998447564",
            appId: "1:220998447564:web:d258c84f0cbfb882da2d69"
        };
        // ===================================

        // Speech synthesis for audio pronunciation
        const synth = window.speechSynthesis;
        let sourceVoice = null;
        let targetVoice = null;
        let allVoices = [];
        let speechRate = 1.0;
        let speechPitch = 1.0;

        // Load voices - Universal version supporting all languages
        function loadVoices() {
            allVoices = synth.getVoices();

            // Edge browser may return empty array initially - skip until voices are loaded
            if (allVoices.length === 0) {
                console.log('â³ Voices not loaded yet, waiting...');
                return;
            }

            console.log('âœ… Voices loaded successfully:', allVoices.length);

            // Sort ALL voices by quality (Google > Microsoft > Others) and then alphabetically by language code
            let sortedVoices = [...allVoices];

            sortedVoices.sort((a, b) => {
                // Priority order: Google > Microsoft > Others, then alphabetically by language
                const aIsGoogle = a.name.toLowerCase().includes('google');
                const bIsGoogle = b.name.toLowerCase().includes('google');
                const aIsMicrosoft = a.name.toLowerCase().includes('microsoft');
                const bIsMicrosoft = b.name.toLowerCase().includes('microsoft');

                // Sort by provider quality first
                if (aIsGoogle && !bIsGoogle) return -1;
                if (!aIsGoogle && bIsGoogle) return 1;
                if (aIsMicrosoft && !bIsMicrosoft) return -1;
                if (!aIsMicrosoft && bIsMicrosoft) return 1;

                // Then sort alphabetically by language code
                return a.lang.localeCompare(b.lang);
            });

            // ADD COMMON LANGUAGES as selectable options (even if not installed)
            // These will use browser's cloud TTS
            const commonLanguages = [
                { lang: 'ar-SA', name: 'Arabic (Saudi Arabia)', flag: 'ðŸ‡¸ðŸ‡¦' },
                { lang: 'zh-CN', name: 'Chinese (Simplified)', flag: 'ðŸ‡¨ðŸ‡³' },
                { lang: 'zh-TW', name: 'Chinese (Traditional)', flag: 'ðŸ‡¹ðŸ‡¼' },
                { lang: 'da-DK', name: 'Danish', flag: 'ðŸ‡©ðŸ‡°' },
                { lang: 'nl-NL', name: 'Dutch', flag: 'ðŸ‡³ðŸ‡±' },
                { lang: 'en-US', name: 'English (US)', flag: 'ðŸ‡ºðŸ‡¸' },
                { lang: 'en-GB', name: 'English (UK)', flag: 'ðŸ‡¬ðŸ‡§' },
                { lang: 'fi-FI', name: 'Finnish', flag: 'ðŸ‡«ðŸ‡®' },
                { lang: 'fr-FR', name: 'French', flag: 'ðŸ‡«ðŸ‡·' },
                { lang: 'de-DE', name: 'German', flag: 'ðŸ‡©ðŸ‡ª' },
                { lang: 'el-GR', name: 'Greek', flag: 'ðŸ‡¬ðŸ‡·' },
                { lang: 'he-IL', name: 'Hebrew', flag: 'ðŸ‡®ðŸ‡±' },
                { lang: 'hi-IN', name: 'Hindi', flag: 'ðŸ‡®ðŸ‡³' },
                { lang: 'hu-HU', name: 'Hungarian', flag: 'ðŸ‡­ðŸ‡º' },
                { lang: 'it-IT', name: 'Italian', flag: 'ðŸ‡®ðŸ‡¹' },
                { lang: 'ja-JP', name: 'Japanese', flag: 'ðŸ‡¯ðŸ‡µ' },
                { lang: 'ko-KR', name: 'Korean', flag: 'ðŸ‡°ðŸ‡·' },
                { lang: 'no-NO', name: 'Norwegian', flag: 'ðŸ‡³ðŸ‡´' },
                { lang: 'fa-IR', name: 'Persian / Farsi (ÙØ§Ø±Ø³ÛŒ)', flag: 'ðŸ‡®ðŸ‡·' },
                { lang: 'pl-PL', name: 'Polish', flag: 'ðŸ‡µðŸ‡±' },
                { lang: 'pt-BR', name: 'Portuguese (Brazil)', flag: 'ðŸ‡§ðŸ‡·' },
                { lang: 'pt-PT', name: 'Portuguese (Portugal)', flag: 'ðŸ‡µðŸ‡¹' },
                { lang: 'ro-RO', name: 'Romanian', flag: 'ðŸ‡·ðŸ‡´' },
                { lang: 'ru-RU', name: 'Russian', flag: 'ðŸ‡·ðŸ‡º' },
                { lang: 'es-ES', name: 'Spanish (Spain)', flag: 'ðŸ‡ªðŸ‡¸' },
                { lang: 'es-MX', name: 'Spanish (Mexico)', flag: 'ðŸ‡²ðŸ‡½' },
                { lang: 'sv-SE', name: 'Swedish', flag: 'ðŸ‡¸ðŸ‡ª' },
                { lang: 'th-TH', name: 'Thai', flag: 'ðŸ‡¹ðŸ‡­' },
                { lang: 'tr-TR', name: 'Turkish', flag: 'ðŸ‡¹ðŸ‡·' },
                { lang: 'uk-UA', name: 'Ukrainian', flag: 'ðŸ‡ºðŸ‡¦' },
                { lang: 'vi-VN', name: 'Vietnamese', flag: 'ðŸ‡»ðŸ‡³' }
            ];

            // Add common languages if not already in installed voices
            commonLanguages.forEach(commonLang => {
                const alreadyExists = sortedVoices.some(v => v.lang.startsWith(commonLang.lang.split('-')[0]));
                if (!alreadyExists) {
                    // Create virtual voice object
                    sortedVoices.push({
                        name: `${commonLang.flag} ${commonLang.name} [Cloud TTS]`,
                        lang: commonLang.lang,
                        localService: false,
                        default: false,
                        voiceURI: `cloud-${commonLang.lang}`,
                        isVirtual: true // Mark as virtual (not installed)
                    });
                }
            });

            console.log(`ðŸ“¢ Total voices available (installed + cloud): ${sortedVoices.length}`);

            // Set default voices (prefer first Google voice, fallback to first available)
            sourceVoice = sortedVoices.find(v => v.name.toLowerCase().includes('google'))
                || sortedVoices[0]
                || allVoices[0];

            targetVoice = sortedVoices.find(v => v.name.toLowerCase().includes('google') && v !== sourceVoice)
                || sortedVoices[1]
                || sortedVoices[0]
                || allVoices[0];

            // Populate source voice dropdown with enhanced labels
            const sourceSelect = document.getElementById('sourceVoiceSelect');
            sourceSelect.innerHTML = '';
            sortedVoices.forEach((voice, index) => {
                const option = document.createElement('option');
                option.value = index;

                // Enhanced label with provider and quality indicators
                let label = voice.name;
                if (voice.isVirtual) {
                    // Virtual/cloud voice - already has flag in name
                    label = `â˜ï¸ ${voice.name}`;
                } else if (voice.name.toLowerCase().includes('google')) {
                    label = `ðŸ”Š ${voice.name} (${voice.lang})`;
                } else if (voice.name.toLowerCase().includes('microsoft')) {
                    label = `ðŸŽ™ï¸ ${voice.name} (${voice.lang})`;
                } else {
                    label = `${voice.name} (${voice.lang})`;
                }

                option.textContent = label;

                // Mark default as selected
                if (voice === sourceVoice) {
                    option.selected = true;
                }

                sourceSelect.appendChild(option);
            });

            // Populate target voice dropdown with enhanced labels
            const targetSelect = document.getElementById('targetVoiceSelect');
            targetSelect.innerHTML = '';
            sortedVoices.forEach((voice, index) => {
                const option = document.createElement('option');
                option.value = index;

                // Enhanced label with provider and quality indicators
                let label = voice.name;
                if (voice.isVirtual) {
                    // Virtual/cloud voice - already has flag in name
                    label = `â˜ï¸ ${voice.name}`;
                } else if (voice.name.toLowerCase().includes('google')) {
                    label = `ðŸ”Š ${voice.name} (${voice.lang})`;
                } else if (voice.name.toLowerCase().includes('microsoft')) {
                    label = `ðŸŽ™ï¸ ${voice.name} (${voice.lang})`;
                } else {
                    label = `${voice.name} (${voice.lang})`;
                }

                option.textContent = label;

                // Mark default as selected
                if (voice === targetVoice) {
                    option.selected = true;
                }

                targetSelect.appendChild(option);
            });

            // Store sorted voices for easy access
            sourceSelect.dataset.voices = JSON.stringify(sortedVoices.map(v => v.name));
            targetSelect.dataset.voices = JSON.stringify(sortedVoices.map(v => v.name));

            // Update voice info displays
            updateVoiceInfo('source', sourceVoice);
            updateVoiceInfo('target', targetVoice);

            // Log default voices for debugging
            console.log('âœ… Universal Voice System Loaded');
            console.log('Default Source Voice:', sourceVoice ? sourceVoice.name : 'None');
            console.log('Default Target Voice:', targetVoice ? targetVoice.name : 'None');
            console.log('Total voices available:', sortedVoices.length);
        }

        // Update voice info display
        function updateVoiceInfo(language, voice) {
            const infoElement = document.getElementById(language + 'VoiceInfo');
            if (!voice || !infoElement) return;

            let info = '';
            const isGoogle = voice.name.toLowerCase().includes('google');
            const isMicrosoft = voice.name.toLowerCase().includes('microsoft');
            const isVirtual = voice.isVirtual;

            if (isVirtual) {
                info = 'â˜ï¸ <strong>Cloud Voice</strong> - Online Text-to-Speech (works on any device without installation)';
            } else if (isGoogle) {
                info = 'ðŸ”Š <strong>Google Voice</strong> - Premium quality, natural pronunciation (Recommended for learning)';
            } else if (isMicrosoft) {
                info = 'ðŸŽ™ï¸ <strong>Microsoft Voice</strong> - High quality, clear enunciation';
            } else {
                info = 'ðŸ“¢ <strong>System Voice</strong> - Standard quality';
            }

            // Add voice details
            info += `<br><span style="color: #888;">Voice: ${voice.name} | Language: ${voice.lang}</span>`;

            infoElement.innerHTML = info;
        }

        // Load voices on page load with Edge browser support
        if (synth.onvoiceschanged !== undefined) {
            synth.onvoiceschanged = loadVoices;
        }

        // Initial load
        loadVoices();

        // Edge browser often needs extra time to load voices
        // Retry after delays to ensure voices are loaded
        setTimeout(loadVoices, 500);
        setTimeout(loadVoices, 1000);
        setTimeout(loadVoices, 2000);

        // Category Management Functions
        function loadCategories() {
            const saved = safeStorage.getItem('flashcard_categories');
            if (saved) {
                categories = JSON.parse(saved);
            } else {
                categories = { 'Default': [] };
            }

            const savedFiles = safeStorage.getItem('flashcard_file_categories');
            if (savedFiles) {
                fileCategories = JSON.parse(savedFiles);
                // Cleanup is now done explicitly during login, not here
            }

            const savedGroups = safeStorage.getItem('flashcard_category_groups');
            if (savedGroups) {
                categoryGroups = JSON.parse(savedGroups);
            }

            updateCategoryDropdowns();
            renderCategoryList();
        }

        function saveCategories() {
            safeStorage.setItem('flashcard_categories', JSON.stringify(categories));
            safeStorage.setItem('flashcard_file_categories', JSON.stringify(fileCategories));
            safeStorage.setItem('flashcard_category_groups', JSON.stringify(categoryGroups));

            // Auto-sync to cloud if enabled
            if (isCloudEnabled) {
                uploadToCloud();
            }
        }

        function createCategory() {
            const name = document.getElementById('newCategoryName').value.trim();
            if (!name) {
                alert('Please enter a category name');
                return;
            }
            if (categories[name]) {
                alert('Category already exists!');
                return;
            }

            categories[name] = [];
            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();
            renderCategoryBrowser();
            document.getElementById('newCategoryName').value = '';
            alert(`Category "${name}" created!`);
        }

        function createSubcategory() {
            const parent = document.getElementById('parentCategorySelect').value;
            const name = document.getElementById('newSubcategoryName').value.trim();

            if (!name) {
                alert('Please enter a subcategory name');
                return;
            }

            if (!categories[parent]) {
                alert('Parent category not found!');
                return;
            }

            if (categories[parent].includes(name)) {
                alert('Subcategory already exists!');
                return;
            }

            categories[parent].push(name);
            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();
            renderCategoryBrowser();
            document.getElementById('newSubcategoryName').value = '';
            alert(`Subcategory "${name}" added to "${parent}"!`);
        }

        function assignCategory() {
            if (!currentFileName) {
                alert('No file loaded!');
                return;
            }

            const category = document.getElementById('categorySelect').value;
            let subcategory = document.getElementById('subcategorySelect').value;

            // âš ï¸ VALIDATION: Check for duplicate subcategory (only for new subcategories)
            if (subcategory && categories[category] && categories[category].includes(subcategory)) {
                // Check if this is a different file trying to use an existing subcategory
                const existingFileWithSubcat = Object.keys(fileCategories).find(fileName =>
                    fileName !== currentFileName &&
                    fileCategories[fileName].category === category &&
                    fileCategories[fileName].subcategory === subcategory
                );

                if (existingFileWithSubcat) {
                    const proposedSubcategory = generateUniqueSubcategory(category, subcategory);

                    // Show error dialog with proposed solution
                    const userResponse = confirm(
                        'âš ï¸ DUPLICATE SUBCATEGORY DETECTED!\n\n' +
                        `Subcategory: "${subcategory}"\n` +
                        `Already used by file: "${existingFileWithSubcat}"\n` +
                        `In category: "${category}"\n\n` +
                        `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n` +
                        `PROPOSED SOLUTION:\n` +
                        `ðŸ“ New subcategory: "${proposedSubcategory}"\n\n` +
                        `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n` +
                        `Click OK to use the new subcategory name.\n` +
                        `Click CANCEL to keep the same subcategory (files will be grouped together).`
                    );

                    if (userResponse) {
                        // User accepted - use proposed subcategory
                        subcategory = proposedSubcategory;
                        console.log(`âœ… Using proposed subcategory: ${proposedSubcategory}`);
                    } else {
                        console.log(`âœ… User chose to use existing subcategory: ${subcategory}`);
                        // User wants to keep the same subcategory (files will be grouped)
                    }
                }
            }

            fileCategories[currentFileName] = { category, subcategory };
            currentFileCategory = { category, subcategory };

            // Update all current flashcards with the new category/subcategory
            flashcards.forEach(card => {
                card.category = category;
                card.subcategory = subcategory || '';
            });

            // Save updated flashcards
            saveToStorage();

            saveCategories();
            updateCurrentFileDisplay();
            renderCategoryBrowser();

            // Hide manage categories and show format selector
            document.getElementById('mainManageCategories').style.display = 'none';
            const formatSelector = document.getElementById('formatSelector');
            if (formatSelector) {
                formatSelector.style.display = 'block';
                console.log('   âœ… Format selector shown after manual category assignment');
            }

            const subText = subcategory ? ` > ${subcategory}` : '';
            alert(`File mapped to: ${category}${subText}\n\nNext: Choose how to load your file below!`);
        }

        function updateCategoryDropdowns() {
            const categorySelect = document.getElementById('categorySelect');
            const parentSelect = document.getElementById('parentCategorySelect');
            const subcategorySelect = document.getElementById('subcategorySelect');

            // Update category selects
            [categorySelect, parentSelect].forEach(select => {
                const current = select.value;
                select.innerHTML = '';
                Object.keys(categories).forEach(cat => {
                    const option = document.createElement('option');
                    option.value = cat;
                    option.textContent = cat;
                    select.appendChild(option);
                });
                if (current && categories[current]) {
                    select.value = current;
                }
            });

            // Update subcategory select
            updateSubcategoryDropdown();
        }

        function updateSubcategoryDropdown() {
            const category = document.getElementById('categorySelect').value;
            const subcategorySelect = document.getElementById('subcategorySelect');

            subcategorySelect.innerHTML = '<option value="">No Subcategory</option>';

            if (categories[category]) {
                categories[category].forEach(sub => {
                    const option = document.createElement('option');
                    option.value = sub;
                    option.textContent = sub;
                    subcategorySelect.appendChild(option);
                });
            }
        }

        function renderCategoryList() {
            const listDiv = document.getElementById('categoryList');
            listDiv.innerHTML = '';

            Object.keys(categories).forEach(cat => {
                const catDiv = document.createElement('div');
                catDiv.className = 'category-item';
                catDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid #e2e8f0;';

                const catInfo = document.createElement('span');
                catInfo.style.cssText = 'display: flex; align-items: center; gap: 8px; flex: 1;';

                // Editable category name (ALL categories are now editable, including Default)
                const editableSpan = document.createElement('strong');
                editableSpan.textContent = cat;
                editableSpan.contentEditable = true;
                editableSpan.style.cssText = `
                    outline: none;
                    padding: 4px 8px;
                    border-radius: 4px;
                    min-width: 100px;
                    cursor: text;
                    background: #f0f9ff;
                    border: 1px solid #bfdbfe;
                `;
                editableSpan.setAttribute('data-original-name', cat);
                editableSpan.setAttribute('data-type', 'category');
                editableSpan.title = 'Click to edit (press Enter to save)';

                // Save on blur or Enter key (ALL categories are editable now)
                editableSpan.addEventListener('blur', function() {
                    saveCategoryEdit(this);
                });
                editableSpan.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.blur();
                    }
                    if (e.key === 'Escape') {
                        this.textContent = this.getAttribute('data-original-name');
                        this.blur();
                    }
                });

                catInfo.innerHTML = 'ðŸ“ ';
                catInfo.appendChild(editableSpan);

                // Group assignment (editable)
                const groupSpan = document.createElement('span');
                const currentGroup = categoryGroups[cat] || '(Auto)';
                groupSpan.textContent = currentGroup;
                groupSpan.contentEditable = true;
                groupSpan.style.cssText = `
                    outline: none;
                    padding: 3px 8px;
                    margin-left: 10px;
                    border-radius: 6px;
                    font-size: 0.85em;
                    cursor: text;
                    background: linear-gradient(135deg, #e0f2fe 0%, #ddd6fe 100%);
                    border: 1px solid #c7d2fe;
                    color: #4338ca;
                    font-weight: 500;
                `;
                groupSpan.setAttribute('data-category', cat);
                groupSpan.setAttribute('data-original-group', currentGroup);
                groupSpan.title = 'Click to edit group name (press Enter to save, leave empty to use auto-detect)';

                // Save group assignment
                groupSpan.addEventListener('blur', function() {
                    saveGroupAssignment(this);
                });
                groupSpan.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.blur();
                    }
                    if (e.key === 'Escape') {
                        this.textContent = this.getAttribute('data-original-group');
                        this.blur();
                    }
                });

                catInfo.appendChild(groupSpan);

                const actions = document.createElement('div');
                actions.style.cssText = 'display: flex; gap: 5px;';

                // Delete button (now available for ALL categories including Default)
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'âœ•';
                deleteBtn.className = 'btn-small';
                deleteBtn.style.cssText = 'background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; padding: 6px 10px; font-size: 1em;';
                deleteBtn.title = 'Delete category';
                deleteBtn.onclick = () => deleteCategory(cat);
                actions.appendChild(deleteBtn);

                catDiv.appendChild(catInfo);
                catDiv.appendChild(actions);
                listDiv.appendChild(catDiv);

                // Add subcategories
                if (categories[cat] && categories[cat].length > 0) {
                    categories[cat].forEach(sub => {
                        const subDiv = document.createElement('div');
                        subDiv.className = 'category-item subcategory-item';
                        subDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px 8px 8px 30px; border-bottom: 1px solid #f1f5f9;';

                        const subInfo = document.createElement('span');
                        subInfo.style.cssText = 'display: flex; align-items: center; gap: 8px; flex: 1;';

                        // Editable subcategory name
                        const editableSubSpan = document.createElement('span');
                        editableSubSpan.textContent = sub;
                        editableSubSpan.contentEditable = true;
                        editableSubSpan.style.cssText = `
                            outline: none;
                            padding: 4px 8px;
                            border-radius: 4px;
                            cursor: text;
                            background: #fef3c7;
                            border: 1px solid #fde68a;
                            min-width: 100px;
                        `;
                        editableSubSpan.setAttribute('data-original-name', sub);
                        editableSubSpan.setAttribute('data-parent', cat);
                        editableSubSpan.setAttribute('data-type', 'subcategory');
                        editableSubSpan.title = 'Click to edit (press Enter to save)';

                        // Save on blur or Enter key
                        editableSubSpan.addEventListener('blur', function() {
                            saveSubcategoryEdit(this);
                        });
                        editableSubSpan.addEventListener('keydown', function(e) {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                this.blur();
                            }
                            if (e.key === 'Escape') {
                                this.textContent = this.getAttribute('data-original-name');
                                this.blur();
                            }
                        });

                        subInfo.innerHTML = 'â””â”€ ';
                        subInfo.appendChild(editableSubSpan);

                        const subActions = document.createElement('div');
                        const deleteSubBtn = document.createElement('button');
                        deleteSubBtn.textContent = 'âœ•';
                        deleteSubBtn.className = 'btn-small';
                        deleteSubBtn.style.cssText = 'background: #f59e0b; color: white; border: none; border-radius: 4px; cursor: pointer; padding: 6px 10px; font-size: 1em;';
                        deleteSubBtn.title = 'Delete subcategory';
                        deleteSubBtn.onclick = () => deleteSubcategory(cat, sub);
                        subActions.appendChild(deleteSubBtn);

                        subDiv.appendChild(subInfo);
                        subDiv.appendChild(subActions);
                        listDiv.appendChild(subDiv);
                    });
                }
            });
        }

        // Save category edit (inline editing)
        function saveCategoryEdit(element) {
            const oldName = element.getAttribute('data-original-name');
            const newName = element.textContent.trim();

            // Validate
            if (!newName) {
                alert('Category name cannot be empty!');
                element.textContent = oldName;
                return;
            }

            if (newName === oldName) {
                return; // No change
            }

            if (categories[newName]) {
                alert(`Category "${newName}" already exists!`);
                element.textContent = oldName;
                return;
            }

            // Rename category
            categories[newName] = categories[oldName];
            delete categories[oldName];

            // Update all file mappings
            Object.keys(fileCategories).forEach(file => {
                if (fileCategories[file].category === oldName) {
                    fileCategories[file].category = newName;
                }
            });

            // Update group mapping if exists
            if (categoryGroups[oldName]) {
                categoryGroups[newName] = categoryGroups[oldName];
                delete categoryGroups[oldName];
            }

            // Save and refresh
            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();
            renderCategoryBrowser();

            console.log(`âœ… Category renamed: "${oldName}" â†’ "${newName}"`);
            alert(`âœ“ Category renamed to "${newName}"`);
        }

        // Save subcategory edit (inline editing)
        function saveSubcategoryEdit(element) {
            const oldName = element.getAttribute('data-original-name');
            const newName = element.textContent.trim();
            const parentCategory = element.getAttribute('data-parent');

            // Validate
            if (!newName) {
                alert('Subcategory name cannot be empty!');
                element.textContent = oldName;
                return;
            }

            if (newName === oldName) {
                return; // No change
            }

            if (categories[parentCategory].includes(newName)) {
                alert(`Subcategory "${newName}" already exists!`);
                element.textContent = oldName;
                return;
            }

            // Rename subcategory
            const index = categories[parentCategory].indexOf(oldName);
            if (index > -1) {
                categories[parentCategory][index] = newName;
            }

            // Update all file mappings
            Object.keys(fileCategories).forEach(file => {
                if (fileCategories[file].category === parentCategory && fileCategories[file].subcategory === oldName) {
                    fileCategories[file].subcategory = newName;
                }
            });

            // Save and refresh
            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();
            renderCategoryBrowser();

            console.log(`âœ… Subcategory renamed: "${oldName}" â†’ "${newName}" (in ${parentCategory})`);
            alert(`âœ“ Subcategory renamed to "${newName}"`);
        }

        // Save group assignment (inline editing)
        function saveGroupAssignment(element) {
            const categoryName = element.getAttribute('data-category');
            const oldGroup = element.getAttribute('data-original-group');
            const newGroup = element.textContent.trim();

            // If empty or "(Auto)", remove custom mapping to use auto-detect
            if (!newGroup || newGroup === '(Auto)' || newGroup === oldGroup) {
                if (newGroup === '' || newGroup === '(Auto)') {
                    // Remove custom mapping
                    delete categoryGroups[categoryName];
                    element.textContent = '(Auto)';
                    element.setAttribute('data-original-group', '(Auto)');
                    saveCategories();
                    renderCategoryBrowser();
                    console.log(`âœ… Group assignment removed for "${categoryName}" - using auto-detect`);
                }
                return;
            }

            // Set custom group mapping
            categoryGroups[categoryName] = newGroup;
            element.setAttribute('data-original-group', newGroup);

            // Save and refresh
            saveCategories();
            renderCategoryBrowser();

            console.log(`âœ… Category "${categoryName}" assigned to group: "${newGroup}"`);
            // Don't show alert for smoother UX
        }

        function deleteCategory(category) {
            // REMOVED RESTRICTIONS: User can now delete ANY category including Default and the last category
            // This allows complete cleanup of all categories if needed

            // Find all files in this category
            const filesToDelete = Object.keys(fileCategories).filter(file =>
                fileCategories[file].category === category
            );

            // Show detailed confirmation
            const subcategoryCount = categories[category] ? categories[category].length : 0;
            const confirmMessage = `âš ï¸ DELETE CATEGORY CONFIRMATION âš ï¸\n\n` +
                `Category: "${category}"\n` +
                `Subcategories: ${subcategoryCount}\n` +
                `Files to delete: ${filesToDelete.length}\n\n` +
                `This will permanently delete:\n` +
                `âœ— The category and all subcategories\n` +
                `âœ— All ${filesToDelete.length} files in this category\n` +
                `âœ— All flashcard data from localStorage\n` +
                `âœ— All flashcard data from cloud (if synced)\n\n` +
                `âš ï¸ THIS CANNOT BE UNDONE!\n\n` +
                `Are you sure you want to proceed?`;

            if (!confirm(confirmMessage)) {
                return;
            }

            // Delete all files and their data
            let deletedCount = 0;
            filesToDelete.forEach(fileName => {
                // Remove from localStorage
                safeStorage.removeItem(`flashcards_${fileName}`);

                // Remove from fileCategories mapping
                delete fileCategories[fileName];

                // Remove from global flashcards array if currently loaded
                if (currentFileName === fileName) {
                    flashcards = [];
                    filteredCards = [];
                    currentIndex = 0;
                    currentFileName = '';
                }

                deletedCount++;
                console.log(`ðŸ—‘ï¸ Deleted file: ${fileName}`);
            });

            // Delete the category itself
            delete categories[category];

            // Remove group mapping
            delete categoryGroups[category];

            // Save changes
            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();
            renderCategoryBrowser();
            refreshFileTree();

            // Sync to cloud
            if (isCloudEnabled && cloudUser) {
                uploadToCloud();
            }

            alert(`âœ… Category deleted successfully!\n\n` +
                `Deleted:\n` +
                `â€¢ Category: "${category}"\n` +
                `â€¢ Subcategories: ${subcategoryCount}\n` +
                `â€¢ Files: ${deletedCount}\n\n` +
                `${isCloudEnabled ? 'â˜ï¸ Changes synced to cloud' : 'ðŸ’¾ Changes saved locally'}`);
        }

        function deleteSubcategory(category, subcategory) {
            // Find all files in this subcategory
            const filesToDelete = Object.keys(fileCategories).filter(file =>
                fileCategories[file].category === category &&
                fileCategories[file].subcategory === subcategory
            );

            // Show detailed confirmation
            const confirmMessage = `âš ï¸ DELETE SUBCATEGORY CONFIRMATION âš ï¸\n\n` +
                `Category: "${category}"\n` +
                `Subcategory: "${subcategory}"\n` +
                `Files to delete: ${filesToDelete.length}\n\n` +
                `This will permanently delete:\n` +
                `âœ— The subcategory\n` +
                `âœ— All ${filesToDelete.length} files in this subcategory\n` +
                `âœ— All flashcard data from localStorage\n` +
                `âœ— All flashcard data from cloud (if synced)\n\n` +
                `âš ï¸ THIS CANNOT BE UNDONE!\n\n` +
                `Are you sure you want to proceed?`;

            if (!confirm(confirmMessage)) {
                return;
            }

            // Delete all files and their data
            let deletedCount = 0;
            filesToDelete.forEach(fileName => {
                // Remove from localStorage
                safeStorage.removeItem(`flashcards_${fileName}`);

                // Remove from fileCategories mapping
                delete fileCategories[fileName];

                // Remove from global flashcards array if currently loaded
                if (currentFileName === fileName) {
                    flashcards = [];
                    filteredCards = [];
                    currentIndex = 0;
                    currentFileName = '';
                }

                deletedCount++;
                console.log(`ðŸ—‘ï¸ Deleted file: ${fileName}`);
            });

            // Remove subcategory from category list
            const index = categories[category].indexOf(subcategory);
            if (index > -1) {
                categories[category].splice(index, 1);
            }

            // Save changes
            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();
            renderCategoryBrowser();
            refreshFileTree();

            // Sync to cloud
            if (isCloudEnabled && cloudUser) {
                uploadToCloud();
            }

            alert(`âœ… Subcategory deleted successfully!\n\n` +
                `Deleted:\n` +
                `â€¢ Subcategory: "${subcategory}"\n` +
                `â€¢ Files: ${deletedCount}\n\n` +
                `${isCloudEnabled ? 'â˜ï¸ Changes synced to cloud' : 'ðŸ’¾ Changes saved locally'}`);
        }

        function updateCurrentFileDisplay() {
            if (currentFileName) {
                document.getElementById('currentFileDisplay').textContent = currentFileName;

                const cat = currentFileCategory.category || 'Default';
                const sub = currentFileCategory.subcategory;
                const badgeText = sub ? `${cat} > ${sub}` : cat;

                document.getElementById('currentCategoryBadge').textContent = badgeText;
            }
        }

        function filterByCategory() {
            // TODO: Implement filtering by category
            alert('Filter by category feature coming soon!');
        }

        // Category select change handler
        document.getElementById('categorySelect').addEventListener('change', updateSubcategoryDropdown);

        // Category Management Toggle Button Handler (REMOVED - now using toggleMainSection)
        // document.getElementById('categoryMgmtToggleBtn').addEventListener('click', function() {
        //     const section = document.getElementById('categoryManagerSection');
        //     const isVisible = section.style.display === 'block';
        //
        //     if (isVisible) {
        //         section.style.display = 'none';
        //         this.classList.remove('active');
        //     } else {
        //         section.style.display = 'block';
        //         this.classList.add('active');
        //     }
        // });

        // ==============================
        // FILE MANAGER FUNCTIONALITY
        // ==============================

        let currentFileManagerSelection = null; // {category: 'X', subcategory: 'Y'}
        let selectedFlashcardIds = new Set(); // Track selected flashcard IDs
        let currentSearchTerm = ''; // Track current search term
        let modalFlashcards = []; // Flashcards currently displayed in modal

        // Guard flag to prevent multiple executions
        let hasAutoLoaded = false;

        // VERIFICATION: Log which app is loaded
        console.log('ðŸ”µ UNIVERSAL FLASHCARD APP LOADED - flashcard_FINAL.html');
        console.log('ðŸ”µ File: Universal-Flashcard-App/flashcard_FINAL.html');

        // Auto-load all flashcards from all files
        function autoLoadAllCategories() {
            // Prevent multiple executions
            if (hasAutoLoaded) {
                console.log('â­ï¸ Auto-load already completed, skipping...');
                return;
            }

            hasAutoLoaded = true;
            console.log('ðŸš€ AUTO-LOADING ALL CATEGORIES...');

            // Get all files that have been saved
            const allFiles = Object.keys(fileCategories);
            console.log('ðŸ“‚ Found', allFiles.length, 'files to load');

            if (allFiles.length === 0) {
                console.log('âš ï¸ No files found in fileCategories');
                return;
            }

            let loadedCount = 0;
            let totalCards = 0;

            // Load each file into the global flashcards array
            allFiles.forEach(fileName => {
                // Check memory cache first (cloud-first mode), then localStorage
                let savedData = null;

                if (cloudDataCache[fileName]) {
                    savedData = cloudDataCache[fileName];
                } else {
                    savedData = safeStorage.getItem(`flashcards_${fileName}`);
                }

                if (!savedData) {
                    console.log(`âš ï¸ No data for file: ${fileName}`);
                    return;
                }

                try {
                    const cardData = JSON.parse(savedData);
                    const fileCategory = fileCategories[fileName] || { category: 'Default', subcategory: '' };

                    console.log(`ðŸ“¥ Loading ${fileName}: ${cardData.length} cards into ${fileCategory.category} > ${fileCategory.subcategory}`);

                    // Convert each card and add to global flashcards array
                    cardData.forEach((card, index) => {
                        // Create unique ID based on file and index to avoid conflicts
                        const uniqueId = card.id || `${fileName.replace(/[^a-zA-Z0-9]/g, '_')}_${index}`;

                        // Backward compatibility: Support both old (german/english) and new (lang1/lang2) formats
                        const lang1Value = card.lang1 || card.german || '';
                        const lang1ExtendedValue = card.lang1Extended || card.germanExtended || '';
                        const lang2Value = card.lang2 || card.english || '';
                        const lang2ExtendedValue = card.lang2Extended || card.englishExtended || '';

                        const flashcard = {
                            id: uniqueId,
                            lang1: lang1Value,
                            lang1Extended: lang1ExtendedValue,
                            lang2: lang2Value,
                            lang2Extended: lang2ExtendedValue,
                            detail: card.detail || '',
                            hasExtended: !!(lang1ExtendedValue || lang2ExtendedValue),
                            learned: card.learned || false,
                            reviewDate: card.reviewDate || null,
                            repetitions: card.repetitions || 0,
                            easeFactor: card.easeFactor || 2.5,
                            interval: card.interval || 1,
                            category: fileCategory.category,
                            subcategory: fileCategory.subcategory || '',
                            sourceFile: fileName  // Track which file this came from
                        };

                        // Check if this exact card already exists by ID
                        const existingIndex = flashcards.findIndex(c => c.id === uniqueId);

                        if (existingIndex === -1) {
                            flashcards.push(flashcard);
                            totalCards++;
                        }
                        // Duplicate found - silently skip (deduplication working correctly)
                    });

                    loadedCount++;
                } catch (error) {
                    console.error(`âŒ Error loading ${fileName}:`, error);
                }
            });

            console.log(`âœ… AUTO-LOAD COMPLETE!`);
            console.log(`   Files loaded: ${loadedCount}/${allFiles.length}`);
            console.log(`   Total flashcards: ${totalCards}`);
            console.log(`   Flashcards array size: ${flashcards.length}`);

            // Update UI
            if (flashcards.length > 0) {
                updateStats();
                renderCategoryBrowser();

                // Show success message
                const fileInfo = document.getElementById('fileInfo');
                if (fileInfo) {
                    fileInfo.innerHTML = `<strong>âœ… Auto-loaded ${loadedCount} files</strong><br>ðŸ“š Total: ${flashcards.length} flashcards across all categories`;
                }
            }

            // CRITICAL FIX: Auto-upload to cloud after loading local data
            // This ensures that local flashcards are synced to cloud after login
            if (isCloudEnabled && loadedCount > 0) {
                console.log('â˜ï¸ Triggering cloud upload after auto-load...');
                // Use setTimeout to avoid blocking the UI
                setTimeout(() => {
                    uploadToCloud();
                }, 1000);
            }
        }

        // Open table modal
        function openTableModal(category, subcategory) {
            console.log('ðŸ“Š Opening modal for:', category, '>', subcategory);

            currentFileManagerSelection = { category, subcategory };
            const title = subcategory ? `${category} > ${subcategory}` : category;
            document.getElementById('modalTitle').textContent = title;

            const modal = document.getElementById('tableModal');
            modal.classList.add('active');

            // Load data into modal
            loadFlashcardsIntoModal(category, subcategory);
        }

        // Close table modal
        function closeTableModal() {
            const modal = document.getElementById('tableModal');
            modal.classList.remove('active');
            selectedFlashcardIds.clear();
            currentSearchTerm = '';
        }

        // Save all changes button
        function saveAllChanges() {
            console.log('ðŸ’¾ Saving all changes...');
            saveProgress();
            if (isCloudEnabled && cloudUser) {
                syncToCloud();
            }
            alert('âœ… All changes saved successfully!');
        }

        // Export from modal
        function exportModalCSV() {
            if (!currentFileManagerSelection) return;
            exportCategoryToCSV();
        }

        // Load flashcards into modal table
        function loadFlashcardsIntoModal(category, subcategory) {
            const container = document.getElementById('modalTableContainer');
            container.innerHTML = '<p style="text-align: center; padding: 40px;">Loading...</p>';

            console.log('ðŸ“Š Loading flashcards into modal');
            console.log('  Category:', category);
            console.log('  Subcategory:', subcategory);

            // Load ALL cards from localStorage for this category/subcategory
            let allCards = [];

            // Find all files that match this category and subcategory
            Object.keys(fileCategories).forEach(fileName => {
                const fileCategory = fileCategories[fileName];
                const matchesCategory = fileCategory.category === category;
                const matchesSubcategory = subcategory ?
                    fileCategory.subcategory === subcategory :
                    (!fileCategory.subcategory || fileCategory.subcategory === '');

                if (matchesCategory && matchesSubcategory) {
                    // Check memory cache first (cloud-first mode), then localStorage
                    let savedData = cloudDataCache[fileName] || safeStorage.getItem(`flashcards_${fileName}`);
                    if (savedData) {
                        try {
                            const cardData = JSON.parse(savedData);
                            // Add cards with correct category/subcategory
                            cardData.forEach((card, index) => {
                                // Backward compatibility: Support both old (german/english) and new (lang1/lang2) formats
                                const lang1Value = card.lang1 || card.german || '';
                                const lang1ExtendedValue = card.lang1Extended || card.germanExtended || '';
                                const lang2Value = card.lang2 || card.english || '';
                                const lang2ExtendedValue = card.lang2Extended || card.englishExtended || '';

                                allCards.push({
                                    id: card.id || index,
                                    lang1: lang1Value,
                                    lang1Extended: lang1ExtendedValue,
                                    lang2: lang2Value,
                                    lang2Extended: lang2ExtendedValue,
                                    detail: card.detail || '',
                                    hasExtended: !!(lang1ExtendedValue || lang2ExtendedValue),
                                    learned: card.learned || false,
                                    reviewDate: card.reviewDate || null,
                                    repetitions: card.repetitions || 0,
                                    easeFactor: card.easeFactor || 2.5,
                                    interval: card.interval || 1,
                                    category: fileCategory.category,
                                    subcategory: fileCategory.subcategory || '',
                                    fileName: fileName // Track which file this came from
                                });
                            });
                            console.log(`  ðŸ“ Loaded ${cardData.length} cards from ${fileName}`);
                        } catch (e) {
                            console.error(`  âŒ Error loading ${fileName}:`, e);
                        }
                    }
                }
            });

            console.log('  Total cards loaded:', allCards.length);

            if (allCards.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ“­</div><p>No flashcards in this category</p></div>';
                return;
            }

            modalFlashcards = allCards;

            // Build the full modal content with category selector, search, bulk actions, and table
            container.innerHTML = `
                <!-- Category Selector -->
                <div class="modal-category-selector" id="modalCategorySelector">
                    <!-- Will be populated dynamically -->
                </div>

                <!-- Search Bar -->
                <div class="search-bar" style="margin-bottom: 20px;">
                    <input type="text" id="modalSearch" class="search-input" placeholder="ðŸ” Search flashcards..." onkeyup="filterModalTable()">
                    <button class="file-editor-btn" onclick="clearModalSearch()" style="background: #6b7280;">Clear</button>
                </div>

                <!-- Bulk Actions Bar -->
                <div class="bulk-actions hidden" id="modalBulkActions">
                    <span class="selection-count" id="modalSelectionCount">0 selected</span>
                    <button class="file-editor-btn" style="background: #ef4444;" onclick="deleteModalSelected()">ðŸ—‘ï¸ Delete Selected</button>
                    <button class="file-editor-btn" style="background: #6b7280;" onclick="deselectModalAll()">Clear Selection</button>
                </div>

                <!-- Add Flashcard Button -->
                <div style="margin-bottom: 15px;">
                    <button class="file-editor-btn btn-add" onclick="showModalAddForm()" style="width: 100%;">
                        âž• Add New Flashcard
                    </button>
                </div>

                <!-- Add Form (Hidden) -->
                <div class="add-flashcard-form" id="modalAddForm">
                    <h5 style="color: #78350f; margin-bottom: 15px;">âž• Add New Flashcard</h5>
                    <div class="form-group">
                        <label>Source Language Word/Phrase:</label>
                        <input type="text" id="modalNewGerman" placeholder="e.g., Hola">
                    </div>
                    <div class="form-group">
                        <label>Source Example (Optional):</label>
                        <input type="text" id="modalNewGermanExample" placeholder="e.g., Hola, Â¿cÃ³mo estÃ¡s?">
                    </div>
                    <div class="form-group">
                        <label>Target Language Translation:</label>
                        <input type="text" id="modalNewEnglish" placeholder="e.g., Hello">
                    </div>
                    <div class="form-group">
                        <label>Target Example (Optional):</label>
                        <input type="text" id="modalNewEnglishExample" placeholder="e.g., Hello, how are you?">
                    </div>
                    <div class="form-actions">
                        <button class="btn-save" onclick="saveModalNewFlashcard()">ðŸ’¾ Save</button>
                        <button class="btn-cancel" onclick="hideModalAddForm()">âŒ Cancel</button>
                    </div>
                </div>

                <!-- Table Container -->
                <div class="flashcard-list" id="modalTableList"></div>
            `;

            // Render the category selector
            renderModalCategorySelector(category, subcategory);

            // Render the table
            console.log('ðŸ”§ DEBUG: About to render table with modalFlashcards.length =', modalFlashcards.length);
            renderModalTable(modalFlashcards);
        }

        // Render category selector in modal
        function renderModalCategorySelector(selectedCategory, selectedSubcategory) {
            const container = document.getElementById('modalCategorySelector');
            if (!container) return;

            let html = '<h4>ðŸ“ Quick Switch Categories:</h4>';

            // Get all categories sorted
            const allCategories = Object.keys(categories).sort();

            allCategories.forEach(category => {
                const categoryFlashcards = flashcards.filter(card =>
                    card.category === category && (!card.subcategory || card.subcategory === '')
                );

                // Category button
                html += '<div style="margin-bottom: 15px;">';
                html += '<div class="category-button-group">';
                const catActive = (category === selectedCategory && !selectedSubcategory) ? 'active' : '';
                html += `<button class="category-btn ${catActive}" onclick="switchModalCategory('${category}', '')">
                    ðŸ“ ${category} <span style="opacity: 0.7;">(${categoryFlashcards.length})</span>
                </button>`;
                html += '</div>';

                // Subcategory buttons
                if (categories[category] && categories[category].length > 0) {
                    html += '<div class="category-button-group" style="margin-left: 20px;">';
                    categories[category].forEach(subcategory => {
                        const subcatFlashcards = flashcards.filter(card =>
                            card.category === category && card.subcategory === subcategory
                        );
                        const subActive = (category === selectedCategory && subcategory === selectedSubcategory) ? 'active' : '';
                        html += `<button class="subcategory-btn ${subActive}" onclick="switchModalCategory('${category}', '${subcategory}')">
                            ðŸ“„ ${subcategory} <span style="opacity: 0.7;">(${subcatFlashcards.length})</span>
                        </button>`;
                    });
                    html += '</div>';
                }

                html += '</div>';
            });

            container.innerHTML = html;
        }

        // Switch category in modal (without closing)
        function switchModalCategory(category, subcategory) {
            console.log('ðŸ”„ Switching modal to:', category, '>', subcategory);

            // Update title
            const title = subcategory ? `${category} > ${subcategory}` : category;
            document.getElementById('modalTitle').textContent = title;

            // Update selection
            currentFileManagerSelection = { category, subcategory };

            // Reload data in same modal
            loadFlashcardsIntoModal(category, subcategory);
        }

        // Render modal table
        function renderModalTable(cards) {
            console.log('ðŸ”§ DEBUG: renderModalTable called with cards.length =', cards.length);
            const container = document.getElementById('modalTableList');

            // CRITICAL: Clear previous table before rendering new one
            container.innerHTML = '';

            const table = document.createElement('table');
            table.className = 'excel-table';

            // Header
            const thead = document.createElement('thead');
            thead.innerHTML = `
                <tr>
                    <th class="checkbox-cell"><input type="checkbox" id="modalSelectAll" onchange="toggleModalSelectAll()"></th>
                    <th class="line-number-cell">#</th>
                    <th class="content-cell">ðŸ“– Source</th>
                    <th class="content-cell">Source Example</th>
                    <th class="content-cell">ðŸŽ¯ Target</th>
                    <th class="content-cell">Target Example</th>
                    <th class="actions-cell">Actions</th>
                </tr>
            `;
            table.appendChild(thead);

            // Body
            const tbody = document.createElement('tbody');
            cards.forEach((card, index) => {
                const tr = document.createElement('tr');
                tr.id = `modal-row-${card.id}`;

                tr.innerHTML = `
                    <td class="checkbox-cell">
                        <input type="checkbox" class="modal-row-checkbox" data-id="${card.id}" onchange="toggleModalRowSelection(${card.id})">
                    </td>
                    <td class="line-number-cell">${index + 1}</td>
                    <td class="content-cell editable-cell" contenteditable="true" data-id="${card.id}" data-field="lang1">${escapeHtml(card.lang1 || '')}</td>
                    <td class="content-cell editable-cell" contenteditable="true" data-id="${card.id}" data-field="lang1Extended">${escapeHtml(card.lang1Extended || '')}</td>
                    <td class="content-cell editable-cell" contenteditable="true" data-id="${card.id}" data-field="lang2">${escapeHtml(card.lang2 || '')}</td>
                    <td class="content-cell editable-cell" contenteditable="true" data-id="${card.id}" data-field="lang2Extended">${escapeHtml(card.lang2Extended || '')}</td>
                    <td class="actions-cell">
                        <div class="line-actions">
                            <button class="line-btn btn-edit" onclick="quickSaveRow(${card.id})">ðŸ’¾</button>
                            <button class="line-btn btn-delete" onclick="deleteFlashcard(${card.id})">ðŸ—‘ï¸</button>
                        </div>
                    </td>
                `;

                tbody.appendChild(tr);
            });

            table.appendChild(tbody);
            container.appendChild(table);

            console.log('âœ… Modal table rendered with', cards.length, 'rows');
        }

        // Modal helper functions
        function filterModalTable() {
            const searchTerm = document.getElementById('modalSearch').value.toLowerCase();
            const filtered = modalFlashcards.filter(card => {
                return (
                    (card.lang1 && card.lang1.toLowerCase().includes(searchTerm)) ||
                    (card.lang1Extended && card.lang1Extended.toLowerCase().includes(searchTerm)) ||
                    (card.lang2 && card.lang2.toLowerCase().includes(searchTerm)) ||
                    (card.lang2Extended && card.lang2Extended.toLowerCase().includes(searchTerm))
                );
            });
            renderModalTable(filtered);
        }

        function clearModalSearch() {
            document.getElementById('modalSearch').value = '';
            renderModalTable(modalFlashcards);
        }

        function toggleModalSelectAll() {
            const selectAll = document.getElementById('modalSelectAll');
            const checkboxes = document.querySelectorAll('.modal-row-checkbox');
            checkboxes.forEach(cb => {
                const cardId = parseInt(cb.dataset.id);
                cb.checked = selectAll.checked;
                if (selectAll.checked) {
                    selectedFlashcardIds.add(cardId);
                } else {
                    selectedFlashcardIds.delete(cardId);
                }
            });
            updateModalSelectionCount();
        }

        function toggleModalRowSelection(cardId) {
            if (selectedFlashcardIds.has(cardId)) {
                selectedFlashcardIds.delete(cardId);
            } else {
                selectedFlashcardIds.add(cardId);
            }
            updateModalSelectionCount();
        }

        function updateModalSelectionCount() {
            const count = selectedFlashcardIds.size;
            const countEl = document.getElementById('modalSelectionCount');
            const bulkActions = document.getElementById('modalBulkActions');

            if (countEl) countEl.textContent = `${count} selected`;
            if (bulkActions) {
                if (count > 0) {
                    bulkActions.classList.remove('hidden');
                } else {
                    bulkActions.classList.add('hidden');
                }
            }
        }

        function deselectModalAll() {
            selectedFlashcardIds.clear();
            document.querySelectorAll('.modal-row-checkbox').forEach(cb => cb.checked = false);
            const selectAll = document.getElementById('modalSelectAll');
            if (selectAll) selectAll.checked = false;
            updateModalSelectionCount();
        }

        function deleteModalSelected() {
            if (selectedFlashcardIds.size === 0) return;

            if (!confirm(`Delete ${selectedFlashcardIds.size} flashcards?`)) return;

            selectedFlashcardIds.forEach(cardId => {
                const index = flashcards.findIndex(c => c.id === cardId);
                if (index > -1) flashcards.splice(index, 1);
            });

            selectedFlashcardIds.clear();
            saveProgress();
            if (isCloudEnabled && cloudUser) syncToCloud();

            // Reload modal
            const { category, subcategory } = currentFileManagerSelection;
            loadFlashcardsIntoModal(category, subcategory);
            refreshFileTree();
        }

        function showModalAddForm() {
            document.getElementById('modalAddForm').classList.add('active');
        }

        function hideModalAddForm() {
            document.getElementById('modalAddForm').classList.remove('active');
        }

        function saveModalNewFlashcard() {
            const lang1 = document.getElementById('modalNewGerman').value.trim();
            const lang1Ex = document.getElementById('modalNewGermanExample').value.trim();
            const lang2 = document.getElementById('modalNewEnglish').value.trim();
            const lang2Ex = document.getElementById('modalNewEnglishExample').value.trim();

            if (!lang1 || !lang2) {
                alert('Please enter source and target language text');
                return;
            }

            const newCard = {
                id: Date.now(),
                lang1,
                lang1Extended: lang1Ex,
                lang2,
                lang2Extended: lang2Ex,
                learned: false,
                category: currentFileManagerSelection.category,
                subcategory: currentFileManagerSelection.subcategory || ''
            };

            flashcards.push(newCard);
            saveProgress();
            if (isCloudEnabled && cloudUser) syncToCloud();

            // Reload modal
            const { category, subcategory } = currentFileManagerSelection;
            loadFlashcardsIntoModal(category, subcategory);
            hideModalAddForm();
            refreshFileTree();
        }

        // File Manager Toggle Button Handler (REMOVED - now using toggleMainSection)
        // document.getElementById('fileManagerToggleBtn').addEventListener('click', function() {
        //     const section = document.getElementById('fileManagerSection');
        //     const isVisible = section.style.display === 'block';
        //
        //     if (isVisible) {
        //         section.style.display = 'none';
        //         this.classList.remove('active');
        //     } else {
        //         section.style.display = 'block';
        //         this.classList.add('active');
        //         refreshFileTree();
        //     }
        // });

        // Populate the file tree with categories and subcategories
        function refreshFileTree() {
            const treeContent = document.getElementById('fileTreeContent');
            treeContent.innerHTML = '';

            console.log('ðŸ“‚ Refreshing file tree. Total flashcards:', flashcards.length);
            console.log('ðŸ“‚ Categories:', Object.keys(categories));

            if (Object.keys(categories).length === 0) {
                treeContent.innerHTML = '<p style="color: #94a3b8; text-align: center; padding: 20px;">No categories yet</p>';
                return;
            }

            Object.keys(categories).sort().forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'tree-category';

                // Category name
                const categoryName = document.createElement('div');
                categoryName.className = 'tree-category-name';
                categoryName.innerHTML = `<span class="tree-icon">ðŸ“</span>${category}`;

                // Count flashcards in this category (no subcategory)
                const categoryFlashcards = flashcards.filter(card =>
                    card.category === category && (!card.subcategory || card.subcategory === '')
                );
                console.log(`  ðŸ“ ${category}: ${categoryFlashcards.length} cards (no subcategory)`);
                categoryName.innerHTML += ` <span style="color: rgba(255,255,255,0.7); font-size: 0.85em; margin-left: auto;">(${categoryFlashcards.length})</span>`;

                categoryName.addEventListener('click', (e) => {
                    console.log('ðŸ–±ï¸ Category clicked:', category);
                    e.stopPropagation();
                    try {
                        // Open modal directly
                        openTableModal(category, '');
                    } catch (error) {
                        console.error('âŒ Error opening modal:', error);
                    }
                });
                categoryDiv.appendChild(categoryName);

                // Subcategories
                if (categories[category] && categories[category].length > 0) {
                    const subcatContainer = document.createElement('div');
                    subcatContainer.className = 'tree-subcategory';

                    categories[category].forEach(subcategory => {
                        const subcatDiv = document.createElement('div');
                        subcatDiv.className = 'tree-subcategory-name';
                        subcatDiv.innerHTML = `<span class="tree-icon">ðŸ“„</span>${subcategory}`;

                        // Count flashcards in this subcategory from all saved files
                        let subcatCardCount = 0;
                        Object.keys(fileCategories).forEach(fileName => {
                            const fileCategory = fileCategories[fileName];
                            if (fileCategory.category === category && fileCategory.subcategory === subcategory) {
                                // Check memory cache first (cloud-first mode), then localStorage
                                const savedData = cloudDataCache[fileName] || safeStorage.getItem(`flashcards_${fileName}`);
                                if (savedData) {
                                    try {
                                        const cardData = JSON.parse(savedData);
                                        subcatCardCount += cardData.length;
                                    } catch (e) {
                                        console.error(`Error parsing ${fileName}:`, e);
                                    }
                                }
                            }
                        });
                        console.log(`    ðŸ“„ ${category} > ${subcategory}: ${subcatCardCount} cards`);
                        subcatDiv.innerHTML += ` <span style="color: rgba(0,0,0,0.5); font-size: 0.85em; margin-left: auto;">(${subcatCardCount})</span>`;

                        subcatDiv.addEventListener('click', (e) => {
                            console.log('ðŸ–±ï¸ Subcategory clicked:', category, '>', subcategory);
                            e.stopPropagation();
                            try {
                                // Open modal directly
                                openTableModal(category, subcategory);
                            } catch (error) {
                                console.error('âŒ Error opening modal:', error);
                            }
                        });
                        subcatContainer.appendChild(subcatDiv);
                    });

                    categoryDiv.appendChild(subcatContainer);
                }

                treeContent.appendChild(categoryDiv);
            });
        }

        // Manual load data button
        function manualLoadData() {
            console.log('ðŸ”„ ========== MANUAL LOAD DATA CLICKED ==========');

            if (!currentFileManagerSelection) {
                alert('Please select a category from the tree first!');
                return;
            }

            console.log('ðŸ”„ Current selection:', currentFileManagerSelection);
            console.log('ðŸ”„ Total flashcards in memory:', flashcards.length);

            // Debug: Show first 5 flashcards
            console.log('ðŸ”„ First 5 flashcards in memory:');
            for (let i = 0; i < Math.min(5, flashcards.length); i++) {
                console.log(`  Card ${i}:`, {
                    lang1: flashcards[i].lang1,
                    lang2: flashcards[i].lang2,
                    category: flashcards[i].category,
                    subcategory: flashcards[i].subcategory
                });
            }

            const { category, subcategory } = currentFileManagerSelection;

            console.log('ðŸ”„ Looking for cards with:');
            console.log('  - category:', category);
            console.log('  - subcategory:', subcategory);

            // Force load the flashcards
            loadFlashcardsForCategory(category, subcategory);
        }

        // Select a category/subcategory and display its flashcards
        function selectCategory(category, subcategory, clickedElement) {
            console.log('ðŸŽ¯ selectCategory called:', category, '>', subcategory);
            console.log('ðŸŽ¯ Total flashcards in memory:', flashcards.length);

            currentFileManagerSelection = { category, subcategory };

            // Clear selection and search when switching categories
            selectedFlashcardIds.clear();
            currentSearchTerm = '';
            const searchBox = document.getElementById('flashcardSearch');
            if (searchBox) searchBox.value = '';

            // Update UI - highlight selected item
            try {
                document.querySelectorAll('.tree-category-name, .tree-subcategory-name').forEach(el => {
                    el.classList.remove('selected');
                });
                if (clickedElement) {
                    clickedElement.classList.add('selected');
                }
            } catch (e) {
                console.error('Error updating selection:', e);
            }

            // Show editor content, hide empty state
            const editorEmpty = document.getElementById('fileEditorEmpty');
            const editorContent = document.getElementById('fileEditorContent');

            if (editorEmpty) editorEmpty.style.display = 'none';
            if (editorContent) editorContent.style.display = 'block';

            // Update title
            const title = subcategory ? `${category} > ${subcategory}` : category;
            const titleElement = document.getElementById('editorTitle');
            if (titleElement) titleElement.textContent = title;

            // Hide add form if it was open
            const addForm = document.getElementById('addFlashcardForm');
            if (addForm) addForm.classList.remove('active');

            console.log('ðŸŽ¯ Category selected. Click "Load Data" button to view flashcards.');
            // Don't auto-load, let user click the button
        }

        // Load and display flashcards for selected category (Excel-like table)
        function loadFlashcardsForCategory(category, subcategory) {
            const container = document.getElementById('flashcardListContainer');
            container.innerHTML = '';

            console.log(`ðŸ” Filtering flashcards for: ${category} > ${subcategory}`);
            console.log(`ðŸ” Total flashcards available: ${flashcards.length}`);

            // Debug: show first few cards
            if (flashcards.length > 0) {
                console.log('ðŸ” Sample card:', {
                    lang1: flashcards[0].lang1,
                    category: flashcards[0].category,
                    subcategory: flashcards[0].subcategory
                });
            }

            let debugCount = 0;
            let filteredCards = flashcards.filter(card => {
                if (subcategory) {
                    const match = card.category === category && card.subcategory === subcategory;
                    if (!match && debugCount < 3) {
                        console.log(`ðŸ” Card doesn't match: cat="${card.category}", subcat="${card.subcategory}"`);
                        debugCount++;
                    }
                    return match;
                } else {
                    return card.category === category && (!card.subcategory || card.subcategory === '');
                }
            });

            console.log(`ðŸ” Filtered to ${filteredCards.length} cards`);
            console.log('ðŸ” About to enter try-catch block...');

            try {
                console.log('ðŸ” Inside try-catch block!');
                // Apply search filter if search term exists
                if (currentSearchTerm) {
                    filteredCards = filteredCards.filter(card => {
                        const searchLower = currentSearchTerm.toLowerCase();
                        return (
                            (card.lang1 && card.lang1.toLowerCase().includes(searchLower)) ||
                            (card.lang1Extended && card.lang1Extended.toLowerCase().includes(searchLower)) ||
                            (card.lang2 && card.lang2.toLowerCase().includes(searchLower)) ||
                            (card.lang2Extended && card.lang2Extended.toLowerCase().includes(searchLower))
                        );
                    });
                }

                if (filteredCards.length === 0) {
                    container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ“­</div><p>No flashcards found</p></div>';
                    console.log('âŒ No cards to display after filtering');
                    return;
                }

                console.log('âœ… Creating table for', filteredCards.length, 'cards');

            // Create Excel-like table
            const table = document.createElement('table');
            table.className = 'excel-table';
            console.log('âœ… Table element created');

            // Table header
            const thead = document.createElement('thead');
            thead.innerHTML = `
                <tr>
                    <th class="checkbox-cell">
                        <input type="checkbox" id="selectAllCheckbox" onchange="toggleSelectAll()">
                    </th>
                    <th class="line-number-cell">#</th>
                    <th class="content-cell">ðŸ“– Source</th>
                    <th class="content-cell">Source Example</th>
                    <th class="content-cell">ðŸŽ¯ Target</th>
                    <th class="content-cell">Target Example</th>
                    <th class="actions-cell">Actions</th>
                </tr>
            `;
            table.appendChild(thead);
            console.log('âœ… Table header created');

            // Table body
            const tbody = document.createElement('tbody');
            console.log('âœ… Starting to create rows for', filteredCards.length, 'cards');

            filteredCards.forEach((card, index) => {
                try {
                    const tr = document.createElement('tr');
                    tr.id = `row-${card.id}`;
                    if (selectedFlashcardIds.has(card.id)) {
                        tr.classList.add('selected');
                    }

                    // Safely get values with defaults
                    const germanText = card.lang1 || '';
                    const germanExt = card.lang1Extended || '';
                    const englishText = card.lang2 || '';
                    const englishExt = card.lang2Extended || '';

                    if (index < 3) {
                        console.log(`  Row ${index}:`, germanText.substring(0, 20), 'â†’', englishText.substring(0, 20));
                    }

                tr.innerHTML = `
                    <td class="checkbox-cell">
                        <input type="checkbox" class="row-checkbox" data-id="${card.id}"
                               onchange="toggleRowSelection(${card.id})"
                               ${selectedFlashcardIds.has(card.id) ? 'checked' : ''}>
                    </td>
                    <td class="line-number-cell">${index + 1}</td>
                    <td class="content-cell editable-cell" contenteditable="true" data-id="${card.id}" data-field="lang1">
                        ${escapeHtml(germanText)}
                    </td>
                    <td class="content-cell editable-cell" contenteditable="true" data-id="${card.id}" data-field="lang1Extended" style="color: ${germanExt ? '#334155' : '#cbd5e1'};">
                        ${escapeHtml(germanExt)}
                    </td>
                    <td class="content-cell editable-cell" contenteditable="true" data-id="${card.id}" data-field="lang2">
                        ${escapeHtml(englishText)}
                    </td>
                    <td class="content-cell editable-cell" contenteditable="true" data-id="${card.id}" data-field="lang2Extended" style="color: ${englishExt ? '#334155' : '#cbd5e1'};">
                        ${escapeHtml(englishExt)}
                    </td>
                    <td class="actions-cell">
                        <div class="line-actions">
                            <button class="line-btn btn-edit" onclick="quickSaveRow(${card.id})">ðŸ’¾</button>
                            <button class="line-btn btn-delete" onclick="deleteFlashcard(${card.id})">ðŸ—‘ï¸</button>
                        </div>
                    </td>
                `;

                    tbody.appendChild(tr);
                } catch (error) {
                    console.error(`âŒ Error creating row ${index}:`, error);
                }
            });

            console.log('âœ… All rows created, appending tbody to table');
            table.appendChild(tbody);

            console.log('âœ… Appending table to container');
            console.log('  Container:', container);
            console.log('  Table rows:', tbody.children.length);

            container.appendChild(table);

                console.log('âœ… TABLE RENDERED SUCCESSFULLY!');
                console.log('  Total rows in table:', table.querySelectorAll('tbody tr').length);

                // Update selection count
                updateSelectionCount();

            } catch (error) {
                console.error('âŒâŒâŒ CRITICAL ERROR IN TABLE RENDERING:', error);
                console.error('Error stack:', error.stack);
                container.innerHTML = `<div class="empty-state">
                    <div class="empty-state-icon">âš ï¸</div>
                    <p style="color: red;">Error loading data: ${error.message}</p>
                    <p style="font-size: 0.9em;">Check console for details</p>
                </div>`;
            }
        }

        // Helper function to escape HTML
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }

        // Search functionality
        document.getElementById('flashcardSearch').addEventListener('input', function(e) {
            currentSearchTerm = e.target.value;
            if (currentFileManagerSelection) {
                loadFlashcardsForCategory(currentFileManagerSelection.category, currentFileManagerSelection.subcategory);
            }
        });

        // Clear search
        function clearSearch() {
            currentSearchTerm = '';
            document.getElementById('flashcardSearch').value = '';
            if (currentFileManagerSelection) {
                loadFlashcardsForCategory(currentFileManagerSelection.category, currentFileManagerSelection.subcategory);
            }
        }

        // Toggle row selection
        function toggleRowSelection(cardId) {
            const row = document.getElementById(`row-${cardId}`);
            if (selectedFlashcardIds.has(cardId)) {
                selectedFlashcardIds.delete(cardId);
                row.classList.remove('selected');
            } else {
                selectedFlashcardIds.add(cardId);
                row.classList.add('selected');
            }
            updateSelectionCount();
        }

        // Toggle select all
        function toggleSelectAll() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            const checkboxes = document.querySelectorAll('.row-checkbox');

            if (selectAllCheckbox.checked) {
                // Select all
                checkboxes.forEach(cb => {
                    const cardId = parseInt(cb.dataset.id);
                    selectedFlashcardIds.add(cardId);
                    cb.checked = true;
                    document.getElementById(`row-${cardId}`).classList.add('selected');
                });
            } else {
                // Deselect all
                checkboxes.forEach(cb => {
                    const cardId = parseInt(cb.dataset.id);
                    selectedFlashcardIds.delete(cardId);
                    cb.checked = false;
                    document.getElementById(`row-${cardId}`).classList.remove('selected');
                });
            }
            updateSelectionCount();
        }

        // Deselect all
        function deselectAll() {
            selectedFlashcardIds.clear();
            const checkboxes = document.querySelectorAll('.row-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = false;
                const cardId = parseInt(cb.dataset.id);
                const row = document.getElementById(`row-${cardId}`);
                if (row) {
                    row.classList.remove('selected');
                }
            });
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            if (selectAllCheckbox) {
                selectAllCheckbox.checked = false;
            }
            updateSelectionCount();
        }

        // Update selection count and show/hide bulk actions bar
        function updateSelectionCount() {
            const count = selectedFlashcardIds.size;
            const countElement = document.getElementById('selectionCount');
            const bulkActionsBar = document.getElementById('bulkActionsBar');

            if (count > 0) {
                countElement.textContent = `${count} selected`;
                bulkActionsBar.classList.remove('hidden');
            } else {
                countElement.textContent = '0 selected';
                bulkActionsBar.classList.add('hidden');
            }
        }

        // Delete selected flashcards
        function deleteSelected() {
            if (selectedFlashcardIds.size === 0) {
                alert('No flashcards selected');
                return;
            }

            const count = selectedFlashcardIds.size;
            if (!confirm(`Delete ${count} selected flashcard${count > 1 ? 's' : ''}?`)) {
                return;
            }

            // Remove selected cards
            selectedFlashcardIds.forEach(cardId => {
                const index = flashcards.findIndex(c => c.id === cardId);
                if (index > -1) {
                    flashcards.splice(index, 1);
                }
            });

            // Clear selection
            selectedFlashcardIds.clear();

            // Save to storage
            saveToStorage();

            // Sync to cloud if enabled
            if (isCloudEnabled && cloudUser) {
                syncToCloud();
            }

            // Refresh display
            loadFlashcardsForCategory(currentFileManagerSelection.category, currentFileManagerSelection.subcategory);
            refreshFileTree();
            updateCategoryBrowser();

            alert(`âœ… ${count} flashcard${count > 1 ? 's' : ''} deleted successfully!`);
        }

        // Show add flashcard form
        function showAddFlashcardForm() {
            const form = document.getElementById('addFlashcardForm');
            form.classList.add('active');

            // Clear form fields
            document.getElementById('newGerman').value = '';
            document.getElementById('newGermanExample').value = '';
            document.getElementById('newEnglish').value = '';
            document.getElementById('newEnglishExample').value = '';

            // Focus on first field
            document.getElementById('newGerman').focus();
        }

        // Hide add flashcard form
        function hideAddFlashcardForm() {
            document.getElementById('addFlashcardForm').classList.remove('active');
        }

        // Save new flashcard
        function saveNewFlashcard() {
            const lang1 = document.getElementById('newGerman').value.trim();
            const germanExample = document.getElementById('newGermanExample').value.trim();
            const lang2 = document.getElementById('newEnglish').value.trim();
            const englishExample = document.getElementById('newEnglishExample').value.trim();

            if (!lang1 || !lang2) {
                alert('Please enter at least Source and Target language text');
                return;
            }

            if (!currentFileManagerSelection) {
                alert('Please select a category first');
                return;
            }

            // Create new flashcard
            const newCard = {
                id: Date.now(), // Simple unique ID
                lang1: lang1,
                lang1Extended: germanExample || '',
                lang2: lang2,
                lang2Extended: englishExample || '',
                learned: false,
                category: currentFileManagerSelection.category,
                subcategory: currentFileManagerSelection.subcategory || ''
            };

            // Add to flashcards array
            flashcards.push(newCard);

            // Save to storage
            saveToStorage();

            // Sync to cloud if enabled
            if (isCloudEnabled && cloudUser) {
                syncToCloud();
            }

            // Refresh display
            loadFlashcardsForCategory(currentFileManagerSelection.category, currentFileManagerSelection.subcategory);
            hideAddFlashcardForm();
            refreshFileTree();
            updateCategoryBrowser();

            alert('âœ… Flashcard added successfully!');
        }

        // Quick save row (for inline editing)
        function quickSaveRow(cardId) {
            const card = flashcards.find(c => c.id === cardId);
            if (!card) return;

            // Get all editable cells for this card
            const cells = document.querySelectorAll(`[data-id="${cardId}"][data-field]`);

            let updated = false;
            cells.forEach(cell => {
                const field = cell.getAttribute('data-field');
                const newValue = cell.textContent.trim();

                if (card[field] !== newValue) {
                    card[field] = newValue;
                    updated = true;
                }
            });

            if (updated) {
                // Save to storage
                saveToStorage();

                // Sync to cloud if enabled
                if (isCloudEnabled && cloudUser) {
                    syncToCloud();
                }

                // Visual feedback
                const row = document.getElementById(`row-${cardId}`);
                if (row) {
                    row.style.background = '#d1fae5';
                    setTimeout(() => {
                        row.style.background = '';
                    }, 500);
                }

                console.log('âœ… Card saved:', cardId);
            }
        }

        // Edit flashcard (legacy prompt-based)
        function editFlashcard(cardId) {
            const card = flashcards.find(c => c.id === cardId);
            if (!card) return;

            const lang1 = prompt('Source language word/phrase:', card.lang1);
            if (lang1 === null) return;

            const germanExample = prompt('Source example (optional):', card.lang1Extended || '');
            const lang2 = prompt('Target language translation:', card.lang2);
            if (lang2 === null) return;

            const englishExample = prompt('Target example (optional):', card.lang2Extended || '');

            // Update card
            card.lang1 = lang1.trim();
            card.lang1Extended = germanExample ? germanExample.trim() : '';
            card.lang2 = lang2.trim();
            card.lang2Extended = englishExample ? englishExample.trim() : '';

            // Save to storage
            saveToStorage();

            // Sync to cloud if enabled
            if (isCloudEnabled && cloudUser) {
                syncToCloud();
            }

            // Refresh display
            loadFlashcardsForCategory(currentFileManagerSelection.category, currentFileManagerSelection.subcategory);

            alert('âœ… Flashcard updated successfully!');
        }

        // Delete flashcard
        function deleteFlashcard(cardId) {
            const card = flashcards.find(c => c.id === cardId);
            if (!card) return;

            if (!confirm(`Delete this flashcard?\n\nSource: ${card.lang1}\nTarget: ${card.lang2}`)) {
                return;
            }

            // Remove from array
            const index = flashcards.findIndex(c => c.id === cardId);
            if (index > -1) {
                flashcards.splice(index, 1);
            }

            // Save to storage
            saveToStorage();

            // Sync to cloud if enabled
            if (isCloudEnabled && cloudUser) {
                syncToCloud();
            }

            // Refresh display
            loadFlashcardsForCategory(currentFileManagerSelection.category, currentFileManagerSelection.subcategory);
            refreshFileTree();
            updateCategoryBrowser();

            alert('âœ… Flashcard deleted successfully!');
        }

        // Export category to CSV
        function exportCategoryToCSV() {
            if (!currentFileManagerSelection) {
                alert('Please select a category first');
                return;
            }

            const { category, subcategory } = currentFileManagerSelection;
            const filteredCards = flashcards.filter(card => {
                if (subcategory) {
                    return card.category === category && card.subcategory === subcategory;
                } else {
                    return card.category === category && (!card.subcategory || card.subcategory === '');
                }
            });

            if (filteredCards.length === 0) {
                alert('No flashcards to export');
                return;
            }

            // Create CSV content
            let csv = 'Source,Source Example,Target,Target Example\n';
            filteredCards.forEach(card => {
                const row = [
                    card.lang1 || '',
                    card.lang1Extended || '',
                    card.lang2 || '',
                    card.lang2Extended || ''
                ].map(field => `"${field.replace(/"/g, '""')}"`).join(',');
                csv += row + '\n';
            });

            // Download
            const filename = subcategory ? `${category}_${subcategory}.csv` : `${category}.csv`;
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();

            alert(`âœ… Exported ${filteredCards.length} flashcards to ${filename}`);
        }

        /**
         * Export all categories as separate CSV files in a ZIP with full metadata
         */
        async function exportAllCategories() {
            if (!flashcards || flashcards.length === 0) {
                alert('No flashcards to export!');
                return;
            }

            console.log('ðŸ“¦ Starting export of all categories with metadata...');

            try {
                // Create a new JSZip instance
                const zip = new JSZip();

                // Group flashcards by category
                const categorizedCards = {};
                flashcards.forEach(card => {
                    const category = card.category || 'Default';
                    const subcategory = card.subcategory || '';
                    const key = subcategory ? `${category}/${subcategory}` : category;

                    if (!categorizedCards[key]) {
                        categorizedCards[key] = [];
                    }
                    categorizedCards[key].push(card);
                });

                // Check if there are any categories
                const categoryKeys = Object.keys(categorizedCards);
                if (categoryKeys.length === 0) {
                    alert('No categories found to export!');
                    return;
                }

                console.log(`ðŸ“ Found ${categoryKeys.length} categories to export`);

                // Create metadata file with full structure
                const metadata = {
                    exportDate: new Date().toISOString(),
                    version: '3.1',
                    totalCards: flashcards.length,
                    totalCategories: categoryKeys.length,
                    categories: categories, // Full category structure
                    categoryGroups: categoryGroups, // Group names
                    fileCategories: fileCategories, // File-to-category mappings
                    categoryStructure: {} // Detailed structure
                };

                // Build detailed category structure
                categoryKeys.forEach(key => {
                    const parts = key.split('/');
                    const category = parts[0];
                    const subcategory = parts[1] || null;

                    if (!metadata.categoryStructure[category]) {
                        metadata.categoryStructure[category] = {
                            name: category,
                            group: categoryGroups[category] || category,
                            subcategories: [],
                            cardCount: 0
                        };
                    }

                    if (subcategory) {
                        metadata.categoryStructure[category].subcategories.push({
                            name: subcategory,
                            cardCount: categorizedCards[key].length
                        });
                    }

                    metadata.categoryStructure[category].cardCount += categorizedCards[key].length;
                });

                // Add metadata.json to ZIP
                zip.file('_metadata.json', JSON.stringify(metadata, null, 2));
                console.log('  âœ… Added _metadata.json');

                // Create CSV for each category and add to ZIP
                let totalCards = 0;
                categoryKeys.forEach(key => {
                    const cards = categorizedCards[key];
                    totalCards += cards.length;

                    // Create CSV content with metadata header
                    const parts = key.split('/');
                    const category = parts[0];
                    const subcategory = parts[1] || '';
                    const group = categoryGroups[category] || category;

                    let csv = `# Category: ${category}\n`;
                    csv += `# Subcategory: ${subcategory}\n`;
                    csv += `# Group: ${group}\n`;
                    csv += `# Cards: ${cards.length}\n`;
                    csv += `# Export Date: ${new Date().toISOString()}\n`;
                    csv += `Source,Source Example,Target,Target Example,Learned\n`;

                    cards.forEach(card => {
                        const row = [
                            card.lang1 || '',
                            card.lang1Extended || '',
                            card.lang2 || '',
                            card.lang2Extended || '',
                            card.learned ? 'true' : 'false'
                        ].map(field => `"${field.replace(/"/g, '""')}"`).join(',');
                        csv += row + '\n';
                    });

                    // Add file to ZIP
                    const filename = key.replace(/\//g, '_') + '.csv';
                    zip.file(filename, csv);
                    console.log(`  âœ… Added ${filename} (${cards.length} cards)`);
                });

                // Generate ZIP file
                console.log('ðŸ—œï¸  Generating ZIP file...');
                const blob = await zip.generateAsync({ type: 'blob' });

                // Download ZIP
                const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                const zipFilename = `flashcards_backup_${timestamp}.zip`;

                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = zipFilename;
                link.click();

                console.log('âœ… Export complete!');
                alert(`âœ… Successfully exported with full metadata!\n\n` +
                      `ðŸ“¦ ${categoryKeys.length} categories\n` +
                      `ðŸƒ ${totalCards} total flashcards\n` +
                      `ðŸ·ï¸  Groups: ${Object.keys(categoryGroups).length}\n` +
                      `ðŸ“ File: ${zipFilename}\n\n` +
                      `âœ¨ Includes: Categories, Subcategories, Groups, Progress`);

            } catch (error) {
                console.error('âŒ Export failed:', error);
                alert('âŒ Export failed! Please check the console for details.');
            }
        }

        /**
         * Import flashcards from ZIP backup (restores full structure)
         */
        async function importBackupZip(file) {
            if (!file) {
                alert('Please select a ZIP file to import');
                return;
            }

            console.log('ðŸ“¥ Starting import from ZIP backup...');

            try {
                // Read ZIP file
                const zip = await JSZip.loadAsync(file);
                console.log('âœ… ZIP file loaded');

                // Read metadata first
                const metadataFile = zip.file('_metadata.json');
                let metadata = null;

                if (metadataFile) {
                    const metadataText = await metadataFile.async('text');
                    metadata = JSON.parse(metadataText);
                    console.log('ðŸ“‹ Metadata loaded:', metadata);

                    // Restore category structure
                    if (metadata.categories) {
                        Object.assign(categories, metadata.categories);
                    }
                    if (metadata.categoryGroups) {
                        Object.assign(categoryGroups, metadata.categoryGroups);
                    }
                    if (metadata.fileCategories) {
                        Object.assign(fileCategories, metadata.fileCategories);
                    }
                }

                // Import all CSV files
                const csvFiles = Object.keys(zip.files).filter(name => name.endsWith('.csv'));
                console.log(`ðŸ“„ Found ${csvFiles.length} CSV files to import`);

                let totalImported = 0;
                const importedCategories = new Set();

                for (const filename of csvFiles) {
                    const file = zip.file(filename);
                    const csvText = await file.async('text');

                    // Parse CSV (skip comment lines starting with #)
                    const lines = csvText.split('\n').filter(line => !line.startsWith('#') && line.trim());
                    if (lines.length <= 1) continue; // Skip if only header

                    // Extract metadata from comments if present
                    const commentLines = csvText.split('\n').filter(line => line.startsWith('#'));
                    let category = 'Default';
                    let subcategory = '';
                    let group = 'Default';

                    commentLines.forEach(line => {
                        if (line.includes('# Category:')) category = line.split(':')[1].trim();
                        if (line.includes('# Subcategory:')) subcategory = line.split(':')[1].trim();
                        if (line.includes('# Group:')) group = line.split(':')[1].trim();
                    });

                    // Parse CSV data (skip header)
                    const dataLines = lines.slice(1);
                    const newCards = [];

                    dataLines.forEach((line, index) => {
                        if (!line.trim()) return;

                        // Simple CSV parser (handles quoted fields)
                        const fields = [];
                        let currentField = '';
                        let inQuotes = false;

                        for (let i = 0; i < line.length; i++) {
                            const char = line[i];
                            if (char === '"') {
                                if (inQuotes && line[i + 1] === '"') {
                                    currentField += '"';
                                    i++;
                                } else {
                                    inQuotes = !inQuotes;
                                }
                            } else if (char === ',' && !inQuotes) {
                                fields.push(currentField);
                                currentField = '';
                            } else {
                                currentField += char;
                            }
                        }
                        fields.push(currentField);

                        if (fields.length >= 4) {
                            const card = {
                                id: Date.now() + index + totalImported,
                                lang1: fields[0],
                                lang1Extended: fields[1],
                                lang2: fields[2],
                                lang2Extended: fields[3],
                                learned: fields[4] === 'true',
                                lastReviewed: null,
                                reviewCount: 0,
                                category: category,
                                subcategory: subcategory,
                                fileName: filename.replace('.csv', '')
                            };
                            newCards.push(card);
                        }
                    });

                    // Add to flashcards array
                    flashcards.push(...newCards);
                    totalImported += newCards.length;
                    importedCategories.add(category);

                    // Ensure category exists
                    if (!categories[category]) {
                        categories[category] = {
                            name: category,
                            created: Date.now(),
                            subcategories: []
                        };
                    }

                    // Add subcategory if exists
                    if (subcategory && !categories[category].subcategories.includes(subcategory)) {
                        categories[category].subcategories.push(subcategory);
                    }

                    // Set group
                    if (group && group !== 'Default') {
                        categoryGroups[category] = group;
                    }

                    console.log(`  âœ… Imported ${filename}: ${newCards.length} cards (${category}${subcategory ? '/' + subcategory : ''})`);
                }

                // Update UI
                currentFileName = 'Imported Backup';
                applyFilters();
                showFlashcard();
                updateStats();
                updateCategoryBrowser();

                // Save to localStorage
                saveProgress();
                saveCategories();

                // Show success message
                console.log('âœ… Import complete!');
                alert(`âœ… Import successful!\n\n` +
                      `ðŸƒ ${totalImported} flashcards imported\n` +
                      `ðŸ“¦ ${importedCategories.size} categories restored\n` +
                      `ðŸ·ï¸  ${Object.keys(categoryGroups).length} groups restored\n\n` +
                      `Your data has been restored with full structure!`);

                // Show flashcard UI
                document.getElementById('flashcardContainer').style.display = 'block';
                document.getElementById('navigation').style.display = 'flex';
                document.getElementById('stats').style.display = 'block';
                document.getElementById('quickActions').style.display = 'grid';
                document.getElementById('viewModeToggle').style.display = 'flex';

            } catch (error) {
                console.error('âŒ Import failed:', error);
                alert(`âŒ Import failed!\n\nError: ${error.message}\n\nPlease check the console for details.`);
            }
        }

        // ==============================
        // END FILE MANAGER FUNCTIONALITY
        // ==============================

        // Intelligent Category Suggestion System
        let suggestedCategory = null;
        let suggestedSubcategory = null;

        function suggestCategoryFromFile(fileName, fileContent = '') {
            // Extract category hints from filename
            const nameLower = fileName.toLowerCase().replace(/\.(csv|txt|tsv)$/i, '');

            // IMPORTANT: Check for detailed level patterns BEFORE splitting (to preserve A1.1, B2.3, etc.)
            let detectedDetailedLevel = null;
            const detailedLevelMatch = nameLower.match(/([abc][12])\.(\d+)/i);
            if (detailedLevelMatch) {
                const level = detailedLevelMatch[1].toUpperCase();
                const sublevel = detailedLevelMatch[2];
                detectedDetailedLevel = `${level}.${sublevel}`;
                console.log('ðŸŽ¯ Pre-split: Found detailed level:', detectedDetailedLevel);
            }

            // Split filename by common separators to analyze parts
            const nameParts = nameLower.split(/[_\-\s.]+/);

            // Common patterns in filenames
            const patterns = {
                // Language levels - enhanced to catch more variations
                a1: /\b(a1(?!\.\d)|beginner|anfÃ¤nger|elementary)\b/i,
                a2: /\b(a2(?!\.\d)|elementary|grundstufe)\b/i,
                b1: /\b(b1(?!\.\d)|intermediate|mittelstufe)\b/i,
                b2: /\b(b2(?!\.\d)|upper[_\-]?intermediate|oberstufe)\b/i,
                c1: /\b(c1(?!\.\d)|advanced|fortgeschritten)\b/i,
                c2: /\b(c2(?!\.\d)|proficient|sehr[_\-]?fortgeschritten)\b/i,

                // Subject categories
                business: /\b(business|geschÃ¤ft|wirtschaft|beruf|office|meeting)\b/i,
                travel: /\b(travel|reise|urlaub|tourism|vacation|hotel|airport)\b/i,
                food: /\b(food|essen|cuisine|kÃ¼che|restaurant|cooking|meal)\b/i,
                medical: /\b(medical|medizin|health|gesundheit|doctor|arzt|hospital|clinic)\b/i,
                technology: /\b(tech|technology|computer|it|software|programming|digital)\b/i,
                everyday: /\b(everyday|daily|alltag|basic|common|routine)\b/i,
                family: /\b(family|familie|home|haus|zuhause|parents|kinder)\b/i,
                shopping: /\b(shopping|einkaufen|store|laden|market|kaufen)\b/i,
                work: /\b(work|arbeit|job|career|karriere|office)\b/i,

                // Content types
                verbs: /\b(verb|verben|action|tun|doing)\b/i,
                nouns: /\b(noun|nomen|substantiv|things|dinge|objects)\b/i,
                adjectives: /\b(adjective|adjektiv|beschreibung|describing)\b/i,
                phrases: /\b(phrase|satz|expression|redewendung|sentence|saying)\b/i,
                grammar: /\b(grammar|grammatik|rules|regeln|structure)\b/i,
                vocabulary: /\b(vocab|vokabel|wort|word|wÃ¶rter)\b/i,

                // Languages
                lang1: /\b(lang1|deutsch|de)\b/i,
                lang2: /\b(lang2|englisch|en)\b/i
            };

            let category = null;
            let subcategory = null;

            // Priority 1: Detect main category (theme/subject)
            if (patterns.business.test(nameLower)) {
                category = 'Business';
            } else if (patterns.travel.test(nameLower)) {
                category = 'Travel';
            } else if (patterns.medical.test(nameLower)) {
                category = 'Medical';
            } else if (patterns.technology.test(nameLower)) {
                category = 'Technology';
            } else if (patterns.food.test(nameLower)) {
                category = 'Food';
            } else if (patterns.family.test(nameLower)) {
                category = 'Family';
            } else if (patterns.shopping.test(nameLower)) {
                category = 'Shopping';
            } else if (patterns.work.test(nameLower)) {
                category = 'Work';
            } else if (patterns.everyday.test(nameLower)) {
                category = 'Everyday';
            } else if (patterns.lang1.test(nameLower)) {
                category = 'German';
            }

            // Priority 2: Detect subcategory (level or content type)
            // First use the pre-split detailed level if found (this preserves A1.1, B2.3, etc.)
            if (detectedDetailedLevel) {
                subcategory = detectedDetailedLevel;
                console.log('âœ… Using pre-split detailed level:', subcategory);
            }
            // Then check for basic language levels
            else if (patterns.a1.test(nameLower)) {
                subcategory = 'A1';
            } else if (patterns.a2.test(nameLower)) {
                subcategory = 'A2';
            } else if (patterns.b1.test(nameLower)) {
                subcategory = 'B1';
            } else if (patterns.b2.test(nameLower)) {
                subcategory = 'B2';
            } else if (patterns.c1.test(nameLower)) {
                subcategory = 'C1';
            } else if (patterns.c2.test(nameLower)) {
                subcategory = 'C2';
            }
            // Then check for numbered subcategories (e.g., Lesson1, Unit2, Chapter3)
            else {
                const numberedMatch = nameLower.match(/\b(lesson|unit|chapter|lektion|einheit|kapitel)[_\-\s]?(\d+)\b/i);
                if (numberedMatch) {
                    const type = numberedMatch[1].charAt(0).toUpperCase() + numberedMatch[1].slice(1);
                    const number = numberedMatch[2];
                    subcategory = `${type} ${number}`;
                    console.log('Detected numbered subcategory:', subcategory);
                }
                // Then content types
                else if (patterns.verbs.test(nameLower)) {
                    subcategory = 'Verbs';
                } else if (patterns.nouns.test(nameLower)) {
                    subcategory = 'Nouns';
                } else if (patterns.adjectives.test(nameLower)) {
                    subcategory = 'Adjectives';
                } else if (patterns.phrases.test(nameLower)) {
                    subcategory = 'Phrases';
                } else if (patterns.grammar.test(nameLower)) {
                    subcategory = 'Grammar';
                } else if (patterns.vocabulary.test(nameLower)) {
                    subcategory = 'Vocabulary';
                }
                // Finally, check for simple numbers at the end (e.g., vocab1, test2)
                else {
                    const simpleNumberMatch = nameLower.match(/(\d+)$/);
                    if (simpleNumberMatch) {
                        subcategory = `Part ${simpleNumberMatch[1]}`;
                        console.log('Detected simple numbered part:', subcategory);
                    }
                }
            }

            // Analyze file content for additional hints (first 1000 chars)
            if (fileContent && fileContent.length > 100) {
                const contentSample = fileContent.substring(0, 1000).toLowerCase();

                // If no category detected from filename, try content analysis
                if (!category) {
                    const germanWordCount = (contentSample.match(/\b(der|die|das|ich|du|er|sie|wir|und|oder|ist|sind|haben|sein)\b/g) || []).length;
                    if (germanWordCount > 5) {
                        category = 'German';
                    }
                }

                // If still no category, create one from first meaningful part of filename
                if (!category && nameParts.length > 0) {
                    // Take first meaningful part (not numbers or single letters)
                    const meaningfulPart = nameParts.find(part => part.length > 2 && !/^\d+$/.test(part));
                    if (meaningfulPart) {
                        // Capitalize first letter
                        category = meaningfulPart.charAt(0).toUpperCase() + meaningfulPart.slice(1);
                    }
                }
            }

            // Fallback: If still no category, use filename base as category
            if (!category) {
                const baseName = nameParts[0] || 'Vocabulary';
                category = baseName.charAt(0).toUpperCase() + baseName.slice(1);
            }

            // Smart subcategory fallback: If no subcategory detected, try to create one from filename parts
            if (!subcategory && nameParts.length > 1) {
                // Look for the second meaningful part that's not the category
                const categoryLower = category.toLowerCase();
                const potentialSubcat = nameParts.find((part, idx) => {
                    return idx > 0 &&
                           part.length > 1 &&
                           part !== categoryLower &&
                           part !== 'csv' &&
                           part !== 'txt' &&
                           !part.match(/^\d+$/); // Skip pure numbers
                });

                if (potentialSubcat) {
                    // Capitalize first letter
                    subcategory = potentialSubcat.charAt(0).toUpperCase() + potentialSubcat.slice(1);
                    console.log('  âœ¨ Created subcategory from filename parts:', subcategory);
                }
            }

            console.log('ðŸ” Smart Detection Analysis:');
            console.log('  ðŸ“ Filename:', fileName);
            console.log('  ðŸ“„ Lowercase name:', nameLower);
            console.log('  ðŸ“‚ Detected Category:', category || 'None');
            console.log('  ðŸ“‹ Detected Subcategory:', subcategory || 'None');
            console.log('  ðŸ”¤ Name parts:', nameParts);

            // Additional debugging for subcategory detection
            console.log('  ðŸ” Subcategory Detection Tests:');
            console.log('    - Detailed level (A1.1):', nameLower.match(/\b([abc][12])\.(\d+)\b/i));
            console.log('    - Basic A1:', patterns.a1.test(nameLower));
            console.log('    - Basic A2:', patterns.a2.test(nameLower));
            console.log('    - Verbs:', patterns.verbs.test(nameLower));
            console.log('    - Simple number:', nameLower.match(/(\d+)$/));

            return { category, subcategory };
        }

        function showCategorySuggestion(category, subcategory) {
            console.log('ðŸŽ¯ showCategorySuggestion CALLED with:', category, subcategory);

            const section = document.getElementById('suggestedCategorySection');
            const categoryInput = document.getElementById('suggestedCategoryInput');
            const subcategoryInput = document.getElementById('suggestedSubcategoryInput');

            if (!section || !categoryInput || !subcategoryInput) {
                console.error('âŒ Required elements not found for category suggestion');
                return;
            }

            suggestedCategory = category;
            suggestedSubcategory = subcategory;

            // If no category detected, use Default
            if (!category) {
                console.log('No category detected, using Default');
                category = 'Default';
            }

            // Populate the editable input fields with suggestions
            categoryInput.value = category || '';
            subcategoryInput.value = subcategory || '';

            console.log('ðŸ’¡ Showing suggestion box with:', category, subcategory);

            // Show the suggestion section
            section.style.display = 'block';

            console.log('âœ… Suggestion box displayed prominently');

            // Scroll to suggestion box smoothly
            setTimeout(() => {
                try {
                    section.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    categoryInput.focus();
                    categoryInput.select();
                } catch(e) {
                    console.error('Scroll/focus error:', e);
                }
            }, 300);
        }

        // Function to hide category suggestion
        function hideCategorySuggestion() {
            const section = document.getElementById('suggestedCategorySection');
            if (section) {
                section.style.display = 'none';
                console.log('âœ… Category suggestion box hidden');
            }
        }

        function autoApplyCategory(category, subcategory) {
            if (!category) return;

            // Create category if it doesn't exist
            if (!categories[category]) {
                categories[category] = [];
                console.log('Auto-created category:', category);
            }

            // Create subcategory if suggested and doesn't exist
            if (subcategory && !categories[category].includes(subcategory)) {
                categories[category].push(subcategory);
                console.log('Auto-created subcategory:', subcategory);
            }

            // Save and update UI
            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();

            // Assign current file to detected category AUTOMATICALLY
            if (currentFileName) {
                fileCategories[currentFileName] = {
                    category: category,
                    subcategory: subcategory || ''
                };
                currentFileCategory = fileCategories[currentFileName];
                saveCategories();
                updateCurrentFileDisplay();
            }

            // Update dropdowns to show selected values
            document.getElementById('categorySelect').value = category;
            updateSubcategoryDropdown();
            if (subcategory) {
                document.getElementById('subcategorySelect').value = subcategory;
            }

            // Render category browser
            renderCategoryBrowser();
        }

        function applySuggestedCategory() {
            // Read values from input fields (user might have edited them)
            const categoryInput = document.getElementById('suggestedCategoryInput');
            const subcategoryInput = document.getElementById('suggestedSubcategoryInput');

            let category = categoryInput.value.trim();
            let subcategory = subcategoryInput.value.trim();

            if (!category) {
                alert('Please enter a category name!');
                categoryInput.focus();
                return;
            }

            console.log('âœ… User approved category:', category, subcategory);

            // Create category if it doesn't exist
            if (!categories[category]) {
                categories[category] = [];
                console.log('Created new category:', category);
            }

            // âš ï¸ VALIDATION: Check for duplicate subcategory
            if (subcategory && categories[category].includes(subcategory)) {
                const proposedSubcategory = generateUniqueSubcategory(category, subcategory);

                // Show error dialog with proposed solution
                const userResponse = confirm(
                    'âš ï¸ DUPLICATE SUBCATEGORY DETECTED!\n\n' +
                    `Subcategory: "${subcategory}"\n` +
                    `Already exists in category: "${category}"\n\n` +
                    `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n` +
                    `PROPOSED SOLUTION:\n` +
                    `ðŸ“ New subcategory: "${proposedSubcategory}"\n\n` +
                    `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n` +
                    `Click OK to use the new subcategory name.\n` +
                    `Click CANCEL to edit it manually.`
                );

                if (!userResponse) {
                    // User cancelled - focus on subcategory input for manual edit
                    subcategoryInput.focus();
                    subcategoryInput.select();
                    console.log('âŒ User wants to manually edit subcategory');
                    return;
                }

                // User accepted - use proposed subcategory
                subcategory = proposedSubcategory;
                subcategoryInput.value = proposedSubcategory;
                console.log(`âœ… Using proposed subcategory: ${proposedSubcategory}`);
            }

            // Create subcategory if provided and doesn't exist
            if (subcategory && !categories[category].includes(subcategory)) {
                categories[category].push(subcategory);
                console.log('Created new subcategory:', subcategory);
            }

            // Save and update UI
            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();

            // Assign current file to approved category
            if (currentFileName) {
                fileCategories[currentFileName] = {
                    category: category,
                    subcategory: subcategory || ''
                };
                currentFileCategory = fileCategories[currentFileName];
                saveCategories(); // Save category mappings
                updateCurrentFileDisplay();

                console.log('âœ… File category assignment complete:', currentFileName, 'â†’', category, subcategory);
                console.log('ðŸ“¦ Flashcard data already in localStorage (saved during parsing)');
            }

            // Update dropdowns to show selected values
            document.getElementById('categorySelect').value = category;
            updateSubcategoryDropdown();
            if (subcategory) {
                document.getElementById('subcategorySelect').value = subcategory;
            }

            // Hide suggestion section
            document.getElementById('suggestedCategorySection').style.display = 'none';

            // Hide manage categories section
            document.getElementById('mainManageCategories').style.display = 'none';

            // Show format selector
            const formatSelector = document.getElementById('formatSelector');
            if (formatSelector) {
                formatSelector.style.display = 'block';
                console.log('   âœ… Format selector shown');
            }

            // Render category browser (always visible)
            renderCategoryBrowser();

            // Show success message
            const subText = subcategory ? ` â†’ ${subcategory}` : '';
            alert(`âœ“ Success! File assigned to:\nðŸ“ ${category}${subText}\n\nNext: Choose how to load your file below!`);
        }

        function rejectSuggestion() {
            console.log('âŒ User rejected suggestion, using Default');

            // Assign to Default category
            if (currentFileName) {
                fileCategories[currentFileName] = {
                    category: 'Default',
                    subcategory: ''
                };
                currentFileCategory = fileCategories[currentFileName];
                saveCategories(); // Save category mappings
                updateCurrentFileDisplay();

                console.log('âœ… File assigned to Default category:', currentFileName);
                console.log('ðŸ“¦ Flashcard data already in localStorage (saved during parsing)');
            }

            // Update dropdowns
            document.getElementById('categorySelect').value = 'Default';
            updateSubcategoryDropdown();

            // Hide suggestion section
            document.getElementById('suggestedCategorySection').style.display = 'none';

            // Show manage categories section so user can manually select
            document.getElementById('mainManageCategories').style.display = 'block';
            console.log('   âœ… Manage Categories shown for manual selection');

            // Render category browser (always visible)
            renderCategoryBrowser();

            alert('âœ“ File assigned to Default category\n\nNext: Manually select a category below, then choose how to load your file!');
        }

        // ===== CLOUD SYNC FUNCTIONS =====

        // Simple hash function for password
        async function hashPassword(password) {
            const encoder = new TextEncoder();
            const data = encoder.encode(password);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Encrypt data with password (AES-GCM)
        async function encryptData(data, password) {
            try {
                const encoder = new TextEncoder();
                const dataStr = JSON.stringify(data);

                // Log original size
                const originalSize = new Blob([dataStr]).size;
                console.log(`ðŸ“¦ Original data size: ${(originalSize / 1024 / 1024).toFixed(2)}MB`);

                // COMPRESS data using pako (gzip compression)
                const compressed = pako.deflate(dataStr, { level: 9 }); // level 9 = maximum compression
                const compressedSize = compressed.byteLength;
                const compressionRatio = ((1 - compressedSize / originalSize) * 100).toFixed(1);
                console.log(`ðŸ—œï¸  Compressed size: ${(compressedSize / 1024 / 1024).toFixed(2)}MB (${compressionRatio}% reduction)`);

                // Add version marker (0x01 = compressed version)
                const versionMarker = new Uint8Array([0x01]);
                const dataWithVersion = new Uint8Array(versionMarker.length + compressed.length);
                dataWithVersion.set(versionMarker, 0);
                dataWithVersion.set(compressed, versionMarker.length);

                // Generate key from password
                const passwordKey = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(password.padEnd(32, '0').slice(0, 32)),
                    'AES-GCM',
                    false,
                    ['encrypt']
                );

                // Generate random IV
                const iv = crypto.getRandomValues(new Uint8Array(12));

                // Encrypt (compressed data)
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    passwordKey,
                    dataWithVersion
                );

                // Combine IV and encrypted data
                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv, 0);
                combined.set(new Uint8Array(encrypted), iv.length);

                const finalSize = combined.byteLength;
                console.log(`ðŸ”’ Encrypted size: ${(finalSize / 1024 / 1024).toFixed(2)}MB`);
                console.log(`âœ… Total size reduction: ${((1 - finalSize / originalSize) * 100).toFixed(1)}%`);

                // Convert to base64 (process in chunks to avoid call stack overflow)
                let binary = '';
                const chunkSize = 8192; // Process 8KB at a time
                for (let i = 0; i < combined.length; i += chunkSize) {
                    const chunk = combined.slice(i, Math.min(i + chunkSize, combined.length));
                    binary += String.fromCharCode(...chunk);
                }
                return btoa(binary);
            } catch (error) {
                console.error('Encryption error:', error);
                throw error;
            }
        }

        // Decrypt data with password (supports both compressed and uncompressed)
        async function decryptData(encryptedBase64, password) {
            try {
                console.log('ðŸ”“ Starting decryption...');

                // Decode base64
                const combined = new Uint8Array(atob(encryptedBase64).split('').map(c => c.charCodeAt(0)));

                // Extract IV and encrypted data
                const iv = combined.slice(0, 12);
                const encrypted = combined.slice(12);

                // Generate key from password
                const encoder = new TextEncoder();
                const passwordKey = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(password.padEnd(32, '0').slice(0, 32)),
                    'AES-GCM',
                    false,
                    ['decrypt']
                );

                // Decrypt
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    passwordKey,
                    encrypted
                );

                const decryptedArray = new Uint8Array(decrypted);

                // Check for version marker (first byte)
                const version = decryptedArray[0];

                if (version === 0x01) {
                    // NEW FORMAT: Compressed data
                    console.log('ðŸ—œï¸  Detected compressed data, decompressing...');

                    // Extract compressed data (skip version marker)
                    const compressedData = decryptedArray.slice(1);

                    // DECOMPRESS using pako
                    const decompressed = pako.inflate(compressedData, { to: 'string' });

                    console.log(`âœ… Decompressed successfully (${(decompressed.length / 1024).toFixed(2)}KB)`);

                    return JSON.parse(decompressed);
                } else {
                    // Try to detect if data is compressed without version marker (legacy compressed data)
                    // Check for gzip magic number (0x1f 0x8b) at start
                    if (decryptedArray.length > 2 && decryptedArray[0] === 0x1f && decryptedArray[1] === 0x8b) {
                        console.log('ðŸ—œï¸  Detected gzip compressed data (no version marker), decompressing...');
                        try {
                            const decompressed = pako.inflate(decryptedArray, { to: 'string' });
                            console.log(`âœ… Decompressed successfully (${(decompressed.length / 1024).toFixed(2)}KB)`);
                            return JSON.parse(decompressed);
                        } catch (decompressError) {
                            console.error('âŒ Decompression failed, trying as uncompressed:', decompressError);
                        }
                    }

                    // OLD FORMAT: Uncompressed data (backward compatible)
                    console.log('ðŸ“„ Detected uncompressed data (legacy format)');

                    const decoder = new TextDecoder();
                    const dataStr = decoder.decode(decrypted);
                    return JSON.parse(dataStr);
                }
            } catch (error) {
                console.error('Decryption error:', error);
                throw error;
            }
        }

        // Initialize Firebase
        function initializeFirebase() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY_HERE") {
                console.log('Firebase not configured yet');
                return false;
            }

            try {
                if (!firebase.apps.length) {
                    firebase.initializeApp(firebaseConfig);
                }
                firebaseDB = firebase.database();
                console.log('Firebase initialized successfully');
                return true;
            } catch (error) {
                console.error('Firebase initialization error:', error);
                return false;
            }
        }

        // Handle Enter key press in login form
        function handleLoginKeyPress(event) {
            if (event.key === 'Enter' || event.keyCode === 13) {
                event.preventDefault();

                // Check which mode we're in (login or signup)
                const signupBtn = document.getElementById('signupBtn');
                const loginBtn = document.getElementById('loginBtn');
                const isSignupMode = signupBtn && signupBtn.style.display !== 'none';

                if (isSignupMode) {
                    // Trigger signup button click
                    signupBtn.click();
                } else {
                    // Trigger login button click
                    loginBtn.click();
                }
            }
        }

        // Cloud Login
        async function cloudLogin() {
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value;

            if (!username || !password) {
                alert('Please enter username and password');
                return;
            }

            if (username.length < 3) {
                alert('Username must be at least 3 characters');
                return;
            }

            if (password.length < 6) {
                alert('Password must be at least 6 characters');
                return;
            }

            // Initialize Firebase
            if (!initializeFirebase()) {
                alert('âš ï¸ Cloud sync not configured yet.\n\nPlease follow the setup instructions to enable cloud sync.\n\nFor now, using local storage only.');
                skipLogin();
                return;
            }

            try {
                // Hash password for storage
                const passwordHash = await hashPassword(password);

                cloudUser = {
                    username: username,
                    password: password, // Keep for encryption
                    passwordHash: passwordHash
                };

                // Save login info (encrypted)
                safeStorage.setItem('cloud_user', JSON.stringify({
                    username: username,
                    passwordHash: passwordHash
                }));

                isCloudEnabled = true;
                isCloudFirstMode = true; // Enable cloud-first storage to avoid localStorage quota issues

                // Show cloud-first mode indicator
                console.log('%câ˜ï¸ CLOUD-FIRST MODE ENABLED', 'background: #4CAF50; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold');
                console.log('âœ… Data will be saved directly to cloud, avoiding localStorage quota issues');
                console.log('âœ… Minimal cache kept in localStorage for offline fallback');

                // Clean up any corrupted localStorage entries from previous quota errors
                safeStorage.cleanupCorrupted();

                // Hide login modal
                document.getElementById('loginOverlay').style.display = 'none';

                // Show account button in hamburger panel and sync status
                document.getElementById('accountButtonPanel').style.display = 'block';
                document.getElementById('syncStatus').style.display = 'block';
                document.getElementById('compressDataBtn').style.display = 'block'; // Show compress button
                updateSyncStatus('syncing', 'Syncing...');

                // ========================================================
                // HYBRID CLOUD-MASTER MODE:
                // - Cloud is ALWAYS the master (source of truth)
                // - localStorage is NEVER uploaded to cloud on login
                // - localStorage only used as temporary practice cache
                // - Clear ALL localStorage on login to prevent conflicts
                // ========================================================

                console.log('%câ˜ï¸ CLOUD-MASTER MODE', 'background: #2196F3; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold');
                console.log('ðŸ“‹ Cloud = Master (always read from cloud)');
                console.log('ðŸ’¾ localStorage = Practice cache only (never uploaded)');

                // STEP 1: Clear ALL localStorage immediately (no questions asked)
                console.log('ðŸ§¹ Clearing ALL localStorage (cloud-master mode)...');
                let clearedCount = 0;
                try {
                    const keysToRemove = [];
                    for (let key in localStorage) {
                        if (localStorage.hasOwnProperty(key) &&
                            (key.startsWith('flashcards_') || key === 'practice_cache')) {
                            keysToRemove.push(key);
                        }
                    }

                    keysToRemove.forEach(key => {
                        safeStorage.removeItem(key);
                        clearedCount++;
                    });

                    console.log(`âœ… Cleared ${clearedCount} flashcard entries from localStorage`);
                    console.log('âœ… localStorage clean - ready for cloud data');
                } catch (e) {
                    console.warn('âš ï¸ Could not clear localStorage (non-critical):', e);
                }

                // STEP 2: Download from cloud ONLY (ignore any localStorage data)
                console.log('ðŸ“¥ Downloading ALL data from cloud...');
                try {
                    await downloadFromCloud();
                    pendingCloudSync.clear(); // Clear any stale pending items
                    console.log('âœ… Cloud data loaded successfully');
                } catch (downloadError) {
                    updateSyncStatus('error', 'âŒ Download Failed');
                    console.error('âŒ Failed to download from cloud:', downloadError);
                    alert('âš ï¸ CLOUD DOWNLOAD FAILED\n\n' +
                        'Could not download your data from cloud.\n\n' +
                        'WHAT TO DO:\n' +
                        '1. Check your internet connection\n' +
                        '2. Try logging in again\n' +
                        '3. Contact support if problem persists\n\n' +
                        `Error: ${downloadError?.message || 'Unknown error'}`);
                    throw new Error('Download failed - cannot proceed without cloud data');
                }

                // Load categories (will use cloud data if available)
                loadCategories();

                // Refresh category browser to display downloaded categories
                renderCategoryBrowser();

                updateSyncStatus('synced', 'â˜ï¸ Synced');

                console.log('Cloud login successful');

                // Auto-load all flashcards from all categories
                autoLoadAllCategories();
            } catch (error) {
                console.error('Login error:', error);
                alert('Login failed. Please try again.');
            }
        }

        // Cloud Signup
        async function cloudSignup() {
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value;
            const confirmPassword = document.getElementById('confirmPassword').value;

            if (!username || !password || !confirmPassword) {
                alert('Please fill in all fields');
                return;
            }

            if (username.length < 3) {
                alert('Username must be at least 3 characters');
                return;
            }

            if (password.length < 6) {
                alert('Password must be at least 6 characters');
                return;
            }

            if (password !== confirmPassword) {
                alert('Passwords do not match!');
                return;
            }

            // Initialize Firebase
            if (!initializeFirebase()) {
                alert('âš ï¸ Cloud sync not configured yet.\n\nPlease follow the setup instructions to enable cloud sync.\n\nFor now, using local storage only.');
                skipLogin();
                return;
            }

            try {
                // Check if username already exists
                const userPath = `users-universal/${username}`;
                const snapshot = await firebaseDB.ref(userPath).once('value');

                if (snapshot.exists()) {
                    alert('âŒ Username already taken!\n\nPlease choose a different username or login if this is your account.');
                    return;
                }

                // Hash password for storage
                const passwordHash = await hashPassword(password);

                cloudUser = {
                    username: username,
                    password: password, // Keep for encryption
                    passwordHash: passwordHash
                };

                // Save login info
                safeStorage.setItem('cloud_user', JSON.stringify({
                    username: username,
                    passwordHash: passwordHash
                }));

                isCloudEnabled = true;
                isCloudFirstMode = true; // Enable cloud-first storage to avoid localStorage quota issues

                // Show cloud-first mode indicator
                console.log('%câ˜ï¸ CLOUD-FIRST MODE ENABLED', 'background: #4CAF50; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold');
                console.log('âœ… Data will be saved directly to cloud, avoiding localStorage quota issues');
                console.log('âœ… Minimal cache kept in localStorage for offline fallback');

                // Clean up any corrupted localStorage entries from previous quota errors
                safeStorage.cleanupCorrupted();

                // Hide login modal
                document.getElementById('loginOverlay').style.display = 'none';

                // Show account button in hamburger panel and sync status
                document.getElementById('accountButtonPanel').style.display = 'block';
                document.getElementById('syncStatus').style.display = 'block';
                document.getElementById('compressDataBtn').style.display = 'block'; // Show compress button
                updateSyncStatus('syncing', 'Syncing...');

                // Load categories (will be empty for new user, or from localStorage if migrating)
                loadCategories();

                // Refresh category browser
                renderCategoryBrowser();

                // IMPORTANT: Upload any localStorage data BEFORE clearing
                // This handles migration scenario where user had offline data
                console.log('ðŸ“¤ Checking for local data to upload before clearing...');
                const localFiles = safeStorage.getStoredFiles();
                if (localFiles.length > 0) {
                    console.log(`ðŸ“¦ Found ${localFiles.length} files in localStorage. Uploading to cloud first...`);
                }
                await uploadToCloud(); // Upload everything (or create empty account if no local data)
                pendingCloudSync.clear(); // Clear any pending items after upload

                // AFTER uploading, clear all flashcard data from localStorage to free up space
                console.log('ðŸ§¹ Clearing flashcard data from localStorage (data is now in cloud)...');
                let clearedCount = 0;
                try {
                    const keysToRemove = [];
                    for (let key in localStorage) {
                        if (localStorage.hasOwnProperty(key) && key.startsWith('flashcards_')) {
                            keysToRemove.push(key);
                        }
                    }

                    keysToRemove.forEach(key => {
                        safeStorage.removeItem(key);
                        clearedCount++;
                    });

                    console.log(`âœ… Cleared ${clearedCount} flashcard entries from localStorage`);
                    const freedMB = (safeStorage.getStorageUsage() / (1024 * 1024)).toFixed(2);
                    console.log(`ðŸ“Š localStorage now: ${freedMB}MB (freed up space for metadata)`);
                } catch (e) {
                    console.warn('Could not clear localStorage:', e);
                }

                updateSyncStatus('synced', 'âœ… Account Created!');

                alert('âœ… Account created successfully!\n\nYour categories will now sync across all devices.');

                console.log('Cloud signup successful');
            } catch (error) {
                console.error('Signup error:', error);
                alert('Signup failed. Please try again.');
            }
        }

        // Safe localStorage wrapper (handles tracking prevention and quota exceeded)
        const safeStorage = {
            // Maximum chunk size (1MB per chunk to stay well under quota)
            CHUNK_SIZE: 1024 * 1024, // 1MB

            getItem: function(key) {
                try {
                    // Try to get regular item first
                    const item = localStorage.getItem(key);
                    if (item !== null) {
                        return item;
                    }

                    // Check if it's a chunked item
                    const chunkCount = localStorage.getItem(`${key}_chunks`);
                    if (chunkCount) {
                        return this.getChunkedItem(key, parseInt(chunkCount));
                    }

                    return null;
                } catch (e) {
                    console.warn('localStorage blocked by browser:', e);
                    return null;
                }
            },

            setItem: function(key, value) {
                // Check quota before attempting to save
                const quotaCheck = this.checkQuota(value.length);

                if (quotaCheck.shouldWarn) {
                    console.warn(`âš ï¸ Storage usage high: ${quotaCheck.usagePercent}% (${quotaCheck.totalSizeMB}MB / ~8MB)`);
                }

                if (!quotaCheck.hasSpace) {
                    console.error('Storage quota will be exceeded. Cannot save.');
                    const cleanupMsg = this.suggestCleanup();
                    throw new Error('QUOTA_EXCEEDED_WITH_DETAILS:' + cleanupMsg);
                }

                try {
                    // Try normal storage first
                    localStorage.setItem(key, value);
                } catch (e) {
                    if (e.name === 'QuotaExceededError') {
                        console.warn('localStorage quota exceeded, attempting chunked storage...');
                        try {
                            // Remove the failed attempt
                            localStorage.removeItem(key);

                            // Try chunked storage
                            this.setChunkedItem(key, value);
                        } catch (chunkError) {
                            console.error('Chunked storage also failed:', chunkError);

                            // Provide detailed cleanup suggestions
                            const cleanupMsg = this.suggestCleanup();
                            throw new Error('QUOTA_EXCEEDED_WITH_DETAILS:' + cleanupMsg);
                        }
                    } else {
                        console.warn('localStorage blocked by browser:', e);
                        throw e;
                    }
                }
            },

            setChunkedItem: function(key, value) {
                // Remove any existing chunks
                this.removeItem(key);

                const chunks = [];
                let offset = 0;

                // Split into chunks
                while (offset < value.length) {
                    chunks.push(value.substring(offset, offset + this.CHUNK_SIZE));
                    offset += this.CHUNK_SIZE;
                }

                console.log(`Splitting ${key} into ${chunks.length} chunks`);

                // Store chunk count
                localStorage.setItem(`${key}_chunks`, chunks.length.toString());

                // Store each chunk
                for (let i = 0; i < chunks.length; i++) {
                    localStorage.setItem(`${key}_chunk_${i}`, chunks[i]);
                }
            },

            getChunkedItem: function(key, chunkCount) {
                const chunks = [];

                for (let i = 0; i < chunkCount; i++) {
                    const chunk = localStorage.getItem(`${key}_chunk_${i}`);
                    if (chunk === null) {
                        // Missing chunk - data is corrupted (don't log as error, handled at higher level)
                        return null;
                    }
                    chunks.push(chunk);
                }

                return chunks.join('');
            },

            removeItem: function(key) {
                try {
                    // Remove regular item
                    localStorage.removeItem(key);

                    // Remove chunked items if they exist
                    const chunkCount = localStorage.getItem(`${key}_chunks`);
                    if (chunkCount) {
                        const count = parseInt(chunkCount);
                        for (let i = 0; i < count; i++) {
                            localStorage.removeItem(`${key}_chunk_${i}`);
                        }
                        localStorage.removeItem(`${key}_chunks`);
                    }
                } catch (e) {
                    console.warn('localStorage blocked by browser:', e);
                }
            },

            // Get total localStorage usage in bytes
            getStorageUsage: function() {
                let totalSize = 0;
                try {
                    for (let key in localStorage) {
                        if (localStorage.hasOwnProperty(key)) {
                            totalSize += localStorage[key].length + key.length;
                        }
                    }
                } catch (e) {
                    console.warn('Could not calculate storage usage:', e);
                }
                return totalSize;
            },

            // Get list of stored flashcard files with sizes
            getStoredFiles: function() {
                const files = [];
                const processedKeys = new Set();

                try {
                    for (let key in localStorage) {
                        if (localStorage.hasOwnProperty(key) && key.startsWith('flashcards_')) {
                            // Skip chunk metadata keys
                            if (key.endsWith('_chunks') || key.includes('_chunk_')) {
                                continue;
                            }

                            const baseKey = key;
                            if (processedKeys.has(baseKey)) continue;
                            processedKeys.add(baseKey);

                            // Get full content (whether chunked or not)
                            const content = this.getItem(baseKey);
                            if (content) {
                                const fileName = key.replace('flashcards_', '');
                                const size = content.length;

                                // Try to get card count
                                let cardCount = 0;
                                try {
                                    const data = JSON.parse(content);
                                    cardCount = Array.isArray(data) ? data.length : 0;
                                } catch (e) {
                                    // Invalid JSON, ignore card count
                                }

                                files.push({
                                    key: baseKey,
                                    fileName: fileName,
                                    size: size,
                                    sizeMB: (size / (1024 * 1024)).toFixed(2),
                                    cardCount: cardCount
                                });
                            }
                        }
                    }

                    // Sort by size (largest first)
                    files.sort((a, b) => b.size - a.size);
                } catch (e) {
                    console.warn('Could not list stored files:', e);
                }

                return files;
            },

            // Check if there's enough quota for new data
            checkQuota: function(newDataSize) {
                const currentUsage = this.getStorageUsage();
                const totalSize = currentUsage + newDataSize;

                // Typical localStorage limit is 5-10MB, we'll use 8MB as safe threshold
                const STORAGE_LIMIT = 8 * 1024 * 1024; // 8MB
                const WARNING_THRESHOLD = 0.7; // Warn at 70%

                const usagePercent = totalSize / STORAGE_LIMIT;

                return {
                    hasSpace: totalSize < STORAGE_LIMIT,
                    currentUsageMB: (currentUsage / (1024 * 1024)).toFixed(2),
                    totalSizeMB: (totalSize / (1024 * 1024)).toFixed(2),
                    usagePercent: (usagePercent * 100).toFixed(1),
                    shouldWarn: usagePercent > WARNING_THRESHOLD
                };
            },

            // Suggest which files to delete to free up space
            suggestCleanup: function() {
                const files = this.getStoredFiles();
                const currentUsage = this.getStorageUsage();
                const currentUsageMB = (currentUsage / (1024 * 1024)).toFixed(2);

                let message = `ðŸ“Š STORAGE USAGE: ${currentUsageMB}MB / ~8MB\n\n`;
                message += `You have ${files.length} flashcard file(s) stored:\n\n`;

                files.forEach((file, index) => {
                    message += `${index + 1}. ${file.fileName}\n`;
                    message += `   Size: ${file.sizeMB}MB (${file.cardCount} cards)\n\n`;
                });

                if (files.length > 0) {
                    message += `ðŸ’¡ TIP: Delete unused files in the "Manage Files" section (â˜° menu) to free up space.\n\n`;
                    message += `Or enable Cloud Sync (â˜ï¸ button) to store data online instead of locally.`;
                } else {
                    message += `Other data is using storage. Try:\n`;
                    message += `1. Clear browser cache for this site\n`;
                    message += `2. Check browser's storage settings`;
                }

                return message;
            },

            // Clean up corrupted localStorage entries (orphaned chunks, incomplete data)
            cleanupCorrupted: function() {
                console.log('ðŸ§¹ Cleaning up corrupted localStorage entries...');
                let removedCount = 0;

                try {
                    const keysToCheck = [];
                    for (let key in localStorage) {
                        if (localStorage.hasOwnProperty(key) && key.startsWith('flashcards_')) {
                            keysToCheck.push(key);
                        }
                    }

                    keysToCheck.forEach(key => {
                        // Skip chunk metadata keys
                        if (key.endsWith('_chunks') || key.includes('_chunk_')) {
                            return;
                        }

                        // Try to read the data
                        const data = this.getItem(key);
                        if (data === null) {
                            // Corrupted or unreadable - remove it
                            console.log(`   Removing corrupted entry: ${key}`);
                            this.removeItem(key);
                            removedCount++;
                        }
                    });

                    if (removedCount > 0) {
                        console.log(`âœ… Cleaned up ${removedCount} corrupted entry/entries`);
                    } else {
                        console.log('âœ… No corrupted entries found');
                    }
                } catch (e) {
                    console.warn('Could not complete cleanup:', e);
                }

                return removedCount;
            }
        };

        // Toggle between Login and Signup modes
        function toggleLoginMode() {
            const title = document.getElementById('loginTitle');
            const subtitle = document.getElementById('loginSubtitle');
            const loginBtn = document.getElementById('loginBtn');
            const signupBtn = document.getElementById('signupBtn');
            const confirmPassword = document.getElementById('confirmPassword');
            const toggleText = document.getElementById('toggleText');

            if (loginBtn.style.display !== 'none') {
                // Switch to Signup mode
                title.textContent = 'ðŸ“ Create Account';
                subtitle.textContent = 'Sync your categories across all devices';
                loginBtn.style.display = 'none';
                signupBtn.style.display = 'block';
                confirmPassword.style.display = 'block';
                toggleText.innerHTML = 'Already have an account? <a href="#" onclick="window.toggleLoginMode(); return false;" style="color: #667eea; text-decoration: none; font-weight: bold;">Login</a>';
            } else {
                // Switch to Login mode
                title.textContent = 'â˜ï¸ Cloud Sync Login';
                subtitle.textContent = 'Access your categories from any device';
                loginBtn.style.display = 'block';
                signupBtn.style.display = 'none';
                confirmPassword.style.display = 'none';
                confirmPassword.value = '';
                toggleText.innerHTML = 'Don\'t have an account? <a href="#" onclick="window.toggleLoginMode(); return false;" style="color: #667eea; text-decoration: none; font-weight: bold;">Sign Up</a>';
            }
        }

        // Make functions globally accessible (fixes tracking prevention issues)
        window.toggleLoginMode = toggleLoginMode;
        window.cloudLogin = cloudLogin;
        window.cloudSignup = cloudSignup;
        window.skipLogin = skipLogin;
        window.compressAndReuploadData = compressAndReuploadData;

        // Skip Login (Local Only)
        function skipLogin() {
            isCloudEnabled = false;
            document.getElementById('loginOverlay').style.display = 'none';
            loadCategories();
            renderCategoryBrowser();
            console.log('Using local storage only');
        }

        // ===== ACCOUNT MANAGEMENT FUNCTIONS =====

        // Open Account Settings
        function openAccountSettings() {
            document.getElementById('accountModal').style.display = 'flex';
            document.getElementById('accountUsername').textContent = cloudUser ? cloudUser.username : '-';
            document.getElementById('accountStatus').textContent = isCloudEnabled ? 'âœ… Connected' : 'âŒ Offline';
            const syncText = document.getElementById('syncStatusText').textContent;
            document.getElementById('accountSyncStatus').textContent = syncText;
        }

        // Close Account Settings
        function closeAccountSettings() {
            document.getElementById('accountModal').style.display = 'none';
            document.getElementById('changePasswordSection').style.display = 'none';
            document.getElementById('deleteAccountSection').style.display = 'none';
        }

        // Show Change Password Section
        function showChangePassword() {
            document.getElementById('changePasswordSection').style.display = 'block';
            document.getElementById('deleteAccountSection').style.display = 'none';
        }

        // Cancel Change Password
        function cancelChangePassword() {
            document.getElementById('changePasswordSection').style.display = 'none';
            document.getElementById('currentPassword').value = '';
            document.getElementById('newPassword').value = '';
            document.getElementById('confirmNewPassword').value = '';
        }

        // Change Password
        async function changePassword() {
            const currentPwd = document.getElementById('currentPassword').value;
            const newPwd = document.getElementById('newPassword').value;
            const confirmPwd = document.getElementById('confirmNewPassword').value;

            if (!currentPwd || !newPwd || !confirmPwd) {
                alert('Please fill in all password fields');
                return;
            }

            if (newPwd !== confirmPwd) {
                alert('New passwords do not match');
                return;
            }

            if (newPwd.length < 6) {
                alert('New password must be at least 6 characters');
                return;
            }

            if (!cloudUser || !firebaseDB) {
                alert('Not connected to cloud');
                return;
            }

            try {
                // Verify current password
                const currentHash = await hashPassword(currentPwd);
                if (currentHash !== cloudUser.passwordHash) {
                    alert('Current password is incorrect');
                    return;
                }

                updateSyncStatus('syncing', 'Changing password...');

                // Download and decrypt current data with old password
                const userPath = `users-universal/${cloudUser.username}`;
                const snapshot = await firebaseDB.ref(userPath).once('value');
                const cloudData = snapshot.val();

                if (!cloudData || !cloudData.data) {
                    alert('No data found to re-encrypt');
                    return;
                }

                // Decrypt with old password
                const decrypted = decrypt(cloudData.data, currentPwd);
                if (!decrypted) {
                    alert('Failed to decrypt existing data');
                    return;
                }

                // Re-encrypt with new password
                const encrypted = encrypt(decrypted, newPwd);

                // Generate new password hash
                const newHash = await hashPassword(newPwd);

                // Update in Firebase
                await firebaseDB.ref(userPath).update({
                    passwordHash: newHash,
                    data: encrypted,
                    lastModified: Date.now()
                });

                // Update local cloudUser object
                cloudUser.password = newPwd;
                cloudUser.passwordHash = newHash;

                // Update local storage
                safeStorage.setItem('cloud_user', JSON.stringify({
                    username: cloudUser.username,
                    passwordHash: newHash
                }));

                updateSyncStatus('synced', 'Synced');
                alert('âœ… Password changed successfully!\n\nYour data has been re-encrypted with the new password.');
                cancelChangePassword();

            } catch (error) {
                console.error('Password change error:', error);
                alert('Failed to change password: ' + error.message);
                updateSyncStatus('error', 'Error');
            }
        }

        // Show Delete Account Section
        function showDeleteAccount() {
            document.getElementById('deleteAccountSection').style.display = 'block';
            document.getElementById('changePasswordSection').style.display = 'none';
        }

        // Cancel Delete Account
        function cancelDeleteAccount() {
            document.getElementById('deleteAccountSection').style.display = 'none';
            document.getElementById('deletePassword').value = '';
        }

        // Confirm Delete Account
        async function confirmDeleteAccount() {
            const password = document.getElementById('deletePassword').value;

            if (!password) {
                alert('Please enter your password to confirm deletion');
                return;
            }

            if (!cloudUser || !firebaseDB) {
                alert('Not connected to cloud');
                return;
            }

            try {
                // Verify password
                const passwordHash = await hashPassword(password);
                if (passwordHash !== cloudUser.passwordHash) {
                    alert('Incorrect password');
                    return;
                }

                const confirmDelete = confirm(
                    'âš ï¸ FINAL WARNING âš ï¸\n\n' +
                    'This will permanently delete:\n' +
                    'â€¢ All your categories\n' +
                    'â€¢ All your vocabulary data\n' +
                    'â€¢ Your account from the cloud\n\n' +
                    'This action CANNOT be undone!\n\n' +
                    'Are you absolutely sure?'
                );

                if (!confirmDelete) {
                    return;
                }

                updateSyncStatus('syncing', 'Deleting account...');

                // Delete from Firebase
                const userPath = `users-universal/${cloudUser.username}`;
                await firebaseDB.ref(userPath).remove();

                // Clear local data
                safeStorage.removeItem('cloud_user');
                safeStorage.removeItem('flashcard_categories');
                safeStorage.removeItem('flashcard_file_categories');

                // Reset app state
                cloudUser = null;
                isCloudEnabled = false;
                categories = { 'Default': [] };
                fileCategories = {};

                alert('âœ… Account deleted successfully.\n\nYou will be logged out now.');

                // Reload page
                window.location.reload();

            } catch (error) {
                console.error('Delete account error:', error);
                alert('Failed to delete account: ' + error.message);
                updateSyncStatus('error', 'Error');
            }
        }

        // Logout
        function logoutAccount() {
            const confirmLogout = confirm(
                'Are you sure you want to logout?\n\n' +
                'Your data is synced to the cloud and will be available when you login again.'
            );

            if (!confirmLogout) {
                return;
            }

            // Clear local session
            safeStorage.removeItem('cloud_user');

            // Clear practice cache (hybrid cloud-master mode)
            clearPracticeCache();

            // Clear all flashcard data from localStorage
            try {
                for (let key in localStorage) {
                    if (key.startsWith('flashcards_') || key === 'practice_cache' || key === 'practice_cache_filename') {
                        safeStorage.removeItem(key);
                    }
                }
                console.log('ðŸ§¹ All flashcard data cleared on logout');
            } catch (e) {
                console.warn('âš ï¸ Could not clear localStorage:', e);
            }

            // Reset app state
            cloudUser = null;
            isCloudEnabled = false;
            cloudDataCache = {}; // Clear memory cache too

            alert('âœ… Logged out successfully.\n\nYou can login again anytime to access your data.');

            // Reload page
            window.location.reload();
        }

        // Make account functions globally accessible
        window.openAccountSettings = openAccountSettings;
        window.closeAccountSettings = closeAccountSettings;
        window.showChangePassword = showChangePassword;
        window.cancelChangePassword = cancelChangePassword;
        window.changePassword = changePassword;
        window.showDeleteAccount = showDeleteAccount;
        window.cancelDeleteAccount = cancelDeleteAccount;
        window.confirmDeleteAccount = confirmDeleteAccount;
        window.logoutAccount = logoutAccount;

        // ===== END ACCOUNT MANAGEMENT FUNCTIONS =====

        // Clean up orphaned entries (only during login/sync, NOT during regular uploads)
        function cleanupOrphanedEntries() {
            console.log('ðŸ§¹ Checking for orphaned file entries...');
            let cleanupNeeded = false;
            const orphanedFiles = [];

            Object.keys(fileCategories).forEach(fileName => {
                const inLocalStorage = safeStorage.getItem(`flashcards_${fileName}`);
                const inCloudCache = cloudDataCache && cloudDataCache[fileName];

                if (!inLocalStorage && !inCloudCache) {
                    console.log(`âš ï¸ Found orphaned file entry: ${fileName}`);
                    orphanedFiles.push(fileName);
                    delete fileCategories[fileName];
                    cleanupNeeded = true;
                }
            });

            if (cleanupNeeded) {
                console.log(`âœ… Cleaned up ${orphanedFiles.length} orphaned entries:`, orphanedFiles);
                safeStorage.setItem('flashcard_file_categories', JSON.stringify(fileCategories));
            } else {
                console.log('âœ… No orphaned entries found');
            }

            return cleanupNeeded;
        }

        // Upload to Cloud
        async function uploadToCloud() {
            if (!isCloudEnabled || !cloudUser || !firebaseDB) {
                return;
            }

            try {
                updateSyncStatus('syncing', 'Uploading...');

                // Collect all flashcard data from localStorage and cloudDataCache
                const allFlashcardData = {};

                // CRITICAL FIX: Read from localStorage DIRECTLY, not just fileCategories
                // This prevents data loss when fileCategories mapping is empty/corrupted
                const storedFiles = safeStorage.getStoredFiles();
                console.log(`ðŸ” Found ${storedFiles.length} files in localStorage to upload`);

                // First, collect from cloudDataCache (for files already in memory)
                if (cloudDataCache) {
                    Object.keys(cloudDataCache).forEach(fileName => {
                        allFlashcardData[fileName] = cloudDataCache[fileName];
                    });
                }

                // Then, collect from localStorage (for files not yet in cloudDataCache)
                storedFiles.forEach(fileInfo => {
                    const fileName = fileInfo.fileName;
                    if (!allFlashcardData[fileName]) {
                        const savedData = safeStorage.getItem(`flashcards_${fileName}`);
                        if (savedData) {
                            allFlashcardData[fileName] = savedData;

                            // Rebuild fileCategories mapping if missing
                            if (!fileCategories[fileName]) {
                                // Try to detect category from fileName
                                let detectedCategory = 'Default';
                                for (let cat in categories) {
                                    if (fileName.toLowerCase().includes(cat.toLowerCase())) {
                                        detectedCategory = cat;
                                        break;
                                    }
                                }
                                fileCategories[fileName] = detectedCategory;
                                console.log(`ðŸ”§ Rebuilding mapping: ${fileName} â†’ ${detectedCategory}`);
                            }
                        }
                    }
                });

                console.log(`ðŸ“¤ Uploading ${Object.keys(allFlashcardData).length} files to cloud`);
                console.log(`ðŸ“¦ Categories: ${Object.keys(categories).length}, File mappings: ${Object.keys(fileCategories).length}`);

                // Prepare data (categories + actual flashcard data)
                const dataToSync = {
                    categories: categories,
                    fileCategories: fileCategories,
                    flashcardData: allFlashcardData,
                    progressData: progressDataCache, // Include position tracking
                    lastSync: Date.now()
                };

                // Check data size before encryption
                const dataSize = JSON.stringify(dataToSync).length;
                const dataSizeMB = (dataSize / (1024 * 1024)).toFixed(2);
                console.log(`ðŸ“Š Syncing ${Object.keys(allFlashcardData).length} files (${dataSizeMB}MB unencrypted)`);

                // Encrypt data
                const encrypted = await encryptData(dataToSync, cloudUser.password);
                const encryptedSizeMB = (encrypted.length / (1024 * 1024)).toFixed(2);
                console.log(`ðŸ” Encrypted data size: ${encryptedSizeMB}MB`);

                // Check Firebase limits (25MB with compression - safe for Blaze plan)
                if (encrypted.length > 25 * 1024 * 1024) {
                    updateSyncStatus('error', 'âŒ Too Large');
                    alert(`âš ï¸ CLOUD SYNC FAILED\n\n` +
                        `Your flashcard data (${encryptedSizeMB}MB) exceeds the 25MB limit.\n\n` +
                        `SOLUTIONS:\n` +
                        `1. Delete unused categories/files\n` +
                        `2. Split large files into smaller files\n` +
                        `3. Export important data as CSV backups\n\n` +
                        `Your data is still saved locally, but cannot sync to cloud.`);
                    throw new Error(`Data exceeds Firebase size limit (${encryptedSizeMB}MB / 25MB max)`);
                }

                // Warn if getting close to limit (20MB = 80% of 25MB)
                if (encrypted.length > 20 * 1024 * 1024) {
                    console.warn(`âš ï¸ Warning: Data size (${encryptedSizeMB}MB) is approaching 25MB limit. Consider reducing data.`);
                }

                // Upload to Firebase
                const userPath = `users-universal/${cloudUser.username}`;
                await firebaseDB.ref(userPath).set({
                    data: encrypted,
                    passwordHash: cloudUser.passwordHash,
                    lastModified: Date.now()
                });

                updateSyncStatus('synced', 'â˜ï¸ Synced');
                console.log('âœ… Data uploaded to cloud successfully');
            } catch (error) {
                console.error('âŒ Upload error:', error);
                updateSyncStatus('error', 'âŒ Sync Failed');

                // Show user-friendly error message
                if (error.message.includes('size limit')) {
                    alert('âš ï¸ Your flashcard data is too large to sync. Please contact support or reduce the number of flashcards.');
                }

                // CRITICAL: Re-throw the error so caller knows upload failed!
                // This prevents data loss by stopping the process before localStorage is cleared
                throw error;
            }
        }

        // Compress and Re-upload Data (Triggered by user)
        async function compressAndReuploadData() {
            if (!isCloudEnabled || !cloudUser || !firebaseDB) {
                alert('âš ï¸ Not logged in to cloud sync.\n\nPlease login first to use compression.');
                return;
            }

            // Show confirmation dialog
            const confirmed = confirm(
                'ðŸ—œï¸ COMPRESS & RE-UPLOAD CLOUD DATA\n\n' +
                'This will:\n' +
                'â€¢ Re-upload all your data with compression\n' +
                'â€¢ Reduce storage size by 70-75%\n' +
                'â€¢ Take a few seconds depending on data size\n\n' +
                'Your data is safe and will remain intact.\n\n' +
                'Continue?'
            );

            if (!confirmed) {
                return;
            }

            try {
                console.log('ðŸ—œï¸ Starting compression and re-upload...');

                // Show progress
                updateSyncStatus('syncing', 'ðŸ—œï¸ Compressing...');

                // Collect all flashcard data (same as uploadToCloud)
                const allFlashcardData = {};

                // Read from localStorage DIRECTLY
                const storedFiles = safeStorage.getStoredFiles();
                console.log(`ðŸ” Found ${storedFiles.length} files in localStorage`);

                // First, collect from cloudDataCache
                if (cloudDataCache) {
                    Object.keys(cloudDataCache).forEach(fileName => {
                        allFlashcardData[fileName] = cloudDataCache[fileName];
                    });
                }

                // Then, collect from localStorage
                storedFiles.forEach(fileInfo => {
                    const fileName = fileInfo.fileName;
                    if (!allFlashcardData[fileName]) {
                        const savedData = safeStorage.getItem(`flashcards_${fileName}`);
                        if (savedData) {
                            allFlashcardData[fileName] = savedData;
                        }
                    }
                });

                console.log(`ðŸ“¦ Preparing ${Object.keys(allFlashcardData).length} files for compression`);

                // Prepare data
                const dataToSync = {
                    categories: categories,
                    fileCategories: fileCategories,
                    flashcardData: allFlashcardData,
                    lastSync: Date.now()
                };

                // Calculate original size
                const originalSize = JSON.stringify(dataToSync).length;
                const originalSizeMB = (originalSize / (1024 * 1024)).toFixed(2);
                console.log(`ðŸ“Š Original size: ${originalSizeMB}MB (unencrypted)`);

                updateSyncStatus('syncing', 'ðŸ” Encrypting...');

                // Encrypt data (compression happens automatically in encryptData)
                const encrypted = await encryptData(dataToSync, cloudUser.password);
                const encryptedSizeMB = (encrypted.length / (1024 * 1024)).toFixed(2);
                console.log(`ðŸ” Encrypted + compressed size: ${encryptedSizeMB}MB`);

                // Calculate compression ratio
                const compressionRatio = ((1 - (encrypted.length / originalSize)) * 100).toFixed(1);
                console.log(`ðŸ—œï¸ Total compression: ${compressionRatio}% reduction`);

                // Check Firebase limits
                if (encrypted.length > 25 * 1024 * 1024) {
                    updateSyncStatus('error', 'âŒ Too Large');
                    alert(`âš ï¸ Data still too large after compression!\n\n` +
                        `Size: ${encryptedSizeMB}MB (limit: 25MB)\n\n` +
                        `Please reduce your data by deleting unused categories.`);
                    return;
                }

                updateSyncStatus('syncing', 'â˜ï¸ Uploading...');

                // Upload to Firebase
                const userPath = `users-universal/${cloudUser.username}`;
                await firebaseDB.ref(userPath).set({
                    data: encrypted,
                    passwordHash: cloudUser.passwordHash,
                    lastModified: Date.now()
                });

                updateSyncStatus('synced', 'âœ… Compressed!');

                // Show success message
                alert(
                    'âœ… COMPRESSION COMPLETE!\n\n' +
                    `Original size: ${originalSizeMB}MB\n` +
                    `Compressed size: ${encryptedSizeMB}MB\n` +
                    `Compression ratio: ${compressionRatio}%\n\n` +
                    'Your data is now compressed in Firebase.\n' +
                    'Check Firebase Console to see the reduced storage!'
                );

                console.log('âœ… Compression and re-upload completed successfully');
            } catch (error) {
                console.error('âŒ Compression error:', error);
                updateSyncStatus('error', 'âŒ Failed');
                alert('âš ï¸ Compression failed.\n\nError: ' + (error.message || 'Unknown error'));
            }
        }

        // Save single file directly to cloud (Cloud-First Mode)
        // This bypasses localStorage quota issues by storing data primarily in cloud
        async function saveToCloudImmediate(fileName, data) {
            if (!isCloudEnabled || !cloudUser || !firebaseDB) {
                console.warn('âš ï¸ Cloud save skipped: not logged in. Falling back to localStorage.');
                return false;
            }

            try {
                console.log(`â˜ï¸ Cloud-first: Saving ${fileName} directly to cloud...`);
                console.log(`ðŸ“Š Memory cache status: ${Object.keys(cloudDataCache).length} files cached`);
                console.log(`ðŸ“Š fileCategories: ${Object.keys(fileCategories).length} files registered`);

                // CRITICAL: If cloudDataCache is empty (e.g., after page refresh), download from cloud first
                if (Object.keys(cloudDataCache).length === 0 && Object.keys(fileCategories).length > 0) {
                    console.log('âš ï¸ Memory cache is empty but files exist. Downloading from cloud first...');
                    try {
                        await downloadFromCloud();
                        console.log(`âœ… Cache repopulated: ${Object.keys(cloudDataCache).length} files loaded`);
                    } catch (downloadError) {
                        console.warn('âš ï¸ Could not download from cloud to repopulate cache:', downloadError);
                        // Continue anyway - will upload what we have
                    }
                }

                // Collect all flashcard data including the one we're saving
                const allFlashcardData = {};
                const skippedFiles = [];

                Object.keys(fileCategories).forEach(fn => {
                    if (fn === fileName) {
                        // Use the new data we're saving
                        allFlashcardData[fn] = data;
                    } else {
                        // Try to get existing data from multiple sources
                        let foundData = null;

                        // 1. Check memory cache first (cloud-first mode)
                        if (cloudDataCache[fn]) {
                            foundData = cloudDataCache[fn];
                            console.log(`   ðŸ“¦ Found ${fn} in memory cache`);
                        }

                        // 2. Fall back to localStorage if not in cache
                        if (!foundData) {
                            try {
                                const savedData = safeStorage.getItem(`flashcards_${fn}`);
                                if (savedData) {
                                    foundData = savedData;
                                    console.log(`   ðŸ’¾ Found ${fn} in localStorage`);
                                }
                            } catch (e) {
                                console.warn(`âš ï¸ Could not read ${fn} from localStorage:`, e);
                            }
                        }

                        // 3. Add to upload or skip
                        if (foundData) {
                            allFlashcardData[fn] = foundData;
                        } else {
                            // File not found in memory or localStorage - skip it
                            console.warn(`âš ï¸ ${fn} not found in memory or localStorage, skipping...`);
                            skippedFiles.push(fn);
                        }
                    }
                });

                if (skippedFiles.length > 0) {
                    console.warn(`âš ï¸ Skipped ${skippedFiles.length} corrupted file(s) from localStorage:`, skippedFiles);
                    console.warn('   These files will not be included in this cloud save.');
                    console.warn('   They may have been corrupted due to previous quota errors.');
                }

                // Prepare data package
                const dataToSync = {
                    categories: categories,
                    fileCategories: fileCategories,
                    flashcardData: allFlashcardData,
                    progressData: progressDataCache, // Include position tracking
                    lastSync: Date.now()
                };

                // Encrypt data
                const encrypted = await encryptData(dataToSync, cloudUser.password);
                const encryptedSizeMB = (encrypted.length / (1024 * 1024)).toFixed(2);

                // Check Firebase limits (25MB with compression - safe for Blaze plan)
                if (encrypted.length > 25 * 1024 * 1024) {
                    console.error(`âŒ Cloud data too large: ${encryptedSizeMB}MB (max 25MB)`);
                    alert(`âš ï¸ CLOUD SAVE FAILED\n\n` +
                        `Your flashcard data (${encryptedSizeMB}MB) exceeds the 25MB limit.\n\n` +
                        `SOLUTIONS:\n` +
                        `1. Delete unused categories/files\n` +
                        `2. Split large files into smaller files\n` +
                        `3. Export important data as CSV backups\n\n` +
                        `Temporarily saving to local storage as fallback.`);
                    return false;
                }

                // Upload to Firebase
                const userPath = `users-universal/${cloudUser.username}`;
                await firebaseDB.ref(userPath).set({
                    data: encrypted,
                    passwordHash: cloudUser.passwordHash,
                    lastModified: Date.now()
                });

                updateSyncStatus('synced', 'â˜ï¸ Synced');
                console.log(`âœ… ${fileName} saved to cloud (${encryptedSizeMB}MB encrypted)`);
                return true;
            } catch (error) {
                console.error('âŒ Cloud save error:', error);
                updateSyncStatus('error', 'âŒ Cloud Error');
                return false;
            }
        }

        // Download from Cloud
        async function downloadFromCloud() {
            if (!isCloudEnabled || !cloudUser || !firebaseDB) {
                console.log('âš ï¸ Download skipped: cloud not enabled or not logged in');
                return;
            }

            try {
                updateSyncStatus('syncing', 'Downloading...');

                const userPath = `users-universal/${cloudUser.username}`;
                console.log(`ðŸ” Fetching data for user: ${cloudUser.username}`);

                const snapshot = await firebaseDB.ref(userPath).once('value');
                const cloudData = snapshot.val();

                if (!cloudData) {
                    console.log('ðŸ“­ No cloud data found for this user');
                    updateSyncStatus('synced', 'â˜ï¸ No Data');
                    return;
                }

                console.log(`ðŸ“¦ Cloud data received, size: ${JSON.stringify(cloudData).length} bytes`);
                console.log(`ðŸ” Encrypted data length: ${cloudData.data ? cloudData.data.length : 0} bytes`);

                // Verify password
                if (cloudData.passwordHash !== cloudUser.passwordHash) {
                    throw new Error('Invalid password');
                }

                // Decrypt data
                console.log('ðŸ”“ Decrypting data...');
                const decrypted = await decryptData(cloudData.data, cloudUser.password);
                console.log('âœ… Decryption successful');
                console.log(`ðŸ“Š Decrypted data structure:`, {
                    hasCategories: !!decrypted.categories,
                    categoriesCount: decrypted.categories ? Object.keys(decrypted.categories).length : 0,
                    hasFileCategories: !!decrypted.fileCategories,
                    fileCategoriesCount: decrypted.fileCategories ? Object.keys(decrypted.fileCategories).length : 0,
                    hasFlashcardData: !!decrypted.flashcardData,
                    flashcardDataCount: decrypted.flashcardData ? Object.keys(decrypted.flashcardData).length : 0
                });

                // Update local data
                categories = decrypted.categories || {};
                fileCategories = decrypted.fileCategories || {};
                progressDataCache = decrypted.progressData || {}; // Restore progress positions from cloud
                console.log(`ðŸ“‚ Restored ${Object.keys(progressDataCache).length} progress entries from Firebase`);

                // Restore flashcard data
                const flashcardData = decrypted.flashcardData || {};

                // Note: Empty flashcardData on download is normal during initial sync or after cleanup
                // Data gets populated when files are uploaded

                // CLOUD-FIRST MODE: Don't save to localStorage, keep data in cloud only
                if (isCloudFirstMode) {
                    console.log('%câ˜ï¸ CLOUD-FIRST: Skipping localStorage save', 'background: #2196F3; color: white; padding: 2px 6px; border-radius: 3px');
                    console.log(`ðŸ“¥ Loaded ${Object.keys(flashcardData).length} files from cloud (kept in memory only)`);

                    // Store in memory cache for cloud-first mode
                    cloudDataCache = flashcardData;
                    console.log(`ðŸ’¾ Cached ${Object.keys(cloudDataCache).length} files in memory`);

                    // Only save metadata (categories) to localStorage - very small
                    try {
                        safeStorage.setItem('flashcard_categories', JSON.stringify(categories));
                        safeStorage.setItem('flashcard_file_categories', JSON.stringify(fileCategories));
                        console.log('âœ… Saved category metadata to localStorage');
                    } catch (metaError) {
                        console.warn('âš ï¸ Could not save metadata to localStorage (not critical)');
                    }
                } else {
                    // NORMAL MODE: Save everything to localStorage
                    console.log('ðŸ’¾ Saving files to localStorage...');
                    Object.keys(flashcardData).forEach(fileName => {
                        const data = flashcardData[fileName];
                        console.log(`  ðŸ’¾ Restoring ${fileName}: ${data ? data.length : 0} bytes`);
                        safeStorage.setItem(`flashcards_${fileName}`, data);
                    });

                    // Save to local storage
                    safeStorage.setItem('flashcard_categories', JSON.stringify(categories));
                    safeStorage.setItem('flashcard_file_categories', JSON.stringify(fileCategories));
                }

                console.log('âœ… Data downloaded from cloud');
                console.log(`ðŸ“¥ Restored ${Object.keys(flashcardData).length} files from cloud`);

                if (Object.keys(flashcardData).length > 0) {
                    updateSyncStatus('synced', 'â˜ï¸ Synced');
                } else {
                    updateSyncStatus('synced', 'â˜ï¸ No Files');
                }
            } catch (error) {
                console.error('âŒ Download error:', error);
                console.error('Error stack:', error.stack);
                updateSyncStatus('error', 'âŒ Sync Failed');

                if (error.message === 'Invalid password') {
                    alert('âŒ Invalid password');
                    cloudUser = null;
                    isCloudEnabled = false;
                    document.getElementById('loginOverlay').style.display = 'flex';
                } else {
                    alert(`âŒ Download failed: ${error.message}`);
                }
            }
        }

        // Update sync status indicator
        function updateSyncStatus(status, text) {
            const statusEl = document.getElementById('syncStatus');
            const textEl = document.getElementById('syncStatusText');

            statusEl.className = 'sync-status ' + status;
            textEl.textContent = text;
            statusEl.style.display = 'block';

            // Hide after 3 seconds if synced
            if (status === 'synced') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }
        }

        // Check if user is already logged in
        function checkExistingLogin() {
            const savedUser = safeStorage.getItem('cloud_user');
            if (savedUser) {
                // Show login modal to re-enter password
                // (We don't store password locally for security)
                document.getElementById('loginOverlay').style.display = 'flex';
                const userData = JSON.parse(savedUser);
                document.getElementById('username').value = userData.username;
            } else {
                document.getElementById('loginOverlay').style.display = 'flex';
            }
        }

        // ===== END CLOUD SYNC FUNCTIONS =====

        // Category Browser Functions
        // Global variables for pagination and view
        let currentPage = 1;
        let categoriesPerPage = 3;
        let allCategoryData = {};
        let filteredCategoryData = {};
        let currentViewMode = 'list'; // 'list' or 'grouped'

        // Toggle management panel visibility
        function toggleManagementPanel() {
            const panel = document.getElementById('managementPanel');
            const overlay = document.getElementById('managementPanelOverlay');
            const hamburgerBtn = document.getElementById('hamburgerMenuBtn');

            if (panel.classList.contains('open')) {
                // Close
                panel.classList.remove('open');
                overlay.classList.remove('open');
                hamburgerBtn.style.transform = 'scale(1)';
            } else {
                // Open
                panel.classList.add('open');
                overlay.classList.add('open');
                hamburgerBtn.style.transform = 'scale(1.1)';
            }
        }

        // Toggle subsection visibility (expand/collapse within main sections)
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const toggleBtn = document.getElementById(sectionId.replace('Section', 'Toggle'));

            if (!section) {
                console.error('Section not found:', sectionId);
                return;
            }

            if (section.style.display === 'none' || section.style.display === '') {
                // Show
                section.style.display = 'block';
                if (toggleBtn) toggleBtn.textContent = 'â–² Hide';
            } else {
                // Hide
                section.style.display = 'none';
                if (toggleBtn) toggleBtn.textContent = 'â–¼ Show';
            }
        }

        // Toggle main section visibility (from sidebar buttons)
        function toggleMainSection(sectionName) {
            let sectionId;

            // Map button names to section IDs
            switch(sectionName) {
                case 'categorySuggestion':
                    sectionId = 'suggestedCategorySection';
                    break;
                case 'manageCategories':
                    sectionId = 'mainManageCategories';
                    break;
                case 'fileManager':
                    sectionId = 'mainFileManager';
                    break;
                case 'categoryBrowser':
                    sectionId = 'categoryBrowser';
                    break;
                case 'settingsMenu':
                    sectionId = 'settingsMenu';
                    break;
                case 'uploadSection':
                    sectionId = 'uploadSection';
                    break;
                default:
                    console.error('Unknown section:', sectionName);
                    return;
            }

            const section = document.getElementById(sectionId);
            if (!section) {
                console.error('Section not found:', sectionId);
                return;
            }

            // Toggle visibility
            // For Category Browser, Settings Menu, and Upload Section, check actual visibility since they don't have inline display style by default
            const isHidden = (sectionName === 'categoryBrowser' || sectionName === 'settingsMenu' || sectionName === 'uploadSection')
                ? (section.style.display === 'none')
                : (section.style.display === 'none' || section.style.display === '');

            if (isHidden) {
                // Show section
                // File Manager is a modal, so use flex display
                if (sectionName === 'fileManager') {
                    section.style.display = 'flex';
                    refreshFileTree();
                } else {
                    section.style.display = 'block';
                }

                // Special initialization for Category Suggestion
                if (sectionName === 'categorySuggestion') {
                    testAutoOpen();
                }

                // For Settings Menu, also show the toggle button
                if (sectionName === 'settingsMenu') {
                    const settingsBtn = document.getElementById('settingsToggleBtn');
                    if (settingsBtn) {
                        settingsBtn.style.display = 'flex';
                    }
                }

                // Close sidebar after selection
                toggleManagementPanel();
            } else {
                // Hide section
                section.style.display = 'none';

                // For Settings Menu, also hide the toggle button
                if (sectionName === 'settingsMenu') {
                    const settingsBtn = document.getElementById('settingsToggleBtn');
                    if (settingsBtn) {
                        settingsBtn.style.display = 'none';
                    }
                }

                // Close sidebar when hiding (for consistency)
                toggleManagementPanel();
            }
        }

        // ===== REMAP LOADED FLASHCARDS =====
        // Open existing column mapper modal with currently loaded flashcards
        function remapLoadedFlashcards() {
            console.log('ðŸŽ¯ Remapping loaded flashcards...');

            // Check if flashcards are loaded
            if (!flashcards || flashcards.length === 0) {
                alert('âš ï¸ No flashcards loaded!\n\nPlease load some flashcards first before remapping columns.');
                return;
            }

            // Convert flashcards array back to CSV-like format for the mapper
            const firstCard = flashcards[0];
            const columns = Object.keys(firstCard).filter(key => key !== 'learned'); // Exclude learned status

            // Create header row
            const headerRow = columns.join(',');

            // Create data rows
            const dataRows = flashcards.map(card => {
                return columns.map(col => card[col] || '').join(',');
            });

            // Combine into lines array
            const lines = [headerRow, ...dataRows];

            console.log(`ðŸ“‹ Prepared ${lines.length} lines for remapping`);
            console.log(`ðŸ“‹ Columns: ${columns.join(', ')}`);

            // Close hamburger menu
            toggleManagementPanel();

            // Open the existing column mapper modal
            showColumnMapperModal(lines, ',');
        }

        // Toggle category browser visibility
        function toggleCategoryBrowser() {
            const content = document.getElementById('categoryBrowserContent');
            const toggleBtn = document.getElementById('categoryBrowserToggle');

            if (content.style.maxHeight === '0px' || content.style.maxHeight === '0') {
                // Show
                content.style.maxHeight = '2000px';
                toggleBtn.textContent = 'â–¼ Hide';
                toggleBtn.style.background = '#667eea';
            } else {
                // Hide
                content.style.maxHeight = '0px';
                toggleBtn.textContent = 'â–¶ Show';
                toggleBtn.style.background = '#999';
            }
        }

        // Pagination functions
        function nextPage() {
            const totalPages = Math.ceil(Object.keys(filteredCategoryData).length / categoriesPerPage);
            if (currentPage < totalPages) {
                currentPage++;
                renderCategoryBrowser();
            }
        }

        function previousPage() {
            if (currentPage > 1) {
                currentPage--;
                renderCategoryBrowser();
            }
        }

        // Filter categories by search term
        function filterCategories() {
            const searchTerm = document.getElementById('categorySearchBox').value.toLowerCase().trim();

            if (!searchTerm) {
                filteredCategoryData = {...allCategoryData};
            } else {
                filteredCategoryData = {};
                Object.keys(allCategoryData).forEach(category => {
                    if (category.toLowerCase().includes(searchTerm)) {
                        filteredCategoryData[category] = allCategoryData[category];
                    }
                });
            }

            currentPage = 1; // Reset to first page when filtering
            renderCategoryBrowser();
        }

        // Expand all categories
        function expandAllCategories() {
            const allCollapseBtns = document.querySelectorAll('.category-collapse-btn');
            allCollapseBtns.forEach(btn => {
                const categoryId = btn.id.replace('_btn', '');
                const subcatContainer = document.getElementById(categoryId);

                if (subcatContainer && subcatContainer.style.maxHeight === '0px') {
                    subcatContainer.style.maxHeight = '2000px';
                    subcatContainer.style.opacity = '1';
                    subcatContainer.style.marginTop = '10px';
                    subcatContainer.style.paddingTop = '10px';
                    subcatContainer.style.borderTop = '1px solid #e0e0e0';
                    btn.textContent = 'â–¼';
                    btn.style.transform = 'rotate(0deg)';
                }
            });
        }

        // Collapse all categories
        function collapseAllCategories() {
            const allCollapseBtns = document.querySelectorAll('.category-collapse-btn');
            allCollapseBtns.forEach(btn => {
                const categoryId = btn.id.replace('_btn', '');
                const subcatContainer = document.getElementById(categoryId);

                if (subcatContainer && subcatContainer.style.maxHeight !== '0px') {
                    subcatContainer.style.maxHeight = '0px';
                    subcatContainer.style.opacity = '0';
                    subcatContainer.style.marginTop = '0px';
                    subcatContainer.style.paddingTop = '0px';
                    subcatContainer.style.borderTop = 'none';
                    btn.textContent = 'â–¶';
                    btn.style.transform = 'rotate(-90deg)';
                }
            });
        }

        // Toggle between list and grouped view
        function toggleViewMode() {
            const toggleBtn = document.getElementById('viewModeToggle');

            if (currentViewMode === 'list') {
                currentViewMode = 'grouped';
                toggleBtn.textContent = 'ðŸ“‹ List View';
                toggleBtn.style.background = '#10b981';
            } else {
                currentViewMode = 'list';
                toggleBtn.textContent = 'ðŸ—‚ï¸ Grouped View';
                toggleBtn.style.background = '#764ba2';
            }

            renderCategoryBrowser();
        }

        // Group categories by language/type
        function groupCategoriesByLanguage(categories) {
            const groups = {};

            Object.keys(categories).forEach(categoryName => {
                let group, groupIcon;

                // FIRST: Check if custom group mapping exists
                if (categoryGroups[categoryName]) {
                    group = categoryGroups[categoryName];
                    // Determine icon based on group name
                    groupIcon = getGroupIcon(group);
                } else {
                    // SECOND: Auto-detect from category name (fallback)
                    group = 'Other';
                    groupIcon = 'ðŸ“š';

                    if (categoryName.toLowerCase().includes('german') || categoryName.toLowerCase().includes('deutsch')) {
                        group = 'German Learning';
                        groupIcon = 'ðŸ‡©ðŸ‡ª';
                    } else if (categoryName.toLowerCase().includes('american') || categoryName.toLowerCase().includes('english') || categoryName.toLowerCase().includes('oxford')) {
                        group = 'English Learning';
                        groupIcon = 'ðŸ‡ºðŸ‡¸';
                    } else if (categoryName.toLowerCase().includes('farsi') || categoryName.toLowerCase().includes('persian')) {
                        group = 'Persian/Farsi Learning';
                        groupIcon = 'ðŸ‡®ðŸ‡·';
                    } else if (categoryName.toLowerCase().includes('spanish') || categoryName.toLowerCase().includes('espaÃ±ol')) {
                        group = 'Spanish Learning';
                        groupIcon = 'ðŸ‡ªðŸ‡¸';
                    } else if (categoryName.toLowerCase().includes('french') || categoryName.toLowerCase().includes('franÃ§ais')) {
                        group = 'French Learning';
                        groupIcon = 'ðŸ‡«ðŸ‡·';
                    } else if (categoryName.toLowerCase().includes('italian') || categoryName.toLowerCase().includes('italiano')) {
                        group = 'Italian Learning';
                        groupIcon = 'ðŸ‡®ðŸ‡¹';
                    } else if (categoryName.toLowerCase().includes('chinese') || categoryName.toLowerCase().includes('ä¸­æ–‡')) {
                        group = 'Chinese Learning';
                        groupIcon = 'ðŸ‡¨ðŸ‡³';
                    } else if (categoryName.toLowerCase().includes('japanese') || categoryName.toLowerCase().includes('æ—¥æœ¬èªž')) {
                        group = 'Japanese Learning';
                        groupIcon = 'ðŸ‡¯ðŸ‡µ';
                    } else if (categoryName.toLowerCase().includes('korean') || categoryName.toLowerCase().includes('í•œêµ­ì–´')) {
                        group = 'Korean Learning';
                        groupIcon = 'ðŸ‡°ðŸ‡·';
                    } else if (categoryName.toLowerCase().includes('arabic') || categoryName.toLowerCase().includes('Ø¹Ø±Ø¨ÙŠ')) {
                        group = 'Arabic Learning';
                        groupIcon = 'ðŸ‡¸ðŸ‡¦';
                    }
                }

                if (!groups[group]) {
                    groups[group] = {
                        icon: groupIcon,
                        categories: []
                    };
                }

                groups[group].categories.push(categoryName);
            });

            return groups;
        }

        // Get icon for group name
        function getGroupIcon(groupName) {
            const lower = groupName.toLowerCase();
            if (lower.includes('german') || lower.includes('deutsch')) return 'ðŸ‡©ðŸ‡ª';
            if (lower.includes('english') || lower.includes('american')) return 'ðŸ‡ºðŸ‡¸';
            if (lower.includes('farsi') || lower.includes('persian')) return 'ðŸ‡®ðŸ‡·';
            if (lower.includes('spanish') || lower.includes('espaÃ±ol')) return 'ðŸ‡ªðŸ‡¸';
            if (lower.includes('french') || lower.includes('franÃ§ais')) return 'ðŸ‡«ðŸ‡·';
            if (lower.includes('italian') || lower.includes('italiano')) return 'ðŸ‡®ðŸ‡¹';
            if (lower.includes('chinese') || lower.includes('ä¸­æ–‡')) return 'ðŸ‡¨ðŸ‡³';
            if (lower.includes('japanese') || lower.includes('æ—¥æœ¬èªž')) return 'ðŸ‡¯ðŸ‡µ';
            if (lower.includes('korean') || lower.includes('í•œêµ­ì–´')) return 'ðŸ‡°ðŸ‡·';
            if (lower.includes('arabic') || lower.includes('Ø¹Ø±Ø¨ÙŠ')) return 'ðŸ‡¸ðŸ‡¦';
            return 'ðŸ“š'; // Default icon
        }

        // Get icon for category name
        function getCategoryIcon(categoryName) {
            const lower = categoryName.toLowerCase();
            // Check for combinations first
            if (lower.includes('german') && lower.includes('farsi')) return 'ðŸ‡©ðŸ‡ªðŸ‡®ðŸ‡·';
            if (lower.includes('german') && lower.includes('english')) return 'ðŸ‡©ðŸ‡ªðŸ‡¬ðŸ‡§';
            if (lower.includes('english') && lower.includes('farsi')) return 'ðŸ‡¬ðŸ‡§ðŸ‡®ðŸ‡·';
            // Then check individual languages
            if (lower.includes('german') || lower.includes('deutsch')) return 'ðŸ‡©ðŸ‡ª';
            if (lower.includes('english') || lower.includes('american')) return 'ðŸ‡¬ðŸ‡§';
            if (lower.includes('farsi') || lower.includes('persian')) return 'ðŸ‡®ðŸ‡·';
            if (lower.includes('spanish') || lower.includes('espaÃ±ol')) return 'ðŸ‡ªðŸ‡¸';
            if (lower.includes('french') || lower.includes('franÃ§ais')) return 'ðŸ‡«ðŸ‡·';
            if (lower.includes('italian') || lower.includes('italiano')) return 'ðŸ‡®ðŸ‡¹';
            if (lower.includes('chinese') || lower.includes('ä¸­æ–‡')) return 'ðŸ‡¨ðŸ‡³';
            if (lower.includes('japanese') || lower.includes('æ—¥æœ¬èªž')) return 'ðŸ‡¯ðŸ‡µ';
            if (lower.includes('korean') || lower.includes('í•œêµ­ì–´')) return 'ðŸ‡°ðŸ‡·';
            if (lower.includes('arabic') || lower.includes('Ø¹Ø±Ø¨ÙŠ')) return 'ðŸ‡¸ðŸ‡¦';
            // Default category
            if (lower.includes('default')) return 'ðŸ“š';
            return 'ðŸ“'; // Generic folder icon
        }

        function renderCategoryBrowser() {
            console.log('ðŸ”„ renderCategoryBrowser() called at:', new Date().toLocaleTimeString());

            const browserList = document.getElementById('categoryBrowserList');
            const noMessage = document.getElementById('noCategoriesMessage');

            // Get all files organized by category
            const categoryFiles = {};

            // FIRST: Initialize ALL defined categories (even if empty)
            console.log('  âœ… Step 1: Initializing ALL categories from storage...');
            Object.keys(categories).forEach(cat => {
                categoryFiles[cat] = { '_root': [] };
                // Also initialize defined subcategories
                if (categories[cat] && Array.isArray(categories[cat])) {
                    categories[cat].forEach(subcat => {
                        categoryFiles[cat][subcat] = [];
                    });
                }
            });

            // SECOND: Populate with actual files
            console.log('  âœ… Step 2: Populating with file mappings...');
            Object.keys(fileCategories).forEach(fileName => {
                const cat = fileCategories[fileName].category || 'Default';
                const subcat = fileCategories[fileName].subcategory || '';

                console.log(`    ðŸ“„ File: ${fileName} -> Category: ${cat}, Subcategory: "${subcat}"`);

                // Ensure category exists
                if (!categoryFiles[cat]) {
                    categoryFiles[cat] = { '_root': [] };
                }

                if (subcat) {
                    if (!categoryFiles[cat][subcat]) {
                        categoryFiles[cat][subcat] = [];
                    }
                    categoryFiles[cat][subcat].push(fileName);
                    console.log(`      âœ… Added to ${cat} > ${subcat}`);
                } else {
                    if (!categoryFiles[cat]['_root']) {
                        categoryFiles[cat]['_root'] = [];
                    }
                    categoryFiles[cat]['_root'].push(fileName);
                    console.log(`      âœ… Added to ${cat} > _root`);
                }
            });

            // Store in global variables
            allCategoryData = categoryFiles;
            if (Object.keys(filteredCategoryData).length === 0 || document.getElementById('categorySearchBox').value === '') {
                filteredCategoryData = {...categoryFiles};
            }

            // DEBUG: Enhanced category information
            console.log('ðŸ” CATEGORY DEBUG - ENHANCED:');
            console.log('  ðŸ“ Total categories in storage (categories object):', Object.keys(categories).length);
            console.log('  ðŸ“‚ All defined categories:', Object.keys(categories));
            console.log('  ðŸ“„ Total file mappings:', Object.keys(fileCategories).length);
            console.log('  ðŸŽ¯ Categories initialized (categoryFiles object):', Object.keys(categoryFiles).length);
            console.log('  ðŸ“‹ Category names in categoryFiles:', Object.keys(categoryFiles));

            // Count files per category from categoryFiles object
            const categoryFileCount = {};
            Object.keys(categoryFiles).forEach(catName => {
                let count = 0;
                Object.keys(categoryFiles[catName]).forEach(subcatKey => {
                    count += categoryFiles[catName][subcatKey].length;
                });
                categoryFileCount[catName] = count;
            });
            console.log('  ðŸ“Š Files per category (from categoryFiles):', categoryFileCount);

            // Show which files are mapped from fileCategories
            const fileCategoryMapping = {};
            Object.keys(fileCategories).forEach(fileName => {
                const cat = fileCategories[fileName].category;
                fileCategoryMapping[cat] = (fileCategoryMapping[cat] || 0) + 1;
            });
            console.log('  ðŸ—‚ï¸ Files per category (from fileCategories):', fileCategoryMapping);
            console.log('  ðŸ’¾ Raw fileCategories object:', fileCategories);

            // Check for empty categories
            const emptyCategories = Object.keys(categoryFiles).filter(cat => categoryFileCount[cat] === 0);
            console.log('  âš ï¸ Empty categories (0 files):', emptyCategories);

            // Check if we have any categories with files
            const hasCategories = Object.keys(categoryFiles).length > 0;

            if (!hasCategories) {
                browserList.innerHTML = '';
                noMessage.style.display = 'block';
                return;
            }

            noMessage.style.display = 'none';
            browserList.innerHTML = '';

            // Update category count in header
            const categoryCount = Object.keys(filteredCategoryData).length;
            const totalCategoryCount = Object.keys(allCategoryData).length;
            const categoryCountEl = document.getElementById('categoryCount');
            if (categoryCountEl) {
                categoryCountEl.textContent = `(${totalCategoryCount} ${totalCategoryCount === 1 ? 'category' : 'categories'})`;
            }

            // Pagination logic
            const paginationControls = document.getElementById('categoryPagination');
            const shouldShowPagination = totalCategoryCount > 3; // Show pagination if more than 3 categories

            if (shouldShowPagination) {
                paginationControls.style.display = 'block';

                const totalPages = Math.ceil(categoryCount / categoriesPerPage);
                const startIndex = (currentPage - 1) * categoriesPerPage;
                const endIndex = Math.min(startIndex + categoriesPerPage, categoryCount);

                // Update pagination info
                document.getElementById('paginationInfo').textContent = `Showing ${startIndex + 1}-${endIndex} of ${categoryCount}`;
                document.getElementById('pageNumbers').textContent = `Page ${currentPage} of ${totalPages}`;
                document.getElementById('prevPageBtn').disabled = currentPage === 1;
                document.getElementById('nextPageBtn').disabled = currentPage === totalPages;

                // Get categories for current page
                const categoriesToShow = Object.keys(filteredCategoryData).sort().slice(startIndex, endIndex);

                // Render based on current view mode
                if (currentViewMode === 'grouped') {
                    renderGroupedView(filteredCategoryData, false);
                } else {
                    renderListView(categoriesToShow, filteredCategoryData, false);
                }
            } else {
                paginationControls.style.display = 'none';
                currentPage = 1; // Reset pagination

                // Get all categories (no pagination)
                const categoriesToShow = Object.keys(filteredCategoryData).sort();

                // Render based on current view mode
                if (currentViewMode === 'grouped') {
                    renderGroupedView(filteredCategoryData, false);
                } else {
                    renderListView(categoriesToShow, filteredCategoryData, false);
                }
            }
        }

        // Render List View (SIMPLE TABLE DESIGN)
        function renderListView(categoriesToShow, categoryData, shouldAutoCollapse) {
            const browserList = document.getElementById('categoryBrowserList');
            browserList.innerHTML = ''; // Clear existing content

            // Render each category as a table row
            categoriesToShow.forEach(category => {
                // Count total files and cards in this category
                let fileCount = 0;
                let totalCards = 0;
                Object.keys(categoryData[category]).forEach(subcat => {
                    fileCount += categoryData[category][subcat].length;
                    // Count cards
                    categoryData[category][subcat].forEach(fileName => {
                        // Check memory cache first (cloud-first mode), then localStorage
                        let savedData = null;

                        if (cloudDataCache[fileName]) {
                            savedData = cloudDataCache[fileName];
                        } else {
                            savedData = safeStorage.getItem(`flashcards_${fileName}`);
                        }

                        if (savedData) {
                            try {
                                const cardData = JSON.parse(savedData);
                                totalCards += cardData.length;
                            } catch (e) {}
                        }
                    });
                });

                // Get category icon
                const categoryIcon = getCategoryIcon(category);
                const isEmpty = fileCount === 0;

                // Get subcategories
                const subcats = Object.keys(categoryData[category]).filter(s => s !== '_root').sort();
                const hasSubcats = subcats.length > 0;

                // Skip completely empty categories (has subcategories defined but 0 files)
                if (isEmpty && hasSubcats) {
                    console.log(`â­ï¸ Skipping empty category with placeholder subcategories: ${category}`);
                    return;
                }

                // Create main category row
                const row = document.createElement('tr');
                row.style.cssText = `
                    border-bottom: 2px solid #e5e7eb;
                    ${isEmpty ? 'opacity: 0.5; background: #f9fafb;' : 'background: white;'}
                `;

                row.innerHTML = `
                    <td style="padding: 16px; width: 60px; text-align: center; font-size: 2em;">
                        ${categoryIcon}
                    </td>
                    <td style="padding: 16px;">
                        <div style="font-weight: 700; font-size: 1.1em; color: #667eea; margin-bottom: 4px;">
                            ${category}
                        </div>
                        <div style="font-size: 0.9em; color: #6b7280;">
                            ${!isEmpty ? `ðŸ“„ ${fileCount} files â€¢ ðŸƒ ${totalCards.toLocaleString()} cards` : hasSubcats ? `ðŸ“‚ ${subcats.length} groups` : 'ðŸ“­ No files'}
                            ${!isEmpty && hasSubcats ? ` â€¢ ðŸ“‚ ${subcats.length} groups` : ''}
                        </div>
                    </td>
                    <td style="padding: 16px; text-align: right; width: 200px;">
                        ${hasSubcats ? `
                            <button onclick="toggleCategoryGroups('${category.replace(/'/g, "\\'")}')" id="toggle_${category.replace(/[^a-zA-Z0-9]/g, '_')}" style="
                                padding: 10px 20px;
                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                color: white;
                                border: none;
                                border-radius: 8px;
                                cursor: pointer;
                                font-weight: 600;
                                font-size: 0.95em;
                                transition: all 0.2s;
                            " onmouseenter="this.style.transform='scale(1.05)'" onmouseleave="this.style.transform='scale(1)'">
                                â–¼ Show ${subcats.length}
                            </button>
                        ` : !isEmpty ? `
                            <button onclick="loadCategoryVocabulary('${category.replace(/'/g, "\\'")}')" style="
                                padding: 10px 20px;
                                background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                                color: white;
                                border: none;
                                border-radius: 8px;
                                cursor: pointer;
                                font-weight: 600;
                                font-size: 0.95em;
                                transition: all 0.2s;
                            " onmouseenter="this.style.transform='scale(1.05)'" onmouseleave="this.style.transform='scale(1)'">
                                â–¶ï¸ Practice
                            </button>
                        ` : '<span style="color: #9ca3af; font-size: 0.9em;">Empty</span>'}
                    </td>
                `;

                browserList.appendChild(row);

                // Create subcategories row (hidden by default)
                if (hasSubcats) {
                    console.log(`ðŸ“‚ Rendering subcategories for ${category}:`, subcats);

                    const subcatRow = document.createElement('tr');
                    subcatRow.id = `subcat_${category.replace(/[^a-zA-Z0-9]/g, '_')}`;
                    subcatRow.style.cssText = 'display: none; background: #f8f9fa;';

                    const subcatCell = document.createElement('td');
                    subcatCell.colSpan = 3;
                    subcatCell.style.padding = '0px 16px 16px 76px';

                    subcats.forEach(subcat => {
                        console.log(`  - Processing subcat: ${subcat}`);
                        console.log(`    Files in this subcat:`, categoryData[category][subcat]);

                        // Count cards in this subcategory
                        let subcatCards = 0;
                        const fileList = categoryData[category][subcat] || [];
                        console.log(`    File list length: ${fileList.length}`);

                        fileList.forEach(fileName => {
                            console.log(`    Checking file: ${fileName}`);
                            // Check memory cache first (cloud-first mode), then localStorage
                            const savedData = cloudDataCache[fileName] || safeStorage.getItem(`flashcards_${fileName}`);
                            if (savedData) {
                                try {
                                    const cardData = JSON.parse(savedData);
                                    subcatCards += cardData.length;
                                    console.log(`      Found ${cardData.length} cards`);
                                } catch (e) {
                                    console.log(`      Error parsing: ${e}`);
                                }
                            } else {
                                console.log(`      No saved data found for ${fileName}`);
                            }
                        });

                        const subcatDiv = document.createElement('div');
                        subcatDiv.style.cssText = `
                            display: flex;
                            align-items: center;
                            justify-content: space-between;
                            padding: 12px;
                            margin: 8px 0;
                            background: white;
                            border: 1px solid #e5e7eb;
                            border-radius: 8px;
                            transition: all 0.2s;
                        `;

                        subcatDiv.onmouseenter = function() {
                            this.style.background = '#eff6ff';
                            this.style.borderColor = '#667eea';
                            this.style.transform = 'translateX(4px)';
                        };
                        subcatDiv.onmouseleave = function() {
                            this.style.background = 'white';
                            this.style.borderColor = '#e5e7eb';
                            this.style.transform = 'translateX(0)';
                        };

                        const fileCount = fileList.length;
                        console.log(`    Final count: ${fileCount} files, ${subcatCards} cards`);

                        // Skip empty subcategories (no files/cards)
                        if (fileCount === 0) {
                            console.log(`    â­ï¸ Skipping empty subcategory: ${subcat}`);
                            return; // Skip this iteration in forEach
                        }

                        subcatDiv.innerHTML = `
                            <div>
                                <div style="font-weight: 600; color: #374151;">ðŸ“„ ${subcat}</div>
                                <div style="font-size: 0.85em; color: #9ca3af; margin-top: 2px;">
                                    ${fileCount} files â€¢ ${subcatCards.toLocaleString()} cards
                                </div>
                            </div>
                            <button onclick="loadSubcategoryVocabulary('${category.replace(/'/g, "\\'")}', '${subcat.replace(/'/g, "\\'")}')" style="
                                padding: 8px 16px;
                                background: #667eea;
                                color: white;
                                border: none;
                                border-radius: 6px;
                                cursor: pointer;
                                font-weight: 600;
                                font-size: 0.9em;
                                transition: all 0.2s;
                            " onmouseenter="this.style.background='#5568d3'" onmouseleave="this.style.background='#667eea'">
                                â–¶ï¸ Practice
                            </button>
                        `;

                        subcatCell.appendChild(subcatDiv);
                    });

                    subcatRow.appendChild(subcatCell);
                    browserList.appendChild(subcatRow);
                }
            });
        }

        // Toggle category groups visibility
        function toggleCategoryGroups(category) {
            const safeCategoryId = category.replace(/[^a-zA-Z0-9]/g, '_');
            const subcatRow = document.getElementById(`subcat_${safeCategoryId}`);
            const toggleBtn = document.getElementById(`toggle_${safeCategoryId}`);

            if (subcatRow && toggleBtn) {
                if (subcatRow.style.display === 'none') {
                    // Show groups
                    subcatRow.style.display = 'table-row';
                    toggleBtn.innerHTML = 'â–² Hide';
                } else {
                    // Hide groups
                    subcatRow.style.display = 'none';
                    const subcats = Object.keys(filteredCategoryData[category]).filter(s => s !== '_root').length;
                    toggleBtn.innerHTML = `â–¼ Show ${subcats}`;
                }
            }
        }

        // Render Grouped View (by language)
        function renderGroupedView(categoryData, shouldAutoCollapse) {
            const browserList = document.getElementById('categoryBrowserList');

            // Group categories by language
            const languageGroups = groupCategoriesByLanguage(categoryData);

            // Render each language group
            Object.keys(languageGroups).sort().forEach(groupName => {
                const group = languageGroups[groupName];
                const groupId = `group_${groupName.replace(/[^a-zA-Z0-9]/g, '_')}`;

                // Create group container
                const groupContainer = document.createElement('div');
                groupContainer.style.cssText = `
                    background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
                    border: 3px solid #667eea;
                    border-radius: 15px;
                    padding: 15px;
                    margin-bottom: 15px;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                `;

                // Group header
                const groupHeader = document.createElement('div');
                groupHeader.style.cssText = 'display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px; cursor: pointer;';
                groupHeader.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 2em;">${group.icon}</span>
                        <div>
                            <div style="font-size: 1.4em; font-weight: 700; color: #667eea;">${groupName}</div>
                            <div style="font-size: 0.85em; color: #666; margin-top: 2px;">${group.categories.length} ${group.categories.length === 1 ? 'category' : 'categories'}</div>
                        </div>
                    </div>
                    <button class="group-collapse-btn" id="${groupId}_btn" style="background: transparent; border: none; font-size: 1.8em; cursor: pointer; color: #667eea; padding: 5px; transition: transform 0.3s; user-select: none;" title="Show/Hide categories">
                        â–¼
                    </button>
                `;

                groupContainer.appendChild(groupHeader);

                // Categories list within group
                const categoriesContainer = document.createElement('div');
                categoriesContainer.id = groupId;
                categoriesContainer.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 10px; margin-top: 10px; transition: all 0.3s ease-out;';

                group.categories.forEach(categoryName => {
                    if (!categoryData[categoryName]) return;

                    // Count files in category
                    let fileCount = 0;
                    Object.keys(categoryData[categoryName]).forEach(subcat => {
                        fileCount += categoryData[categoryName][subcat].length;
                    });

                    // Create file count display with visual indicator for empty categories
                    const fileCountDisplay = fileCount === 0
                        ? '<span style="color: #ff9800; font-weight: 600;">ðŸ“­ Empty</span>'
                        : `${fileCount} file${fileCount !== 1 ? 's' : ''}`;

                    // Compact category card
                    const catCard = document.createElement('div');
                    catCard.style.cssText = `
                        background: white;
                        border: 2px solid #667eea;
                        border-radius: 10px;
                        padding: 12px;
                        cursor: pointer;
                        transition: all 0.3s;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    `;

                    catCard.innerHTML = `
                        <div style="font-weight: 600; color: #667eea; font-size: 1.1em; margin-bottom: 5px;">ðŸ“ ${categoryName}</div>
                        <div style="font-size: 0.8em; color: #999;">${fileCountDisplay}</div>
                    `;

                    catCard.addEventListener('mouseenter', function() {
                        this.style.transform = 'translateY(-3px)';
                        this.style.boxShadow = '0 4px 12px rgba(102, 126, 234, 0.4)';
                    });

                    catCard.addEventListener('mouseleave', function() {
                        this.style.transform = 'translateY(0)';
                        this.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                    });

                    catCard.addEventListener('click', () => {
                        loadCategoryVocabulary(categoryName);
                    });

                    categoriesContainer.appendChild(catCard);
                });

                groupContainer.appendChild(categoriesContainer);

                // Add collapse/expand functionality for group
                const collapseBtn = groupHeader.querySelector(`#${groupId}_btn`);
                if (collapseBtn) {
                    collapseBtn.addEventListener('click', (e) => {
                        e.stopPropagation();

                        const container = document.getElementById(groupId);
                        if (container) {
                            if (container.style.maxHeight === '0px') {
                                // Expand
                                container.style.maxHeight = '2000px';
                                container.style.opacity = '1';
                                collapseBtn.textContent = 'â–¼';
                                collapseBtn.style.transform = 'rotate(0deg)';
                            } else {
                                // Collapse
                                container.style.maxHeight = '0px';
                                container.style.opacity = '0';
                                collapseBtn.textContent = 'â–¶';
                                collapseBtn.style.transform = 'rotate(-90deg)';
                            }
                        }
                    });
                }

                browserList.appendChild(groupContainer);
            });
        }

        function loadCategoryVocabulary(categoryName) {
            // Get all files in this category
            const filesInCategory = Object.keys(fileCategories).filter(fileName => {
                return fileCategories[fileName].category === categoryName;
            });

            if (filesInCategory.length === 0) {
                alert(`No files found in category "${categoryName}"`);
                return;
            }

            // Show selection dialog if multiple files
            if (filesInCategory.length > 1) {
                let message = `Select a file from "${categoryName}":\n\n`;
                filesInCategory.forEach((file, idx) => {
                    const subcat = fileCategories[file].subcategory;
                    message += `${idx + 1}. ${file}${subcat ? ' (' + subcat + ')' : ''}\n`;
                });

                const selection = prompt(message + '\nEnter file number:');
                if (selection) {
                    const index = parseInt(selection) - 1;
                    if (index >= 0 && index < filesInCategory.length) {
                        loadFileByName(filesInCategory[index]);
                    }
                }
            } else {
                // Load the single file
                loadFileByName(filesInCategory[0]);
            }
        }

        function loadSubcategoryVocabulary(categoryName, subcategoryName) {
            console.log('ðŸ“‹ Loading subcategory:', categoryName, 'â†’', subcategoryName);

            // Get all files in this specific subcategory
            const filesInSubcategory = Object.keys(fileCategories).filter(fileName => {
                return fileCategories[fileName].category === categoryName &&
                       fileCategories[fileName].subcategory === subcategoryName;
            });

            if (filesInSubcategory.length === 0) {
                alert(`No files found in subcategory "${categoryName} â†’ ${subcategoryName}"`);
                return;
            }

            // Show selection dialog if multiple files
            if (filesInSubcategory.length > 1) {
                let message = `Select a file from "${categoryName} â†’ ${subcategoryName}":\n\n`;
                filesInSubcategory.forEach((file, idx) => {
                    message += `${idx + 1}. ${file}\n`;
                });

                const selection = prompt(message + '\nEnter file number:');
                if (selection) {
                    const index = parseInt(selection) - 1;
                    if (index >= 0 && index < filesInSubcategory.length) {
                        loadFileByName(filesInSubcategory[index]);
                    }
                }
            } else {
                // Load the single file
                loadFileByName(filesInSubcategory[0]);
            }
        }

        function loadFileByName(fileName) {
            console.log(`ðŸŽ¯ Loading file for practice: ${fileName}`);

            // STEP 1: Clear old practice cache (switching files)
            if (currentFileName && currentFileName !== fileName) {
                console.log(`ðŸ§¹ Clearing old practice cache for: ${currentFileName}`);
                clearPracticeCache();
            }

            // STEP 2: Load from CLOUD ONLY (cloudDataCache), never from old localStorage files
            const savedData = cloudDataCache[fileName];

            if (!savedData) {
                console.error(`âŒ File not found in cloud: ${fileName}`);
                alert(`Vocabulary data for "${fileName}" not found in cloud.\n\nPlease ensure:\n1. You are connected to internet\n2. File was uploaded successfully\n3. Try refreshing the page`);
                return;
            }

            // STEP 3: Save to practice cache for offline resilience
            console.log(`ðŸ’¾ Caching ${fileName} for offline practice...`);
            try {
                safeStorage.setItem('practice_cache', savedData);
                safeStorage.setItem('practice_cache_filename', fileName);
                console.log(`âœ… Practice cache ready for offline mode`);
            } catch (cacheError) {
                console.warn('âš ï¸ Could not cache for offline (non-critical):', cacheError);
            }

            try {
                const cardData = JSON.parse(savedData);

                // Get the file's category mapping
                const fileCategory = fileCategories[fileName] || { category: 'Default', subcategory: '' };
                console.log(`ðŸ“‚ Loading file "${fileName}" with category:`, fileCategory);

                // Reconstruct flashcards from saved data
                flashcards = cardData.map((card, index) => {
                    // Backward compatibility: Support both old (german/english) and new (lang1/lang2) formats
                    const lang1Value = card.lang1 || card.german || '';
                    const lang1ExtendedValue = card.lang1Extended || card.germanExtended || '';
                    const lang2Value = card.lang2 || card.english || '';
                    const lang2ExtendedValue = card.lang2Extended || card.englishExtended || '';

                    return {
                    id: card.id || index,
                    lang1: lang1Value,
                    lang1Extended: lang1ExtendedValue,
                    lang2: lang2Value,
                    lang2Extended: lang2ExtendedValue,
                    detail: card.detail || '',
                    hasExtended: !!(lang1ExtendedValue || lang2ExtendedValue),
                    learned: card.learned || false,
                    reviewDate: card.reviewDate || null,
                    repetitions: card.repetitions || 0,
                    easeFactor: card.easeFactor || 2.5,
                    interval: card.interval || 1,
                    // Always use the file's category mapping, not what was saved
                    category: fileCategory.category,
                    subcategory: fileCategory.subcategory || ''
                };
                });

                console.log(`ðŸ“‚ Loaded ${flashcards.length} flashcards into memory`);

                currentFileName = fileName;
                currentIndex = 0;
                filteredCards = [...flashcards];

                // Load file category
                if (fileCategories[currentFileName]) {
                    currentFileCategory = fileCategories[currentFileName];
                }

                // Update UI
                const dueCount = flashcards.filter(isDueForReview).length;
                document.getElementById('fileInfo').innerHTML = `<strong>ðŸ“‚ ${currentFileName}</strong><br>âœ… Loaded ${flashcards.length} cards (${dueCount} due for review) from saved data`;

                updateStats();
                updateCurrentFileDisplay();

                // Load saved progress to resume from where user left off
                // Note: loadProgress() calls showFlashcard() internally via applyProgress()
                const progressLoaded = loadProgress();

                // If no saved progress, show first card
                if (!progressLoaded) {
                    showFlashcard();
                }

                // Show main UI elements
                document.getElementById('flashcardContainer').style.display = 'block';
                document.getElementById('navigation').style.display = 'flex';
                document.getElementById('stats').style.display = 'block';
                document.getElementById('quickActions').style.display = 'grid';
                document.getElementById('practiceModeBtn').style.display = 'block';
                document.getElementById('settingsToggleBtn').style.display = 'flex';
                document.getElementById('clearFileBtn').style.display = 'inline-block';
                document.getElementById('viewModeToggle').style.display = 'flex'; // Show view mode toggle
                document.getElementById('instructions').style.display = 'none';

                // NOTE: Auto-show management sections is ONLY for new file uploads, not for loading existing files
                // This function is for loading existing saved data, so we don't show management sections

                // Hide suggestions and manage categories
                document.getElementById('suggestedCategorySection').style.display = 'none';
                document.getElementById('mainManageCategories').style.display = 'none';

                // Auto-hide Category Browser, Settings, and Upload Section when loading a file for practice
                document.getElementById('categoryBrowser').style.display = 'none';
                document.getElementById('settingsMenu').style.display = 'none';
                document.getElementById('settingsToggleBtn').style.display = 'none';
                document.getElementById('uploadSection').style.display = 'none';
                console.log('   âœ… Category Browser, Settings, and Upload Section auto-hidden for clean practice view');

                // Scroll to flashcard
                document.getElementById('flashcardContainer').scrollIntoView({ behavior: 'smooth', block: 'start' });

            } catch (error) {
                console.error('Error loading saved vocabulary:', error);
                alert('Error loading vocabulary data. Please upload the file again.');
            }
        }

        // Helper: Clear practice cache (called when switching files or logging out)
        function clearPracticeCache() {
            try {
                safeStorage.removeItem('practice_cache');
                safeStorage.removeItem('practice_cache_filename');
                console.log('ðŸ§¹ Practice cache cleared');
            } catch (error) {
                console.warn('âš ï¸ Could not clear practice cache:', error);
            }
        }

        // TEST FUNCTION - For testing suggestion display
        function testAutoOpen() {
            console.log('ðŸ§ª TEST: Manual trigger of suggestion display');
            console.log('ðŸ§ª TEST: Using lastDetectedSuggestion:', window.lastDetectedSuggestion);

            // Use real suggestion if available, otherwise use test values
            let testCategory = 'TestCategory';
            let testSubcategory = 'TestSubcategory';

            if (window.lastDetectedSuggestion) {
                testCategory = window.lastDetectedSuggestion.category;
                testSubcategory = window.lastDetectedSuggestion.subcategory;
                console.log('ðŸ§ª TEST: Using real detected values');
            } else if (window.pendingCategorySuggestion) {
                testCategory = window.pendingCategorySuggestion.category;
                testSubcategory = window.pendingCategorySuggestion.subcategory;
                console.log('ðŸ§ª TEST: Using pending suggestion');
            } else {
                console.log('ðŸ§ª TEST: No suggestion found, using test values');
            }

            showCategorySuggestion(testCategory, testSubcategory);
            console.log('âœ… TEST: Suggestion display triggered');
        }

        // Load categories and render browser on page load
        loadCategories();
        renderCategoryBrowser();

        const csvFileInput = document.getElementById('csvFile');
        const fileInfo = document.getElementById('fileInfo');
        const flashcardContainer = document.getElementById('flashcardContainer');
        const flashcard = document.getElementById('flashcard');
        const navigation = document.getElementById('navigation');
        const germanWord = document.getElementById('germanWord');
        const englishWord = document.getElementById('englishWord');
        const detailBack = document.getElementById('detailBack');
        const progress = document.getElementById('progress');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const controlButtons = document.getElementById('controlButtons');
        const stats = document.getElementById('stats');
        const learnedCount = document.getElementById('learnedCount');
        const remainingCount = document.getElementById('remainingCount');
        const totalCount = document.getElementById('totalCount');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const learnedBtn = document.getElementById('learnedBtn');
        const resetBtn = document.getElementById('resetBtn');
        const showLearnedBtn = document.getElementById('showLearnedBtn');
        const repeatBtn = document.getElementById('repeatBtn');
        const deleteRecordBtn = document.getElementById('deleteRecordBtn');
        const learnedBadge = document.getElementById('learnedBadge');
        const audioBtn = document.getElementById('audioBtn');
        const reviewInfo = document.getElementById('reviewInfo');
        const englishSection = document.getElementById('englishSection');
        const revealBtn = document.getElementById('revealBtn');
        const alwaysShowMeaningsCheckbox = document.getElementById('alwaysShowMeanings');
        const showMeaningsToggle = document.getElementById('showMeaningsToggle');
        const audioBtnEnglish = document.getElementById('audioBtnEnglish');

        // Auto-play elements
        const autoplayBtn = document.getElementById('autoplayBtn');
        const autoplaySettings = document.getElementById('autoplaySettings');
        const autoplayEnglishCheckbox = document.getElementById('autoplayEnglish');
        const delayBetweenSlider = document.getElementById('delayBetween');
        const delayNextSlider = document.getElementById('delayNext');
        const delayBetweenValue = document.getElementById('delayBetweenValue');
        const delayNextValue = document.getElementById('delayNextValue');

        // Helper function to generate unique file name
        function generateUniqueFileName(originalName) {
            // Extract file name without extension
            const lastDotIndex = originalName.lastIndexOf('.');
            const baseName = lastDotIndex > 0 ? originalName.substring(0, lastDotIndex) : originalName;
            const extension = lastDotIndex > 0 ? originalName.substring(lastDotIndex) : '';

            let counter = 1;
            let newName = `${baseName}_${counter}${extension}`;

            // Keep incrementing until we find a unique name
            while (fileCategories[newName]) {
                counter++;
                newName = `${baseName}_${counter}${extension}`;
            }

            return newName;
        }

        // Helper function to generate unique subcategory name
        function generateUniqueSubcategory(category, originalSubcategory) {
            if (!originalSubcategory) return '';

            // Check if this subcategory already exists in this category
            const existingSubcategories = categories[category] || [];

            if (!existingSubcategories.includes(originalSubcategory)) {
                return originalSubcategory; // Not a duplicate, use original
            }

            let counter = 1;
            let newSubcategory = `${originalSubcategory}_${counter}`;

            // Keep incrementing until we find a unique subcategory
            while (existingSubcategories.includes(newSubcategory)) {
                counter++;
                newSubcategory = `${originalSubcategory}_${counter}`;
            }

            return newSubcategory;
        }

        // Handle file upload
        csvFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                console.log('ðŸ†• New file upload detected:', file.name);

                // âš ï¸ VALIDATION: Check for duplicate file name
                if (fileCategories[file.name]) {
                    const existingFile = fileCategories[file.name];
                    const proposedFileName = generateUniqueFileName(file.name);

                    // Show error dialog with proposed solution
                    const userResponse = confirm(
                        'âš ï¸ DUPLICATE FILE DETECTED!\n\n' +
                        `File name: "${file.name}"\n` +
                        `Already exists in your library!\n\n` +
                        `Existing file details:\n` +
                        `â€¢ Category: ${existingFile.category}\n` +
                        `â€¢ Subcategory: ${existingFile.subcategory || '(None)'}\n\n` +
                        `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n` +
                        `PROPOSED SOLUTION:\n` +
                        `ðŸ“ New file name: "${proposedFileName}"\n\n` +
                        `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n` +
                        `Click OK to proceed with the new file name.\n` +
                        `Click CANCEL to choose a different file.`
                    );

                    if (!userResponse) {
                        // User cancelled - reset file input
                        csvFileInput.value = '';
                        fileInfo.textContent = 'âŒ Upload cancelled. Please rename your file or choose a different one.';
                        console.log('âŒ User cancelled upload due to duplicate file name');
                        return;
                    }

                    // User accepted - we'll rename the file internally
                    console.log(`âœ… User accepted new file name: ${proposedFileName}`);

                    // Store the proposed name to use during parsing
                    window.proposedFileName = proposedFileName;
                } else {
                    // No duplicate, clear any previous proposed name
                    window.proposedFileName = null;
                }

                // Clear any pending suggestion from previous file
                window.pendingCategorySuggestion = null;
                window.lastDetectedSuggestion = null;
                console.log('   Cleared pending suggestions');

                // Hide format selector and suggestion box from previous upload
                const formatSelector = document.getElementById('formatSelector');
                const suggestionBox = document.getElementById('suggestedCategorySection');
                if (formatSelector) {
                    formatSelector.style.display = 'none';
                    console.log('   Hidden format selector');
                }
                if (suggestionBox) {
                    suggestionBox.style.display = 'none';
                    console.log('   Hidden suggestion box');
                }

                // Reset column mapping
                columnMapping = null;
                console.log('   Reset column mapping');

                fileInfo.textContent = `Loading: ${window.proposedFileName || file.name}`;
                parseCSV(file);
            }
        });

        // Handle clear file button
        document.getElementById('clearFileBtn').addEventListener('click', () => {
            if (confirm('Remove current file and reset? All unsaved progress will be kept in browser storage.')) {
                console.log('ðŸ—‘ï¸ Clearing current file and resetting UI');

                // Reset file input
                csvFileInput.value = '';

                // Clear current data
                flashcards = [];
                filteredCards = [];
                currentIndex = 0;
                currentFileName = '';

                // Clear suggestions
                window.pendingCategorySuggestion = null;
                window.lastDetectedSuggestion = null;
                console.log('   Cleared suggestions');

                // Stop any ongoing auto-play
                stopAutoPlay();

                // Hide UI elements
                flashcardContainer.style.display = 'none';
                navigation.style.display = 'none';
                stats.style.display = 'none';
                document.getElementById('quickActions').style.display = 'none';
                document.getElementById('settingsToggleBtn').style.display = 'none';
                document.getElementById('settingsMenu').style.display = 'none';
                document.getElementById('clearFileBtn').style.display = 'none';
                document.getElementById('viewModeToggle').style.display = 'none'; // Hide view mode toggle
                document.getElementById('sessionStats').style.display = 'none';
                document.getElementById('timerDisplay').style.display = 'none';

                // Hide format selector and suggestion box
                const formatSelector = document.getElementById('formatSelector');
                const suggestionBox = document.getElementById('suggestedCategorySection');
                if (formatSelector) {
                    formatSelector.style.display = 'none';
                }
                if (suggestionBox) {
                    suggestionBox.style.display = 'none';
                }
                console.log('   Hidden format selector and suggestion box');

                // Update file info
                fileInfo.textContent = 'File removed. Upload a new CSV file to continue.';

                // Show instructions again
                document.getElementById('instructions').style.display = 'block';

                console.log('âœ… File cleared successfully');
            }
        });

        // LocalStorage functions
        async function saveFlashcardsToCloud() {
            if (currentFileName && flashcards.length > 0) {
                try {
                    const progressData = flashcards.map(card => ({
                        id: card.id,
                        lang1: card.lang1,
                        lang1Extended: card.lang1Extended || '',
                        lang2: card.lang2,
                        lang2Extended: card.lang2Extended || '',
                        detail: card.detail || '',
                        learned: card.learned,
                        reviewDate: card.reviewDate || null,
                        repetitions: card.repetitions || 0,
                        easeFactor: card.easeFactor || 2.5,
                        interval: card.interval || 1,
                        category: card.category || 'Default',
                        subcategory: card.subcategory || ''
                    }));

                    const jsonData = JSON.stringify(progressData);
                    const sizeInMB = (jsonData.length / (1024 * 1024)).toFixed(2);

                    console.log(`Saving ${currentFileName}: ${flashcards.length} cards, ${sizeInMB}MB`);

                    // CLOUD-FIRST MODE: Try to save to cloud first if enabled
                    if (isCloudFirstMode) {
                        console.log('â˜ï¸ Cloud-first mode: Attempting cloud save...');
                        const cloudSaveSuccess = await saveToCloudImmediate(currentFileName, jsonData);

                        if (cloudSaveSuccess) {
                            // Cloud save succeeded - update memory cache only (no localStorage)
                            console.log('âœ… Cloud save successful. Updating memory cache...');
                            cloudDataCache[currentFileName] = jsonData;
                            console.log(`ðŸ’¾ Updated memory cache for ${currentFileName}`);

                            // HYBRID MODE: Also update practice cache if this is the current practice file
                            try {
                                const cachedFileName = safeStorage.getItem('practice_cache_filename');
                                if (cachedFileName === currentFileName) {
                                    safeStorage.setItem('practice_cache', jsonData);
                                    console.log('ðŸ’¾ Practice cache updated for offline resilience');
                                }
                            } catch (cacheError) {
                                console.warn('âš ï¸ Could not update practice cache (non-critical):', cacheError);
                            }

                            console.log('â˜ï¸ Data stored: Cloud (master) + Memory (cache) + Practice cache (if active)');

                            // Remove from pending sync list
                            pendingCloudSync.delete(currentFileName);

                            // Try to sync any other pending files (retry mechanism)
                            if (pendingCloudSync.size > 0) {
                                console.log(`ðŸ“¤ Found ${pendingCloudSync.size} pending file(s) to sync. Attempting full cloud sync...`);
                                try {
                                    await uploadToCloud(); // This will upload all files including pending ones
                                    console.log('âœ… Pending files synced successfully');
                                    pendingCloudSync.clear(); // Clear all pending after successful upload
                                } catch (retryError) {
                                    console.warn('âš ï¸ Could not sync pending files, will retry later:', retryError);
                                }
                            }

                            return; // Exit early - save is complete
                        } else {
                            // CLOUD-MASTER MODE: No localStorage fallback - show error
                            console.error('âŒ Cloud save failed in cloud-master mode!');
                            pendingCloudSync.add(currentFileName);
                            console.warn(`ðŸ“ File marked for cloud sync. Pending files: ${pendingCloudSync.size}`);

                            // Update sync status to show pending uploads
                            updateSyncStatus('error', `âš ï¸ ${pendingCloudSync.size} Pending`);

                            alert('âš ï¸ CLOUD SAVE FAILED\n\n' +
                                'Your progress could not be saved to cloud.\n\n' +
                                'The app will retry automatically.\n' +
                                'Please ensure you have internet connection.\n\n' +
                                'âš ï¸ Do not close the app until cloud save succeeds.');
                            return; // Don't continue to localStorage save
                        }
                    }

                    // NON-CLOUD MODE: Save to localStorage only if cloud is disabled
                    if (!isCloudEnabled) {
                        safeStorage.setItem(`flashcards_${currentFileName}`, jsonData);
                    }

                    // Check if it was stored as chunks
                    const chunkCount = localStorage.getItem(`flashcards_${currentFileName}_chunks`);
                    if (chunkCount) {
                        console.log(`âœ… Large file saved successfully using ${chunkCount} chunks`);
                    }
                } catch (error) {
                    console.error('Error saving progress:', error);

                    if (error.message.startsWith('QUOTA_EXCEEDED_WITH_DETAILS:')) {
                        // Extract the detailed cleanup message
                        const cleanupDetails = error.message.replace('QUOTA_EXCEEDED_WITH_DETAILS:', '');
                        alert(`âš ï¸ STORAGE LIMIT EXCEEDED\n\n` +
                            `Cannot save ${flashcards.length} flashcards - storage is full!\n\n` +
                            cleanupDetails);
                    } else if (error.message === 'QUOTA_EXCEEDED') {
                        alert(`âš ï¸ STORAGE LIMIT EXCEEDED\n\n` +
                            `Your device's storage is full and cannot save ${flashcards.length} flashcards.\n\n` +
                            `SOLUTIONS:\n` +
                            `1. Enable Cloud Sync (â˜ï¸ button) to store data online\n` +
                            `2. Clear browser data for this site\n` +
                            `3. Delete unused flashcard categories\n` +
                            `4. Split your file into smaller files\n\n` +
                            `âš ï¸ Your current session data may not be saved!`);
                    } else {
                        alert(`Failed to save progress: ${error.message}`);
                    }
                }
            }
        }

        // Save to storage function (used by file manager)
        function saveToStorage() {
            saveProgress();
        }

        function loadProgress(fileName) {
            // CLOUD-FIRST MODE: Check memory cache first
            if (isCloudFirstMode && cloudDataCache[fileName]) {
                console.log(`â˜ï¸ Loading ${fileName} from memory cache`);
                try {
                    return JSON.parse(cloudDataCache[fileName]);
                } catch (e) {
                    console.error(`Error parsing cached data for ${fileName}:`, e);
                }
            }

            // FALLBACK: Try localStorage
            const saved = safeStorage.getItem(`flashcards_${fileName}`);
            if (saved) {
                return JSON.parse(saved);
            }
            return null;
        }

        // Spaced Repetition Algorithm (SM-2)
        function calculateNextReview(card, quality) {
            // quality: 0-5 (0=total blackout, 5=perfect response)
            let easeFactor = card.easeFactor || 2.5;
            let repetitions = card.repetitions || 0;
            let interval = card.interval || 1;

            if (quality >= 3) {
                // Correct response
                if (repetitions === 0) {
                    interval = 1;
                } else if (repetitions === 1) {
                    interval = 6;
                } else {
                    interval = Math.round(interval * easeFactor);
                }
                repetitions++;
            } else {
                // Incorrect response - restart
                repetitions = 0;
                interval = 1;
            }

            // Update ease factor
            easeFactor = easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
            if (easeFactor < 1.3) easeFactor = 1.3;

            const nextReviewDate = new Date();
            nextReviewDate.setDate(nextReviewDate.getDate() + interval);

            return {
                repetitions,
                easeFactor,
                interval,
                reviewDate: nextReviewDate.toISOString()
            };
        }

        // Check if card is due for review
        function isDueForReview(card) {
            if (!card.reviewDate) return true;
            return new Date() >= new Date(card.reviewDate);
        }

        // Smart language detection helper
        function detectGerman(text) {
            if (!text) return false;

            // German-specific characters
            const germanChars = /[Ã¤Ã¶Ã¼ÃŸÃ„Ã–Ãœ]/;
            if (germanChars.test(text)) return true;

            // Common German articles and words (case insensitive)
            const germanWords = /\b(der|die|das|den|dem|des|ein|eine|einen|einem|eines|ich|du|er|sie|es|wir|ihr|und|oder|aber|auch|nicht|ist|sind|haben|hat|zu|auf|in|mit|von|fÃ¼r)\b/i;
            if (germanWords.test(text)) return true;

            return false;
        }

        function detectEnglish(text) {
            if (!text) return false;

            // Common English articles and words
            const englishWords = /\b(the|a|an|and|or|but|in|on|at|to|for|of|with|by|from|is|are|was|were|be|been|have|has|had|do|does|did|will|would|can|could|should|may|might|must|this|that|these|those|i|you|he|she|it|we|they|about|sorry|happy|sad|feel|feeling|love|surprised|amazed|furious|satisfied|possible|pleased|excited|interested|grateful|thankful|afraid|anxious|fearful)\b/i;
            return englishWords.test(text);
        }

        function detectPersian(text) {
            if (!text) return false;

            // Persian/Farsi Unicode range: \u0600-\u06FF (Arabic script used for Persian)
            // Persian-specific characters: Ø¢ Ø§ Ø¨ Ù¾ Øª Ø« Ø¬ Ú† Ø­ Ø® Ø¯ Ø° Ø± Ø² Ú˜ Ø³ Ø´ Øµ Ø¶ Ø· Ø¸ Ø¹ Øº Ù Ù‚ Ú© Ú¯ Ù„ Ù… Ù† Ùˆ Ù‡ ÛŒ
            const persianChars = /[\u0600-\u06FF]/;
            if (persianChars.test(text)) {
                // Additional check for Persian-specific letters (not in Arabic)
                // Ù¾ (pe), Ú† (che), Ú˜ (zhe), Ú¯ (gaf) are unique to Persian
                const persianSpecific = /[Ù¾Ú†Ú˜Ú¯]/;
                return persianSpecific.test(text) || persianChars.test(text);
            }

            return false;
        }

        // Get language code for Text-to-Speech based on detected language
        function getLanguageCode(text) {
            if (!text) return null;

            // Check for Persian/Farsi
            if (detectPersian(text)) return 'fa-IR';

            // Check for German
            if (detectGerman(text)) return 'de-DE';

            // Check for English
            if (detectEnglish(text)) return 'en-US';

            // Add more language detections as needed
            // Chinese
            if (/[\u4e00-\u9fff]/.test(text)) return 'zh-CN';
            // Japanese
            if (/[\u3040-\u309f\u30a0-\u30ff]/.test(text)) return 'ja-JP';
            // Korean
            if (/[\uac00-\ud7af]/.test(text)) return 'ko-KR';
            // Arabic (not Persian)
            if (/[\u0600-\u06ff]/.test(text) && !detectPersian(text)) return 'ar-SA';
            // Spanish
            if (/\b(el|la|los|las|un|una|de|del|en|y|o|pero|con|por|para|que|como|muy|mÃ¡s|espaÃ±ol)\b/i.test(text)) return 'es-ES';
            // French
            if (/\b(le|la|les|un|une|de|du|des|en|et|ou|mais|avec|pour|dans|que|comme|trÃ¨s|plus|franÃ§ais)\b/i.test(text)) return 'fr-FR';
            // Italian
            if (/\b(il|lo|la|i|gli|le|un|uno|una|di|da|in|con|su|per|tra|fra|a|che|come|molto|piÃ¹|italiano)\b/i.test(text)) return 'it-IT';
            // Portuguese
            if (/\b(o|a|os|as|um|uma|de|da|do|das|dos|em|e|ou|mas|com|por|para|que|como|muito|mais|portuguÃªs)\b/i.test(text)) return 'pt-BR';
            // Russian
            if (/[\u0400-\u04ff]/.test(text)) return 'ru-RU';
            // Turkish
            if (/[ÄŸÄžÄ±Ä°Ã¶Ã–ÅŸÅžÃ¼ÃœÃ§Ã‡]/.test(text)) return 'tr-TR';
            // Dutch
            if (/\b(de|het|een|en|van|in|op|te|voor|met|door|als|aan|bij|dat|die|dit|zijn|naar|ook)\b/i.test(text)) return 'nl-NL';
            // Polish
            if (/[Ä…Ä‡Ä™Å‚Å„Ã³Å›ÅºÅ¼Ä„Ä†Ä˜ÅÅƒÃ“ÅšÅ¹Å»]/.test(text)) return 'pl-PL';

            return null; // Unknown language
        }

        function isLikelyWord(text) {
            if (!text) return false;
            const trimmed = text.trim();
            // A word/short phrase is typically:
            // - 1-3 words OR
            // - Contains slashes (like "happy / sad / angry") but less than 8 words
            const wordCount = trimmed.split(/\s+/).length;
            const hasSlashes = /\//.test(trimmed);
            return wordCount <= 3 || (hasSlashes && wordCount <= 8);
        }

        function isLikelySentence(text) {
            if (!text) return false;
            const trimmed = text.trim();
            // A sentence is typically: longer text with sentence punctuation
            const wordCount = trimmed.split(/\s+/).length;
            const hasSentencePunctuation = /[.!?]/.test(trimmed);
            // Don't count slash-separated lists as sentences
            const hasSlashes = /\//.test(trimmed);
            return (wordCount > 8 || (wordCount > 3 && hasSentencePunctuation)) && !hasSlashes;
        }

        // Advanced per-row format detection
        function detectRowFormat(parts) {
            if (!parts || parts.length < 2) return null;

            // If manual column mapping is set, use it
            if (columnMapping && Object.keys(columnMapping).length > 0) {
                const result = {
                    lang1: '',
                    lang1Extended1: '',
                    lang1Extended2: '',
                    lang1Extended3: '',
                    lang2: '',
                    lang2Extended1: '',
                    lang2Extended2: '',
                    lang2Extended3: '',
                    detail: ''
                };

                Object.keys(columnMapping).forEach(colKey => {
                    const colIndex = parseInt(colKey.replace('col', ''));
                    const colType = columnMapping[colKey];
                    const colValue = parts[colIndex] ? parts[colIndex].trim() : '';

                    if (colType === 'lang1') result.lang1 = colValue;
                    else if (colType === 'lang1Extended1') result.lang1Extended1 = colValue;
                    else if (colType === 'lang1Extended2') result.lang1Extended2 = colValue;
                    else if (colType === 'lang1Extended3') result.lang1Extended3 = colValue;
                    else if (colType === 'lang2') result.lang2 = colValue;
                    else if (colType === 'lang2Extended1') result.lang2Extended1 = colValue;
                    else if (colType === 'lang2Extended2') result.lang2Extended2 = colValue;
                    else if (colType === 'lang2Extended3') result.lang2Extended3 = colValue;
                });

                // console.log('Using manual mapping:', result); // Disabled to reduce console spam
                return result;
            }

            // Otherwise use auto-detection

            // Analyze each column
            const columns = parts.map((part, idx) => {
                const trimmed = part.trim();
                return {
                    index: idx,
                    text: trimmed,
                    isGerman: detectGerman(trimmed),
                    isEnglish: detectEnglish(trimmed),
                    isPersian: detectPersian(trimmed),
                    isLong: isLikelySentence(trimmed),
                    isShort: isLikelyWord(trimmed),
                    wordCount: trimmed.split(/\s+/).length
                };
            });

            let result = {
                lang1: '',
                lang1Extended: '',
                lang2: '',
                lang2Extended: '',
                detail: ''
            };

            // Strategy: Find the most likely language-specific words first
            const germanCandidates = columns.filter(c => c.isGerman && !c.isEnglish && !c.isPersian);
            const englishCandidates = columns.filter(c => c.isEnglish && !c.isGerman && !c.isPersian);
            const persianCandidates = columns.filter(c => c.isPersian && !c.isGerman && !c.isEnglish);
            const ambiguousCandidates = columns.filter(c => !c.isGerman && !c.isEnglish && !c.isPersian);

            console.log('Detection analysis:', {
                germanCandidates: germanCandidates.map(c => ({index: c.index, text: c.text, wordCount: c.wordCount, isShort: c.isShort, isLong: c.isLong})),
                englishCandidates: englishCandidates.map(c => ({index: c.index, text: c.text, wordCount: c.wordCount, isShort: c.isShort, isLong: c.isLong})),
                persianCandidates: persianCandidates.map(c => ({index: c.index, text: c.text, wordCount: c.wordCount, isShort: c.isShort, isLong: c.isLong})),
                ambiguousCandidates: ambiguousCandidates.map(c => ({index: c.index, text: c.text, wordCount: c.wordCount}))
            });

            // IMPROVED: Prioritize shortest German word (1-3 words) as main vocab
            const germanShortWords = germanCandidates.filter(c => c.isShort).sort((a, b) => a.wordCount - b.wordCount);
            let germanWord = germanShortWords[0] || germanCandidates.sort((a, b) => a.wordCount - b.wordCount)[0];

            // IMPROVED: Prioritize shortest English word (1-3 words) as main translation
            const englishShortWords = englishCandidates.filter(c => c.isShort).sort((a, b) => a.wordCount - b.wordCount);
            let englishWord = englishShortWords[0] || englishCandidates.sort((a, b) => a.wordCount - b.wordCount)[0];

            // IMPROVED: Prioritize shortest Persian word (1-3 words) as main vocab
            const persianShortWords = persianCandidates.filter(c => c.isShort).sort((a, b) => a.wordCount - b.wordCount);
            let persianWord = persianShortWords[0] || persianCandidates.sort((a, b) => a.wordCount - b.wordCount)[0];

            // CRITICAL FIX: If we have ambiguous (undetected) columns AND detected candidates,
            // check if the ambiguous column is SHORTER - if so, use it as the main word
            if (ambiguousCandidates.length > 0) {
                // Sort ambiguous by word count to find shortest
                const sortedAmbiguous = ambiguousCandidates.sort((a, b) => a.wordCount - b.wordCount);
                const shortestAmbiguous = sortedAmbiguous[0];

                // If we have a German candidate but ambiguous is shorter, use ambiguous as German
                if (germanWord && shortestAmbiguous.wordCount < germanWord.wordCount) {
                    console.log(`Overriding German word: "${germanWord.text}" (${germanWord.wordCount} words) with ambiguous: "${shortestAmbiguous.text}" (${shortestAmbiguous.wordCount} words)`);
                    // Move current germanWord to long position
                    const germanLongTemp = germanWord;
                    germanWord = shortestAmbiguous;
                    // Remove this ambiguous from list
                    const ambIdx = ambiguousCandidates.indexOf(shortestAmbiguous);
                    if (ambIdx > -1) ambiguousCandidates.splice(ambIdx, 1);
                }
            }

            // Find long German text (example sentence) - must be different from germanWord
            const germanLong = germanCandidates.find(c => c.isLong && c.index !== germanWord?.index);

            // Find long English text (example sentence) - must be different from englishWord
            const englishLong = englishCandidates.find(c => c.isLong && c.index !== englishWord?.index);

            // Find long Persian text (example sentence) - must be different from persianWord
            const persianLong = persianCandidates.find(c => c.isLong && c.index !== persianWord?.index);

            console.log('Selected words:', {
                germanWord: germanWord?.text,
                germanLong: germanLong?.text,
                englishWord: englishWord?.text,
                englishLong: englishLong?.text,
                persianWord: persianWord?.text,
                persianLong: persianLong?.text
            });

            // Assign words based on detected languages
            // Priority: If Persian detected, use Persian as lang1 (source), otherwise use German
            if (persianWord) {
                result.lang1 = persianWord.text;
                if (persianLong) result.lang1Extended = persianLong.text;
                // Persian typically pairs with English
                if (englishWord) result.lang2 = englishWord.text;
                if (englishLong) result.lang2Extended = englishLong.text;
            } else if (germanWord) {
                result.lang1 = germanWord.text;
                if (germanLong) result.lang1Extended = germanLong.text;
                if (englishWord) result.lang2 = englishWord.text;
                if (englishLong) result.lang2Extended = englishLong.text;
            } else if (englishWord) {
                // Only English detected - use as target language
                result.lang2 = englishWord.text;
                if (englishLong) result.lang2Extended = englishLong.text;
            }

            // Handle ambiguous columns (could be either language)
            if (!germanWord && !englishWord && !persianWord && parts.length >= 2) {
                // Fallback: assume first two columns are source, target language
                result.lang1 = parts[0].trim();
                result.lang2 = parts[1].trim();
                if (parts.length > 2) result.detail = parts.slice(2).join(', ');
            } else if (!englishWord && germanCandidates.length >= 2) {
                // Special case: We have 2+ German columns but NO English
                // This likely means: German word, German example, English (misdetected as German or ambiguous)

                // Sort all candidates by position
                const sortedGerman = germanCandidates.sort((a, b) => a.index - b.index);

                // Strategy:
                // - SHORTEST German candidate = German word
                // - Remaining columns = figure out which is German example vs English

                // Find shortest German candidate
                const shortestGerman = [...germanCandidates].sort((a, b) => a.wordCount - b.wordCount)[0];
                result.lang1 = shortestGerman.text;

                // Get remaining candidates
                const remainingCandidates = columns.filter(c => c.index !== shortestGerman.index);

                // If we have exactly 2 remaining columns:
                if (remainingCandidates.length === 2) {
                    // Assume: [German Extended, English] in order
                    // The one with more German markers = German Extended
                    // The one with fewer German markers = English (even if has some German words)
                    const first = remainingCandidates[0];
                    const second = remainingCandidates[1];

                    // Count German-specific characters
                    const firstGermanScore = (first.text.match(/[Ã¤Ã¶Ã¼ÃŸÃ„Ã–Ãœ]/g) || []).length;
                    const secondGermanScore = (second.text.match(/[Ã¤Ã¶Ã¼ÃŸÃ„Ã–Ãœ]/g) || []).length;

                    if (firstGermanScore > secondGermanScore) {
                        result.lang1Extended = first.text;
                        result.lang2 = second.text;
                    } else if (secondGermanScore > firstGermanScore) {
                        result.lang1Extended = second.text;
                        result.lang2 = first.text;
                    } else {
                        // Equal scores or both zero - use position-based fallback
                        // First remaining = German extended, Second = English
                        result.lang1Extended = first.text;
                        result.lang2 = second.text;
                    }
                } else if (remainingCandidates.length === 1) {
                    // Only one remaining - treat as English
                    result.lang2 = remainingCandidates[0].text;
                } else {
                    // More than 2 remaining - take first two by position
                    result.lang1Extended = remainingCandidates[0].text;
                    result.lang2 = remainingCandidates[1].text;
                }

                console.log('Multiple German, no English detected - using smart positional fallback');
            } else if (!germanWord && englishWord) {
                // Only English detected, guess German from remaining
                // Prioritize SHORT words over LONG sentences
                const remainingCols = columns.filter(c => c.index !== englishWord.index && c.index !== englishLong?.index);
                const shortRemaining = remainingCols.filter(c => c.isShort).sort((a, b) => a.wordCount - b.wordCount);
                result.lang1 = (shortRemaining[0] || remainingCols[0])?.text || '';

                // The longer remaining text becomes lang1Extended
                const longRemaining = remainingCols.find(c => c.isLong && c.text !== result.lang1);
                if (longRemaining) result.lang1Extended = longRemaining.text;
            } else if (germanWord && !englishWord) {
                // Only German detected, guess English from remaining
                // Prioritize SHORT words over LONG sentences
                const remainingCols = columns.filter(c => c.index !== germanWord.index && c.index !== germanLong?.index);
                const shortRemaining = remainingCols.filter(c => c.isShort).sort((a, b) => a.wordCount - b.wordCount);
                result.lang2 = (shortRemaining[0] || remainingCols[0])?.text || '';

                // The longer remaining text becomes lang2Extended
                const longRemaining = remainingCols.find(c => c.isLong && c.text !== result.lang2);
                if (longRemaining) result.lang2Extended = longRemaining.text;
            }

            // Collect any remaining columns as detail
            const usedIndices = [
                germanWord?.index,
                germanLong?.index,
                englishWord?.index,
                englishLong?.index
            ].filter(i => i !== undefined);

            const unusedColumns = columns.filter(c => !usedIndices.includes(c.index));
            if (unusedColumns.length > 0) {
                result.detail = unusedColumns.map(c => c.text).join(', ');
            }

            return result;
        }

        // Show format selector (3 options)
        function showFormatSelector(lines, separator) {
            document.getElementById('formatSelector').style.display = 'block';
            document.getElementById('instructions').style.display = 'none';

            // Add event listeners to preset format buttons
            document.querySelectorAll('.format-preset-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const format = btn.getAttribute('data-format');
                    applyPredefinedFormat(format);
                });
            });
        }

        // Option 1: Predefined formats
        function selectPredefinedFormat() {
            // Just highlight - buttons already have click handlers
            console.log('Click a preset format button');
        }

        function applyPredefinedFormat(format) {
            console.log('âš™ï¸ Applying predefined format:', format);
            console.log('âš™ï¸ Pending suggestion still exists?', window.pendingCategorySuggestion);

            // Set column mapping based on format
            columnMapping = {};

            switch(format) {
                case '3col-standard': // German, Source Example, English
                    columnMapping = {
                        col0: 'lang1',
                        col1: 'lang1Extended',
                        col2: 'lang2'
                    };
                    break;
                case '3col-reverse': // English, Target Example, German
                    columnMapping = {
                        col0: 'lang2',
                        col1: 'lang2Extended',
                        col2: 'lang1'
                    };
                    break;
                case '4col-full': // German, German Ex., English, English Ex.
                    columnMapping = {
                        col0: 'lang1',
                        col1: 'lang1Extended',
                        col2: 'lang2',
                        col3: 'lang2Extended'
                    };
                    break;
                case '2col-simple': // German, English
                    columnMapping = {
                        col0: 'lang1',
                        col1: 'lang2'
                    };
                    break;
            }

            // Hide selector and reload with predefined mapping
            document.getElementById('formatSelector').style.display = 'none';
            const file = new File([rawFileData], currentFileName, { type: 'text/csv' });
            parseCSV(file, true);
        }

        // Option 2: Manual mapping - Open modal immediately
        function selectManualMapping() {
            document.getElementById('formatSelector').style.display = 'none';
            const lines = rawFileData.split('\n').filter(line => line.trim() !== '');
            showColumnMapperModal(lines, detectedSeparator);
        }

        // Show column mapper in modal popup
        function showColumnMapperModal(lines, separator) {
            const table = document.getElementById('dataPreviewTable');

            // Get first 10 data rows (skip header if present)
            let startIndex = 0;
            const firstLine = lines[0].toLowerCase();
            if (firstLine.includes('lang1') || firstLine.includes('lang2') ||
                firstLine.includes('deutsch') || firstLine.includes('word') || firstLine.includes('voc')) {
                startIndex = 1;
            }

            const previewRows = lines.slice(startIndex, Math.min(startIndex + 15, lines.length));
            const sampleData = previewRows.map(line => line.split(separator).map(col => col.trim()));
            const numColumns = sampleData[0].length;

            // Initialize column types (all unassigned initially)
            const columnTypes = new Array(numColumns).fill('unassigned');

            // Build table HTML
            let tableHTML = '<thead><tr>';

            // Create column headers with dropdown selectors
            for (let i = 0; i < numColumns; i++) {
                tableHTML += `
                    <th id="col-header-${i}" data-col-index="${i}" onclick="toggleColumnTypeSelector(${i})" style="position: relative; cursor: pointer;">
                        <div style="font-size: 1.2em; margin-bottom: 5px;">Column ${i + 1}</div>
                        <div class="column-type-selector" id="type-selector-${i}">
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'lang1')" style="color: #10b981;">
                                <span style="font-size: 1.5em;">ðŸ“–</span>
                                <span>Source Language<br><small style="font-weight: normal; opacity: 0.8;">Main vocab (visible)</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'lang1Extended1')" style="color: #f59e0b;">
                                <span style="font-size: 1.5em;">ðŸ“</span>
                                <span>Source Example 1<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'lang1Extended2')" style="color: #f59e0b;">
                                <span style="font-size: 1.5em;">ðŸ“</span>
                                <span>Source Example 2<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'lang1Extended3')" style="color: #f59e0b;">
                                <span style="font-size: 1.5em;">ðŸ“</span>
                                <span>Source Example 3<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'lang2')" style="color: #3b82f6;">
                                <span style="font-size: 1.5em;">ðŸŽ¯</span>
                                <span>Target Language<br><small style="font-weight: normal; opacity: 0.8;">Main translation (visible)</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'lang2Extended1')" style="color: #ec4899;">
                                <span style="font-size: 1.5em;">ðŸ“–</span>
                                <span>Target Example 1<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'lang2Extended2')" style="color: #ec4899;">
                                <span style="font-size: 1.5em;">ðŸ“–</span>
                                <span>Target Example 2<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'lang2Extended3')" style="color: #ec4899;">
                                <span style="font-size: 1.5em;">ðŸ“–</span>
                                <span>Target Example 3<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'ignore')" style="color: #94a3b8;">
                                <span style="font-size: 1.5em;">ðŸš«</span>
                                <span>Ignore Column<br><small style="font-weight: normal; opacity: 0.8;">Skip this data</small></span>
                            </div>
                        </div>
                    </th>
                `;
            }
            tableHTML += '</tr></thead><tbody>';

            // Add data rows
            sampleData.forEach((row, rowIndex) => {
                tableHTML += '<tr>';
                row.forEach((cell, colIndex) => {
                    const displayText = cell.length > 40 ? cell.substring(0, 40) + '...' : cell;
                    tableHTML += `<td title="${cell}">${displayText}</td>`;
                });
                tableHTML += '</tr>';
            });

            tableHTML += '</tbody>';
            table.innerHTML = tableHTML;

            // Store column types globally for later use
            window.currentColumnTypes = columnTypes;

            // Show the modal
            document.getElementById('columnMapperModal').style.display = 'flex';
        }

        // Close column mapper modal
        function closeColumnMapperModal() {
            document.getElementById('columnMapperModal').style.display = 'none';
            // Only show format selector again if user cancelled (not applied)
            if (!flashcards || flashcards.length === 0) {
                document.getElementById('formatSelector').style.display = 'block';
            }
        }

        // Option 3: Auto-detection
        function selectAutoDetection() {
            console.log('âš™ï¸ Auto-detection selected');
            console.log('âš™ï¸ Pending suggestion still exists?', window.pendingCategorySuggestion);
            console.log('âš™ï¸ rawFileData exists?', !!rawFileData);
            console.log('âš™ï¸ currentFileName:', currentFileName);

            columnMapping = null; // Reset to auto-detect
            document.getElementById('formatSelector').style.display = 'none';

            try {
                const file = new File([rawFileData], currentFileName, { type: 'text/csv' });
                console.log('âš™ï¸ File object created:', file);
                parseCSV(file, true);
            } catch (error) {
                console.error('âŒ ERROR in selectAutoDetection:', error);
                alert('ERROR: ' + error.message);
            }
        }

        // Show column mapping interface with data preview table
        function showColumnMapper(lines, separator) {
            const columnMapper = document.getElementById('columnMapper');
            const table = document.getElementById('dataPreviewTable');

            // Get first 10 data rows (skip header if present)
            let startIndex = 0;
            const firstLine = lines[0].toLowerCase();
            if (firstLine.includes('lang1') || firstLine.includes('lang2') ||
                firstLine.includes('deutsch') || firstLine.includes('word') || firstLine.includes('voc')) {
                startIndex = 1;
            }

            const previewRows = lines.slice(startIndex, Math.min(startIndex + 15, lines.length));
            const sampleData = previewRows.map(line => line.split(separator).map(col => col.trim()));
            const numColumns = sampleData[0].length;

            // Initialize column types (all unassigned initially)
            const columnTypes = new Array(numColumns).fill('unassigned');

            // Build table HTML
            let tableHTML = '<thead><tr>';

            // Create column headers with dropdown selectors
            for (let i = 0; i < numColumns; i++) {
                tableHTML += `
                    <th id="col-header-${i}" data-col-index="${i}" onclick="toggleColumnTypeSelector(${i})" style="position: relative; cursor: pointer;">
                        <div style="font-size: 1.2em; margin-bottom: 5px;">Column ${i + 1}</div>
                        <div class="column-type-selector" id="type-selector-${i}">
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'lang1')" style="color: #10b981;">
                                <span style="font-size: 1.5em;">ðŸ“–</span>
                                <span>Source Language<br><small style="font-weight: normal; opacity: 0.8;">Main vocab (visible)</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'lang1Extended1')" style="color: #f59e0b;">
                                <span style="font-size: 1.5em;">ðŸ“</span>
                                <span>Source Example 1<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'lang1Extended2')" style="color: #f59e0b;">
                                <span style="font-size: 1.5em;">ðŸ“</span>
                                <span>Source Example 2<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'lang1Extended3')" style="color: #f59e0b;">
                                <span style="font-size: 1.5em;">ðŸ“</span>
                                <span>Source Example 3<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'lang2')" style="color: #3b82f6;">
                                <span style="font-size: 1.5em;">ðŸŽ¯</span>
                                <span>Target Language<br><small style="font-weight: normal; opacity: 0.8;">Main translation (visible)</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'lang2Extended1')" style="color: #ec4899;">
                                <span style="font-size: 1.5em;">ðŸ“–</span>
                                <span>Target Example 1<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'lang2Extended2')" style="color: #ec4899;">
                                <span style="font-size: 1.5em;">ðŸ“–</span>
                                <span>Target Example 2<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'lang2Extended3')" style="color: #ec4899;">
                                <span style="font-size: 1.5em;">ðŸ“–</span>
                                <span>Target Example 3<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'ignore')" style="color: #94a3b8;">
                                <span style="font-size: 1.5em;">ðŸš«</span>
                                <span>Ignore Column<br><small style="font-weight: normal; opacity: 0.8;">Skip this data</small></span>
                            </div>
                        </div>
                    </th>
                `;
            }
            tableHTML += '</tr></thead><tbody>';

            // Add data rows
            sampleData.forEach((row, rowIndex) => {
                tableHTML += '<tr>';
                row.forEach((cell, colIndex) => {
                    const displayText = cell.length > 40 ? cell.substring(0, 40) + '...' : cell;
                    tableHTML += `<td title="${cell}">${displayText}</td>`;
                });
                tableHTML += '</tr>';
            });

            tableHTML += '</tbody>';
            table.innerHTML = tableHTML;

            // Store column types globally for later use
            window.currentColumnTypes = columnTypes;

            // Show the mapper
            columnMapper.style.display = 'block';
            document.getElementById('instructions').style.display = 'none';
        }

        // Toggle column type selector - Show dropdown
        function toggleColumnTypeSelector(colIndex) {
            const selector = document.getElementById(`type-selector-${colIndex}`);
            if (!selector) return;

            // Close all other selectors
            document.querySelectorAll('.column-type-selector.active').forEach(s => {
                if (s !== selector) s.classList.remove('active');
            });

            // Toggle current selector - CSS handles positioning automatically
            selector.classList.add('active');
        }

        // Set column type
        function setColumnType(colIndex, type) {
            window.currentColumnTypes[colIndex] = type;

            const header = document.getElementById(`col-header-${colIndex}`);

            // Remove all type classes
            header.classList.remove('type-lang1', 'type-lang1Extended', 'type-lang2', 'type-lang2Extended', 'type-ignore');

            // Add new type class
            if (type !== 'unassigned') {
                header.classList.add(`type-${type}`);
            }

            // Update header text and visual appearance
            const typeInfo = {
                'lang1': { icon: 'ðŸ“–', name: 'Source Language', desc: 'Main vocab (visible)' },
                'lang1Extended1': { icon: 'ðŸ“', name: 'Source Example 1', desc: 'Extended (hidden)' },
                'lang1Extended2': { icon: 'ðŸ“', name: 'Source Example 2', desc: 'Extended (hidden)' },
                'lang1Extended3': { icon: 'ðŸ“', name: 'Source Example 3', desc: 'Extended (hidden)' },
                'lang2': { icon: 'ðŸŽ¯', name: 'Target Language', desc: 'Main translation (visible)' },
                'lang2Extended1': { icon: 'ðŸ“–', name: 'Target Example 1', desc: 'Extended (hidden)' },
                'lang2Extended2': { icon: 'ðŸ“–', name: 'Target Example 2', desc: 'Extended (hidden)' },
                'lang2Extended3': { icon: 'ðŸ“–', name: 'Target Example 3', desc: 'Extended (hidden)' },
                'ignore': { icon: 'ðŸš«', name: 'Ignored', desc: 'Will be skipped' }
            };

            const info = typeInfo[type];

            // Preserve the dropdown selector HTML
            const selectorHTML = header.querySelector('.column-type-selector').outerHTML;

            // Update header content while keeping the dropdown
            header.innerHTML = `
                <div style="font-size: 2em; margin-bottom: 8px;">${info.icon}</div>
                <div style="font-size: 1em; font-weight: 600;">${info.name}</div>
                <div style="font-size: 0.75em; font-weight: normal; margin-top: 5px; opacity: 0.9;">${info.desc}</div>
                ${selectorHTML}
            `;

            // Re-attach the onclick event
            header.onclick = () => toggleColumnTypeSelector(colIndex);

            // Close all dropdowns
            document.querySelectorAll('.column-type-selector').forEach(selector => {
                selector.classList.remove('active');
            });

            console.log('Column', colIndex, 'set to', type);
        }

        // Close dropdowns when clicking outside, and close mapper modal when clicking overlay
        document.addEventListener('click', (e) => {
            const columnMapperModal = document.getElementById('columnMapperModal');

            // Close mapper modal if clicking on overlay
            if (e.target === columnMapperModal) {
                closeColumnMapperModal();
            }

            // Close dropdowns if clicking outside column headers and dropdowns
            if (!e.target.closest('th') && !e.target.closest('.column-type-selector')) {
                document.querySelectorAll('.column-type-selector').forEach(selector => {
                    selector.classList.remove('active');
                });
            }
        });

        // Process file with manual column mapping
        function processWithManualMapping() {
            // Build column mapping from user selections in the table
            columnMapping = {};
            window.currentColumnTypes.forEach((type, index) => {
                if (type !== 'ignore' && type !== 'unassigned') {
                    columnMapping[`col${index}`] = type;
                }
            });

            console.log('Manual column mapping:', columnMapping);

            // Validate that at least German and English are set
            const hasGerman = Object.values(columnMapping).includes('lang1');
            const hasEnglish = Object.values(columnMapping).includes('lang2');

            if (!hasGerman || !hasEnglish) {
                alert('Please assign at least one Source Language column and one Target Language column!');
                return;
            }

            // Close modal and continue with parsing
            closeColumnMapperModal();

            // Re-parse with manual mapping enabled
            const file = new File([rawFileData], currentFileName, { type: 'text/csv' });
            parseCSV(file, true);
        }

        // Use auto-detection (skip manual mapping)
        function useAutoDetection() {
            columnMapping = null; // Reset to auto-detect
            document.getElementById('columnMapper').style.display = 'none';

            // Re-parse with auto-detection
            const file = new File([rawFileData], currentFileName, { type: 'text/csv' });
            parseCSV(file, true);
        }

        // Detect CSV separator (comma, semicolon, tab, or pipe)
        function detectSeparator(text) {
            const lines = text.split('\n').filter(line => line.trim() !== '');
            if (lines.length === 0) return ',';

            const firstLine = lines[0];
            const separators = [',', ';', '\t', '|'];
            let bestSeparator = ',';
            let maxColumns = 0;

            for (const sep of separators) {
                const columns = firstLine.split(sep).length;
                if (columns > maxColumns && columns >= 2) {
                    maxColumns = columns;
                    bestSeparator = sep;
                }
            }

            return bestSeparator;
        }

        // Parse CSV file with smart format detection
        function parseCSV(file, useManualMapping = false) {
            console.log('ðŸš€ parseCSV CALLED! File:', file.name, 'useManualMapping:', useManualMapping);

            const reader = new FileReader();
            reader.onload = (e) => {
                console.log('ðŸ“– File read complete, parsing...');
                const text = e.target.result;
                const lines = text.split('\n').filter(line => line.trim() !== '');

                // Use proposed file name if it exists (due to duplicate detection)
                currentFileName = window.proposedFileName || file.name;
                rawFileData = text;
                console.log('ðŸ“ Current file:', currentFileName, '| Lines:', lines.length);
                if (window.proposedFileName) {
                    console.log('   â„¹ï¸ Using proposed file name due to duplicate detection');
                }

                // Detect separator automatically
                detectedSeparator = detectSeparator(text);
                console.log('Detected separator:', detectedSeparator === '\t' ? 'TAB' : detectedSeparator);

                // Store suggestion data for later (after parsing completes)
                // Only generate suggestion on FIRST parse (not on re-parse with format selection)
                if (!window.pendingCategorySuggestion) {
                    window.pendingCategorySuggestion = suggestCategoryFromFile(currentFileName, text);
                    console.log('ðŸ” Category suggestion prepared (first time):', window.pendingCategorySuggestion);
                } else {
                    console.log('ðŸ” Category suggestion already exists (re-parse):', window.pendingCategorySuggestion);
                }

                // Show format selector on first load (unless explicitly using a method)
                if (!useManualMapping) {
                    console.log('ðŸ“‹ Format selector hidden - directly showing suggestions');
                    // Format selector hidden - user sees only category suggestions

                    // Auto-show management sections immediately when file is uploaded
                    console.log('ðŸ“‚ Auto-showing management sections on file upload');

                    // Show Category Suggestion if exists (with proper function call)
                    if (window.pendingCategorySuggestion) {
                        const suggestion = window.pendingCategorySuggestion;
                        console.log('   ðŸ’¡ Category Suggestion detected:', suggestion.category, suggestion.subcategory);

                        // Call the function to properly display and populate the suggestion
                        setTimeout(() => {
                            showCategorySuggestion(suggestion.category, suggestion.subcategory);
                            console.log('   âœ… Category Suggestion shown and populated');
                        }, 500);
                    }

                    // Hide Manage Categories section - Category Browser stays visible
                    const manageCategoriesSection = document.getElementById('mainManageCategories');
                    if (manageCategoriesSection) {
                        manageCategoriesSection.style.display = 'none';
                        console.log('   âœ… Manage Categories hidden');
                    }

                    // NOTE: File Manager is NOT auto-shown - user opens it manually from hamburger menu
                    // Category Browser always remains visible for easy access to existing vocabulary

                    return;
                }

                // Continue with actual parsing
                const savedProgress = loadProgress(currentFileName);

                // Check if first line is a header
                let startIndex = 0;
                const firstLine = lines[0].toLowerCase();
                if (firstLine.includes('lang1') || firstLine.includes('lang2') ||
                    firstLine.includes('deutsch') || firstLine.includes('word') ||
                    firstLine.includes('voc')) {
                    startIndex = 1; // Skip header row
                }

                flashcards = lines.slice(startIndex).map((line, index) => {
                    const parts = line.split(detectedSeparator).map(part => part.trim());

                    if (parts.length < 2) return null; // Need at least 2 columns

                    // Use new per-row format detection
                    const detected = detectRowFormat(parts);

                    if (!detected || !detected.lang1 || !detected.lang2) {
                        // Fallback if detection fails
                        console.warn('Detection failed for row:', index, parts);
                        return null;
                    }

                    let lang1 = detected.lang1;
                    let lang1Extended1 = detected.lang1Extended1 || '';
                    let lang1Extended2 = detected.lang1Extended2 || '';
                    let lang1Extended3 = detected.lang1Extended3 || '';
                    let lang2 = detected.lang2;
                    let lang2Extended1 = detected.lang2Extended1 || '';
                    let lang2Extended2 = detected.lang2Extended2 || '';
                    let lang2Extended3 = detected.lang2Extended3 || '';
                    let detail = detected.detail;

                    // Combine multiple examples with | separator for display
                    const lang1Extended = [lang1Extended1, lang1Extended2, lang1Extended3]
                        .filter(ex => ex.trim() !== '')
                        .join(' | ');
                    const lang2Extended = [lang2Extended1, lang2Extended2, lang2Extended3]
                        .filter(ex => ex.trim() !== '')
                        .join(' | ');

                    // Check if we have saved progress for this card
                    const savedCard = savedProgress?.find(s => s.lang1 === lang1 && s.lang2 === lang2);

                    const cardData = {
                        id: index,
                        lang1: lang1,
                        lang1Extended: lang1Extended,
                        lang1Extended1: lang1Extended1,
                        lang1Extended2: lang1Extended2,
                        lang1Extended3: lang1Extended3,
                        lang2: lang2,
                        lang2Extended: lang2Extended,
                        lang2Extended1: lang2Extended1,
                        lang2Extended2: lang2Extended2,
                        lang2Extended3: lang2Extended3,
                        detail: detail,
                        hasExtended: !!(lang1Extended || lang2Extended),
                        learned: savedCard?.learned || false,
                        reviewDate: savedCard?.reviewDate || null,
                        repetitions: savedCard?.repetitions || 0,
                        easeFactor: savedCard?.easeFactor || 2.5,
                        interval: savedCard?.interval || 1,
                        category: currentFileCategory.category || 'Default',
                        subcategory: currentFileCategory.subcategory || ''
                    };

                    // Debug logging for first 3 cards
                    if (index < 3) {
                        console.log(`Card ${index} parsed:`, cardData);
                        console.log(`Card ${index} raw columns:`, {
                            col0: parts[0],
                            col1: parts[1],
                            col2: parts[2],
                            col3: parts[3]
                        });
                    }

                    return cardData;
                }).filter(card => card && card.lang1 && card.lang2);

                if (flashcards.length > 0) {
                    // AUTO-DETECT LANGUAGE CODES for Text-to-Speech (supports cloud voices!)
                    // Sample first 5 cards to determine languages
                    const sampleSize = Math.min(5, flashcards.length);
                    let sourceLangCodes = [];
                    let targetLangCodes = [];

                    for (let i = 0; i < sampleSize; i++) {
                        const card = flashcards[i];
                        const sourceLang = getLanguageCode(card.lang1);
                        const targetLang = getLanguageCode(card.lang2);
                        if (sourceLang) sourceLangCodes.push(sourceLang);
                        if (targetLang) targetLangCodes.push(targetLang);
                    }

                    // Use most common language code from samples (or default)
                    if (sourceLangCodes.length > 0) {
                        detectedSourceLang = sourceLangCodes[0]; // Use first detected
                        console.log('ðŸŽ™ï¸ Detected source language:', detectedSourceLang);
                    }
                    if (targetLangCodes.length > 0) {
                        detectedTargetLang = targetLangCodes[0]; // Use first detected
                        console.log('ðŸŽ™ï¸ Detected target language:', detectedTargetLang);
                    }

                    const dueCount = flashcards.filter(isDueForReview).length;
                    const sepName = detectedSeparator === '\t' ? 'TAB' : detectedSeparator === ',' ? 'COMMA' : detectedSeparator === ';' ? 'SEMICOLON' : 'PIPE';
                    const extCount = flashcards.filter(card => card.hasExtended).length;
                    fileInfo.innerHTML = `<strong>ðŸ“‚ ${currentFileName}</strong><br>âœ… Loaded ${flashcards.length} cards (${dueCount} due for review) | Separator: ${sepName} | Extended: ${extCount}`;
                    currentIndex = 0;
                    filteredCards = [...flashcards];

                    // Check if file already has a category assigned
                    const fileAlreadyCategorized = fileCategories[currentFileName] != null;
                    console.log('ðŸ“‚ File already categorized?', fileAlreadyCategorized);

                    if (fileCategories[currentFileName]) {
                        currentFileCategory = fileCategories[currentFileName];
                        console.log('   Existing category:', currentFileCategory);
                    } else {
                        // DON'T create default category yet - wait for user to accept/reject suggestion
                        currentFileCategory = { category: 'Default', subcategory: '' };
                        console.log('   Using temporary default category (not saved yet)');
                    }

                    updateStats(); // This calls saveProgress() which saves flashcards to localStorage
                    showFlashcard();
                    updateCurrentFileDisplay();

                    console.log('ðŸ’¾ Flashcards saved to localStorage:', currentFileName, flashcards.length, 'cards');

                    // NOW show category suggestion AFTER flashcards are saved
                    console.log('ðŸ” Checking for pending category suggestion...');
                    console.log('   File already categorized?', fileAlreadyCategorized);
                    console.log('   pendingCategorySuggestion:', window.pendingCategorySuggestion);

                    // Show main UI elements FIRST
                    flashcardContainer.style.display = 'block';
                    navigation.style.display = 'flex';
                    stats.style.display = 'block';
                    document.getElementById('practiceModeBtn').style.display = 'block';

                    // Show new UI elements
                    document.getElementById('quickActions').style.display = 'grid';
                    document.getElementById('settingsToggleBtn').style.display = 'flex';
                    document.getElementById('clearFileBtn').style.display = 'inline-block';
                    document.getElementById('viewModeToggle').style.display = 'flex'; // Show view mode toggle

                    // Hide instructions after successful load
                    document.getElementById('instructions').style.display = 'none';

                    // Auto-show management sections ONLY on first file upload (not during re-parse)
                    if (!useManualMapping) {
                        console.log('ðŸ“‚ Auto-showing management sections after file upload');

                        // Show Manage Categories section
                        const manageCategoriesSection = document.getElementById('mainManageCategories');
                        if (manageCategoriesSection) {
                            manageCategoriesSection.style.display = 'block';
                            console.log('   âœ… Manage Categories shown');
                        }

                        // NOTE: File Manager is NOT auto-shown - user opens it manually from hamburger menu
                        // Only Category Suggestion auto-shows on new file upload
                    } else {
                        console.log('ðŸ“‚ Re-parse after format selection - keeping current visibility state');
                    }

                    // Show category suggestion AFTER all UI is visible (ONLY on first upload)
                    if (!useManualMapping) {
                        console.log('ðŸ” Checking pending suggestion. Value:', window.pendingCategorySuggestion);
                        console.log('ðŸ” File already categorized?', fileAlreadyCategorized);
                        console.log('ðŸ” Current fileName:', currentFileName);

                        // ALWAYS show suggestion if one exists (for testing - we can refine later)
                        if (window.pendingCategorySuggestion) {
                            const suggestion = window.pendingCategorySuggestion;
                            console.log('ðŸ“‹ Suggestion found! Showing it now. Category:', suggestion.category, 'Subcategory:', suggestion.subcategory);

                            // Store for later reference
                            window.lastDetectedSuggestion = {
                                category: suggestion.category,
                                subcategory: suggestion.subcategory
                            };

                            window.pendingCategorySuggestion = null; // Clear pending

                            // Simply show the suggestion box (it's now outside category management!)
                            setTimeout(() => {
                                console.log('â° About to call showCategorySuggestion...');
                                showCategorySuggestion(suggestion.category, suggestion.subcategory);
                                console.log('âœ… showCategorySuggestion called');
                            }, 500);
                        } else {
                            console.log('âš ï¸ NO pending suggestion found!');
                            console.log('   This means either:');
                            console.log('   1. No suggestion was detected from filename');
                            console.log('   2. Suggestion was cleared somewhere');
                            console.log('   3. This is a re-parse without suggestion');
                        }
                    } else {
                        console.log('ðŸ” Re-parse mode - skipping suggestion display');

                        // If no suggestion and file is new, save default category now
                        if (!fileAlreadyCategorized) {
                            fileCategories[currentFileName] = currentFileCategory;
                            saveCategories();
                        }
                    }
                } else {
                    fileInfo.textContent = 'âŒ No valid flashcards found in file';
                    document.getElementById('clearFileBtn').style.display = 'none';
                }
            };
            // Explicitly use UTF-8 encoding to support all languages including Persian/Farsi
            reader.readAsText(file, 'UTF-8');
        }

        // Update statistics
        function updateStats() {
            const learned = flashcards.filter(card => card.learned).length;
            const total = flashcards.length;
            const remaining = total - learned;

            learnedCount.textContent = learned;
            remainingCount.textContent = remaining;
            totalCount.textContent = total;
        }

        // Pronounce source language word
        function pronounceGerman(text, onComplete = null) {
            if (!synth) {
                if (onComplete) onComplete();
                return;
            }

            synth.cancel(); // Stop any ongoing speech

            const utterance = new SpeechSynthesisUtterance(text);
            // Use source voice's language or fallback to detected language
            utterance.lang = sourceVoice ? sourceVoice.lang : detectedSourceLang;

            console.log('ðŸŽ¤ Source Speech:', {
                text: text.substring(0, 50) + '...',
                lang: utterance.lang,
                voiceName: sourceVoice ? sourceVoice.name : 'none',
                isVirtual: sourceVoice ? sourceVoice.isVirtual : false
            });

            // Only set voice if it's not virtual (virtual voices use lang code only)
            if (sourceVoice && !sourceVoice.isVirtual) {
                utterance.voice = sourceVoice;
            }
            utterance.rate = speechRate; // User-configurable rate
            utterance.pitch = speechPitch; // User-configurable pitch

            // Event-driven completion: call callback when speech finishes
            let completed = false;
            const safetyTimeout = setTimeout(() => {
                if (!completed && onComplete) {
                    console.log('âš ï¸ Source speech safety timeout triggered');
                    completed = true;
                    onComplete();
                }
            }, 30000); // 30 second safety timeout for very long text

            utterance.onend = () => {
                if (!completed) {
                    completed = true;
                    clearTimeout(safetyTimeout);
                    console.log('âœ… Source speech completed naturally');
                    if (onComplete) onComplete();
                }
            };

            utterance.onerror = (event) => {
                if (!completed) {
                    completed = true;
                    clearTimeout(safetyTimeout);
                    console.error('âŒ Source speech error:', {
                        error: event.error,
                        message: event.message,
                        lang: utterance.lang,
                        voiceName: sourceVoice ? sourceVoice.name : 'none'
                    });

                    // Special warning for Persian/Farsi and other unsupported languages
                    if (utterance.lang.startsWith('fa') || utterance.lang.startsWith('ar')) {
                        console.warn('âš ï¸ WARNING: Your browser may not support ' + utterance.lang + ' text-to-speech.');
                        console.warn('ðŸ“ Suggested solutions:');
                        console.warn('   1. Try Chrome with Google TTS extension installed');
                        console.warn('   2. Use Microsoft Edge with language packs installed');
                        console.warn('   3. Consider using an online TTS service for these languages');
                    }

                    if (onComplete) onComplete(); // Continue even on error
                }
            };

            // Edge browser needs small delay before speaking
            setTimeout(() => {
                synth.speak(utterance);
            }, 10);
        }

        // Pronounce target language word
        function pronounceEnglish(text, onComplete = null) {
            console.log('ðŸŽ¯ pronounceEnglish called with text:', text);
            console.log('   targetVoice:', targetVoice ? targetVoice.name : 'null');
            console.log('   detectedTargetLang:', detectedTargetLang);

            if (!synth) {
                console.error('âŒ synth not available');
                if (onComplete) onComplete();
                return;
            }

            synth.cancel(); // Stop any ongoing speech

            const utterance = new SpeechSynthesisUtterance(text);
            // Use target voice's language or fallback to detected language
            utterance.lang = targetVoice ? targetVoice.lang : detectedTargetLang;
            console.log('   utterance.lang set to:', utterance.lang);

            // Only set voice if it's not virtual (virtual voices use lang code only)
            if (targetVoice && !targetVoice.isVirtual) {
                utterance.voice = targetVoice;
                console.log('   utterance.voice set to:', targetVoice.name);
            } else if (targetVoice && targetVoice.isVirtual) {
                console.log('   Using cloud TTS with lang:', utterance.lang, '(virtual voice)');
            }
            utterance.rate = speechRate; // User-configurable rate
            utterance.pitch = speechPitch; // User-configurable pitch

            // Event-driven completion: call callback when speech finishes
            let completed = false;
            const safetyTimeout = setTimeout(() => {
                if (!completed && onComplete) {
                    console.log('âš ï¸ English speech safety timeout triggered');
                    completed = true;
                    onComplete();
                }
            }, 30000); // 30 second safety timeout for very long text

            utterance.onend = () => {
                if (!completed) {
                    completed = true;
                    clearTimeout(safetyTimeout);
                    console.log('âœ… English speech completed naturally');
                    if (onComplete) onComplete();
                }
            };

            utterance.onerror = (event) => {
                if (!completed) {
                    completed = true;
                    clearTimeout(safetyTimeout);
                    console.error('âŒ Target speech error:', {
                        error: event.error,
                        message: event.message,
                        lang: utterance.lang,
                        voiceName: targetVoice ? targetVoice.name : 'none'
                    });

                    // Special warning for Persian/Farsi and other unsupported languages
                    if (utterance.lang.startsWith('fa') || utterance.lang.startsWith('ar')) {
                        console.warn('âš ï¸ WARNING: Your browser may not support ' + utterance.lang + ' text-to-speech.');
                        console.warn('ðŸ“ Suggested solutions:');
                        console.warn('   1. Try Chrome with Google TTS extension installed');
                        console.warn('   2. Use Microsoft Edge with language packs installed');
                        console.warn('   3. Consider using an online TTS service for these languages');
                    }

                    if (onComplete) onComplete(); // Continue even on error
                }
            };

            // Edge browser needs small delay before speaking
            setTimeout(() => {
                console.log('ðŸ”Š Calling synth.speak() for target language');
                synth.speak(utterance);
            }, 10);
        }

        // Get active card list
        function getActiveCards() {
            if (filterMode === 'unlearned') {
                return flashcards.filter(card => !card.learned);
            } else if (filterMode === 'learned') {
                return flashcards.filter(card => card.learned);
            } else {
                return flashcards;
            }
        }

        // Show current flashcard
        function showFlashcard() {
            filteredCards = getActiveCards();

            if (filteredCards.length === 0) {
                germanWord.textContent = 'No cards available';
                englishWord.textContent = 'Load a CSV file or adjust filter';
                detailBack.style.display = 'none';
                learnedBadge.style.display = 'none';
                return;
            }

            // Adjust index if out of bounds
            if (currentIndex >= filteredCards.length) {
                currentIndex = filteredCards.length - 1;
            }
            if (currentIndex < 0) {
                currentIndex = 0;
            }

            const card = filteredCards[currentIndex];

            // Debug logging
            console.log('Displaying card:', {
                lang1: card.lang1,
                lang1Extended: card.lang1Extended,
                lang2: card.lang2,
                lang2Extended: card.lang2Extended
            });

            germanWord.textContent = card.lang1;
            englishWord.textContent = card.lang2;

            // Show source example (lang1Extended)
            const detailFront = document.getElementById('detailFront');
            if (detailFront) {
                if (card.lang1Extended) {
                    detailFront.textContent = 'ðŸ“ ' + card.lang1Extended;
                    detailFront.style.display = 'block';
                    detailFront.style.whiteSpace = 'pre-line';
                } else {
                    detailFront.style.display = 'none';
                }
            }

            // Show detail and extended content indicators (only English-related content)
            let detailText = '';
            if (card.lang2Extended) {
                detailText += `ðŸ“ ${card.lang2Extended}\n`;
            }
            if (card.detail) {
                detailText += card.detail;
            }

            if (detailText) {
                detailBack.textContent = detailText;
                detailBack.style.display = 'block';
                detailBack.style.whiteSpace = 'pre-line'; // Preserve line breaks
            } else {
                detailBack.style.display = 'none';
            }

            // Show review date info
            if (card.reviewDate && card.repetitions > 0) {
                const reviewDate = new Date(card.reviewDate);
                const daysUntil = Math.ceil((reviewDate - new Date()) / (1000 * 60 * 60 * 24));
                if (daysUntil > 0) {
                    reviewInfo.textContent = `Next review in ${daysUntil} day${daysUntil > 1 ? 's' : ''}`;
                } else if (daysUntil === 0) {
                    reviewInfo.textContent = 'Review due today';
                } else {
                    reviewInfo.textContent = 'Review overdue';
                }
                reviewInfo.style.display = 'block';
            } else {
                reviewInfo.style.display = 'none';
            }

            // Show/hide learned/unlearned badge
            const unlearnedBadge = document.getElementById('unlearnedBadge');
            if (card.learned) {
                learnedBadge.style.display = 'block';
                unlearnedBadge.style.display = 'none';
                learnedBtn.textContent = 'âœ— Unmark Learned';
            } else {
                learnedBadge.style.display = 'none';
                unlearnedBadge.style.display = 'block';
                learnedBtn.textContent = 'âœ“ Mark as Learned';
            }

            // Update card number input and total
            const currentCardInput = document.getElementById('currentCardInput');
            const totalCardsSpan = document.getElementById('totalCards');
            if (currentCardInput) currentCardInput.value = currentIndex + 1;
            if (totalCardsSpan) totalCardsSpan.textContent = filteredCards.length;
            if (currentCardInput) currentCardInput.max = filteredCards.length;

            // Handle English section visibility
            if (alwaysShowMeanings) {
                englishSection.classList.add('revealed');
                revealBtn.style.display = 'none';
            } else {
                englishSection.classList.remove('revealed');
                revealBtn.style.display = 'block';
                revealBtn.textContent = 'ðŸ‘ Show English Meaning';
            }

            // Update button states
            prevBtn.disabled = currentIndex === 0;
            nextBtn.disabled = currentIndex === filteredCards.length - 1;

            // Save progress after displaying card
            saveProgress();
        }

        // Toggle English meaning visibility
        function toggleEnglish() {
            if (englishSection.classList.contains('revealed')) {
                // Currently shown â†’ Hide it
                englishSection.classList.remove('revealed');
                revealBtn.textContent = 'ðŸ‘ Show Target Meaning';
                revealBtn.style.opacity = '1';
            } else {
                // Currently hidden â†’ Show it
                englishSection.classList.add('revealed');
                revealBtn.textContent = 'âœ“ Meaning Shown';
                revealBtn.style.opacity = '0.7';
            }
        }

        // Legacy function name for backward compatibility
        function revealEnglish() {
            toggleEnglish();
        }

        // Auto-play functions
        function startAutoPlay() {
            if (filteredCards.length === 0) return;

            isAutoPlaying = true;
            autoplayBtn.textContent = 'â¸ Pause';
            autoplayBtn.classList.add('playing');

            // Start session stats (only if not already started)
            if (!sessionStartTime) {
                startSessionStats();
            }

            // Start timers if enabled
            if (studyTimerEnabled) {
                startStudyTimer();
            }
            if (sleepTimerEnabled) {
                startSleepTimer();
            }

            // Start recording if enabled
            const recordCheckbox = document.getElementById('recordSession');
            if (recordCheckbox && recordCheckbox.checked) {
                startRecording();
            }

            // Start from current card
            currentRepeat = 0;
            playCurrentCard();
        }

        function stopAutoPlay(reason = 'manual', autoComplete = false) {
            isAutoPlaying = false;
            autoplayBtn.textContent = 'â–¶ Auto-Play';
            autoplayBtn.classList.remove('playing');

            // Clear any pending timeouts
            if (autoplayTimeout) {
                clearTimeout(autoplayTimeout);
                autoplayTimeout = null;
            }

            // Stop any ongoing speech
            if (synth) {
                synth.cancel();
            }

            // Check if recording was enabled (either actively recording or has recorded data)
            const recordCheckbox = document.getElementById('recordSession');
            const wasRecordingEnabled = recordCheckbox && recordCheckbox.checked;
            const hasRecordingData = isRecording || (mediaRecorder && mediaRecorder.state !== 'inactive') || recordedChunks.length > 0;

            // Handle recording based on stop reason
            if (wasRecordingEnabled && hasRecordingData) {
                if (reason === 'manual' && !autoComplete) {
                    // Manual stop - ask user if they want to save recording
                    const saveRecording = confirm('Do you want to save the recorded audio?\n\nClick OK to save, Cancel to discard.');
                    if (saveRecording) {
                        stopRecording();
                        alert('âœ“ Recording saved! You can download or play it from the Auto-Play Settings.');
                    } else {
                        // Discard recording
                        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                            mediaRecorder.stop();
                            mediaRecorder.stream.getTracks().forEach(track => track.stop());
                        }
                        if (recordingTimerInterval) {
                            clearInterval(recordingTimerInterval);
                            recordingTimerInterval = null;
                        }
                        document.getElementById('recordingControls').style.display = 'none';
                        isRecording = false;
                        recordedChunks = [];
                        alert('Recording discarded.');
                    }
                } else {
                    // Automatic end or timer end - always save recording
                    stopRecording();
                    if (reason === 'complete') {
                        alert('âœ… Auto-play completed! Recording has been saved automatically.\n\nYou can download or play it from the Auto-Play Settings.');
                    }
                }
            }

            // Stop timers (but keep session stats running if manually paused)
            if (reason === 'manual') {
                // Only stop study/sleep timers, keep session stats running
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                timerEndTime = null;
                document.getElementById('timerDisplay').style.display = 'none';
            } else {
                // Stop all timers including session stats for timer/sleep/complete
                stopAllTimers();
            }

            // Show appropriate message (only if recording wasn't already handled)
            const wasRecording = recordedAudioBlob !== null;
            if (reason === 'timer') {
                if (wasRecording) {
                    alert('â° Time\'s up! Auto-play stopped.\nRecording has been saved automatically.');
                } else {
                    alert('â° Time\'s up! Auto-play stopped.');
                }
            } else if (reason === 'sleep') {
                if (wasRecording) {
                    alert('ðŸ“š Sleep timer complete. Good night!\nRecording has been saved automatically.');
                } else {
                    alert('ðŸ“š Sleep timer complete. Good night!');
                }
            } else if (reason === 'complete' && !wasRecording) {
                alert('âœ… Auto-play completed! Reached the end of cards.');
            }
        }

        function playCurrentCard() {
            if (!isAutoPlaying || filteredCards.length === 0) return;

            const card = filteredCards[currentIndex];

            // Always reveal English in auto-play mode
            if (!alwaysShowMeanings) {
                revealEnglish();
            }

            // Increment cards reviewed (only once per card, not per repeat)
            if (currentSourceRepeat === 0 && currentTargetRepeat === 0) {
                cardsReviewedCount++;
                updateSessionStats();
            }

            // Determine what to pronounce
            const germanText = readExtendedContent && card.lang1Extended ? card.lang1Extended : card.lang1;
            const englishText = readExtendedContent && card.lang2Extended ? card.lang2Extended : card.lang2;

            // Step 1: Pronounce source language and handle repeats
            pronounceGerman(germanText, () => {
                if (!isAutoPlaying) return;

                currentSourceRepeat++;

                // Check if we need to repeat source language
                if (currentSourceRepeat < repeatSourceCount) {
                    // Repeat source language with a short delay
                    autoplayTimeout = setTimeout(() => {
                        if (!isAutoPlaying) return;
                        playSourceLanguage(germanText);
                    }, 500);
                } else {
                    // Source repeats complete, move to target language
                    autoplayTimeout = setTimeout(() => {
                        if (!isAutoPlaying) return;

                        if (autoplayEnglishEnabled) {
                            playTargetLanguage(englishText);
                        } else {
                            // If target not enabled, move to next card
                            autoplayTimeout = setTimeout(() => {
                                if (!isAutoPlaying) return;
                                handleCardCompletion();
                            }, delayBeforeNext);
                        }
                    }, delayBetweenLangs);
                }
            });
        }

        function playSourceLanguage(germanText) {
            if (!isAutoPlaying) return;

            pronounceGerman(germanText, () => {
                if (!isAutoPlaying) return;

                currentSourceRepeat++;

                if (currentSourceRepeat < repeatSourceCount) {
                    // Continue repeating source
                    autoplayTimeout = setTimeout(() => {
                        if (!isAutoPlaying) return;
                        playSourceLanguage(germanText);
                    }, 500);
                } else {
                    // Source repeats complete, move to target
                    autoplayTimeout = setTimeout(() => {
                        if (!isAutoPlaying) return;

                        const card = filteredCards[currentIndex];
                        const englishText = readExtendedContent && card.lang2Extended ? card.lang2Extended : card.lang2;

                        if (autoplayEnglishEnabled) {
                            playTargetLanguage(englishText);
                        } else {
                            autoplayTimeout = setTimeout(() => {
                                if (!isAutoPlaying) return;
                                handleCardCompletion();
                            }, delayBeforeNext);
                        }
                    }, delayBetweenLangs);
                }
            });
        }

        function playTargetLanguage(englishText) {
            if (!isAutoPlaying) return;

            pronounceEnglish(englishText, () => {
                if (!isAutoPlaying) return;

                currentTargetRepeat++;

                if (currentTargetRepeat < repeatTargetCount) {
                    // Continue repeating target
                    autoplayTimeout = setTimeout(() => {
                        if (!isAutoPlaying) return;
                        playTargetLanguage(englishText);
                    }, 500);
                } else {
                    // All repeats complete, move to next card
                    autoplayTimeout = setTimeout(() => {
                        if (!isAutoPlaying) return;
                        handleCardCompletion();
                    }, delayBeforeNext);
                }
            });
        }

        function handleCardCompletion() {
            if (!isAutoPlaying) return;

            // Reset repeat counters
            currentSourceRepeat = 0;
            currentTargetRepeat = 0;

            moveToNextCardInAutoPlay();
        }

        function moveToNextCardInAutoPlay() {
            if (!isAutoPlaying) return;

            // Move to next card
            if (currentIndex < filteredCards.length - 1) {
                currentIndex++;
                showFlashcard();
                playCurrentCard();
            } else {
                // Reached end
                if (loopModeEnabled) {
                    // Loop back to beginning
                    currentIndex = 0;
                    showFlashcard();
                    playCurrentCard();
                } else {
                    // Stop auto-play with 'complete' reason to auto-save recording
                    stopAutoPlay('complete', true);
                }
            }
        }

        // ============================================
        // PROGRESS TRACKING & RESET FUNCTIONS
        // ============================================

        // Save current practice progress (position in cards)
        // Saves to memory + localStorage (small data, no quota issues)
        function saveProgress() {
            if (!currentFileName) return;

            const progressData = {
                cardIndex: currentIndex,
                transcriptIndex: transcriptCurrentIndex,
                timestamp: Date.now(),
                totalCards: filteredCards.length
            };

            // Update in-memory progress cache
            progressDataCache[currentFileName] = progressData;

            // Also save to localStorage as backup (survives page refresh)
            // Progress is tiny data (<1KB), won't cause quota issues
            try {
                localStorage.setItem(`progress_${currentFileName}`, JSON.stringify(progressData));
            } catch (e) {
                // Silently fail if localStorage is full
            }

            // Progress also syncs to Firebase when flashcard data is saved
            // (progressDataCache is included in Firebase sync structure)
        }

        // Load saved progress for current file
        function loadProgress() {
            if (!currentFileName) return null;

            let progressData = null;

            // 1. Check in-memory cache first (fastest)
            if (progressDataCache[currentFileName]) {
                progressData = progressDataCache[currentFileName];
                console.log('ðŸ“‚ Progress loaded from memory:', progressData);
            }
            // 2. Fall back to localStorage (page refresh)
            else {
                try {
                    const saved = localStorage.getItem(`progress_${currentFileName}`);
                    if (saved) {
                        progressData = JSON.parse(saved);
                        progressDataCache[currentFileName] = progressData; // Update memory cache
                        console.log('ðŸ“‚ Progress loaded from localStorage:', progressData);
                    }
                } catch (e) {
                    // Ignore corrupted data
                }
            }

            if (progressData) {
                applyProgress(progressData);
                return progressData;
            }

            console.log('No saved progress found for', currentFileName);
            return null;
        }

        // Apply progress data to current session
        function applyProgress(progressData) {
            if (!progressData) return;

            // Restore card mode position
            if (typeof progressData.cardIndex === 'number' && progressData.cardIndex >= 0) {
                currentIndex = Math.min(progressData.cardIndex, filteredCards.length - 1);
                console.log('âœ“ Restored card position:', currentIndex);
            }

            // Restore transcript mode position
            if (typeof progressData.transcriptIndex === 'number' && progressData.transcriptIndex >= 0) {
                transcriptCurrentIndex = Math.min(progressData.transcriptIndex, filteredCards.length - 1);
                console.log('âœ“ Restored transcript position:', transcriptCurrentIndex);
            }

            // Update UI to reflect restored position
            if (flashcardViewMode === 'card') {
                showFlashcard();
            } else if (flashcardViewMode === 'transcript') {
                // Update transcript navigation and highlight
                updateTranscriptProgress();
                highlightTranscriptPair(transcriptCurrentIndex);
            }
        }

        // Reset to beginning - works for both card and transcript modes
        function resetToBeginning(mode) {
            if (mode === 'card') {
                currentIndex = 0;
                showFlashcard();
                console.log('â†º Card mode reset to beginning');

                // Stop autoplay if running
                if (isAutoPlaying) {
                    stopAutoPlay('manual');
                }
            } else if (mode === 'transcript') {
                transcriptCurrentIndex = 0;
                updateTranscriptDisplay();
                console.log('â†º Transcript mode reset to beginning');

                // Stop transcript playback if running
                if (transcriptPlaying) {
                    stopTranscriptPlayback();
                }
            }

            // Save the reset progress
            saveProgress();

            // Show feedback
            const message = mode === 'card' ?
                'Reset to first card' :
                'Reset to first transcript item';

            // Update progress display if it exists
            const progressEl = mode === 'card' ?
                document.getElementById('progress') :
                document.getElementById('transcriptProgress');

            if (progressEl) {
                const originalText = progressEl.textContent;
                progressEl.textContent = `â†º ${message}`;
                progressEl.style.color = '#06b6d4';
                setTimeout(() => {
                    progressEl.textContent = originalText;
                    progressEl.style.color = '';
                }, 2000);
            }
        }

        // Timer functions
        function startStudyTimer() {
            const duration = parseInt(document.getElementById('studyDuration').value);
            timerEndTime = Date.now() + (duration * 60 * 1000);
            document.getElementById('timerDisplay').style.display = 'block';
            updateTimerDisplay();
            timerInterval = setInterval(() => {
                updateTimerDisplay();
                if (Date.now() >= timerEndTime) {
                    // Stop either card mode or transcript mode
                    if (flashcardViewMode === 'transcript') {
                        stopTranscriptPlayback();
                    } else {
                        stopAutoPlay('timer', true); // Auto-save recording
                    }
                }
            }, 1000);
        }

        function startSleepTimer() {
            const duration = parseInt(document.getElementById('sleepDuration').value);
            timerEndTime = Date.now() + (duration * 60 * 1000);
            document.getElementById('timerDisplay').style.display = 'block';
            updateTimerDisplay();
            timerInterval = setInterval(() => {
                updateTimerDisplay();
                if (Date.now() >= timerEndTime) {
                    // Stop either card mode or transcript mode
                    if (flashcardViewMode === 'transcript') {
                        stopTranscriptPlayback();
                    } else {
                        stopAutoPlay('sleep', true); // Auto-save recording
                    }
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            if (!timerEndTime) return;
            const remaining = Math.max(0, timerEndTime - Date.now());
            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            document.getElementById('timerText').textContent =
                `â±ï¸ Time Remaining: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function stopAllTimers() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
            timerEndTime = null;
            document.getElementById('timerDisplay').style.display = 'none';
        }

        // Session stats functions
        function startSessionStats() {
            // Only initialize if starting fresh (not resuming)
            if (!sessionStartTime) {
                sessionStartTime = Date.now();
                cardsReviewedCount = 0;
                document.getElementById('sessionStart').textContent = new Date().toLocaleTimeString();
            }

            document.getElementById('sessionStats').style.display = 'block';
            updateSessionStats();

            // Clear any existing interval before starting new one
            if (statsInterval) {
                clearInterval(statsInterval);
            }
            statsInterval = setInterval(updateSessionStats, 1000);
        }

        function updateSessionStats() {
            if (!sessionStartTime) return;

            const elapsed = Date.now() - sessionStartTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);

            document.getElementById('cardsReviewed').textContent = cardsReviewedCount;
            document.getElementById('timeStudying').textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;

            const cardsPerMin = minutes > 0 ? (cardsReviewedCount / minutes).toFixed(1) : '0.0';
            document.getElementById('cardsPerMinute').textContent = cardsPerMin;
        }

        // Recording functions
        async function startRecording() {
            try {
                // Request permission to capture tab audio
                const stream = await navigator.mediaDevices.getDisplayMedia({
                    video: true, // Required for tab capture
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                // Stop video track as we only need audio
                const videoTrack = stream.getVideoTracks()[0];
                if (videoTrack) videoTrack.stop();

                recordedChunks = [];
                mediaRecorder = new MediaRecorder(stream);

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    recordedAudioBlob = new Blob(recordedChunks, { type: 'audio/webm' });
                    const audioUrl = URL.createObjectURL(recordedAudioBlob);
                    document.getElementById('recordedAudio').src = audioUrl;
                    document.getElementById('recordedAudioSection').style.display = 'block';
                    isRecording = false;
                };

                mediaRecorder.start();
                isRecording = true;
                recordingStartTime = Date.now();

                // Show recording controls
                document.getElementById('recordingControls').style.display = 'block';

                // Start recording timer
                recordingTimerInterval = setInterval(updateRecordingTimer, 1000);
            } catch (err) {
                console.error('Error starting recording:', err);
                alert('Unable to start recording. Please make sure you grant permission to capture tab audio.');
                isRecording = false;
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();

                // Stop all tracks
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }

            if (recordingTimerInterval) {
                clearInterval(recordingTimerInterval);
                recordingTimerInterval = null;
            }

            document.getElementById('recordingControls').style.display = 'none';
        }

        function updateRecordingTimer() {
            if (!recordingStartTime) return;

            const elapsed = Date.now() - recordingStartTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);

            document.getElementById('recordingTime').textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function downloadRecording() {
            if (!recordedAudioBlob) return;

            const url = URL.createObjectURL(recordedAudioBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `flashcard-session-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.webm`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function playRecording() {
            const audio = document.getElementById('recordedAudio');
            audio.style.display = 'block';
            audio.play();
        }

        // Focus Mode functions
        function enterFocusMode() {
            document.getElementById('focusMode').style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }

        function exitFocusMode() {
            document.getElementById('focusMode').style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // Audio pronunciation - German
        audioBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (filteredCards.length > 0) {
                const card = filteredCards[currentIndex];
                pronounceGerman(card.lang1);
            }
        });

        // Audio pronunciation - English
        audioBtnEnglish.addEventListener('click', (e) => {
            e.stopPropagation();
            if (filteredCards.length > 0) {
                const card = filteredCards[currentIndex];
                pronounceEnglish(card.lang2);
            }
        });

        // Reveal button click (now works as toggle)
        revealBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleEnglish();
        });

        // Always show meanings checkbox
        alwaysShowMeaningsCheckbox.addEventListener('change', (e) => {
            alwaysShowMeanings = e.target.checked;
            showFlashcard(); // Refresh current card
        });

        // Read extended content checkbox
        document.getElementById('readExtendedContent').addEventListener('change', (e) => {
            readExtendedContent = e.target.checked;
        });

        // Auto-play button
        autoplayBtn.addEventListener('click', () => {
            if (isAutoPlaying) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        });

        // Auto-play English checkbox
        autoplayEnglishCheckbox.addEventListener('change', (e) => {
            autoplayEnglishEnabled = e.target.checked;
        });

        // Delay sliders
        delayBetweenSlider.addEventListener('input', (e) => {
            delayBetweenLangs = parseInt(e.target.value);
            delayBetweenValue.textContent = (delayBetweenLangs / 1000).toFixed(1) + 's';
        });

        delayNextSlider.addEventListener('input', (e) => {
            delayBeforeNext = parseInt(e.target.value);
            delayNextValue.textContent = (delayBeforeNext / 1000).toFixed(1) + 's';
        });

        // Voice selection handlers
        document.getElementById('sourceVoiceSelect').addEventListener('change', (e) => {
            // Get sorted voices (same sorting as in loadVoices)
            const sortedVoices = [...allVoices].sort((a, b) => {
                const aIsGoogle = a.name.toLowerCase().includes('google');
                const bIsGoogle = b.name.toLowerCase().includes('google');
                const aIsMicrosoft = a.name.toLowerCase().includes('microsoft');
                const bIsMicrosoft = b.name.toLowerCase().includes('microsoft');
                if (aIsGoogle && !bIsGoogle) return -1;
                if (!aIsGoogle && bIsGoogle) return 1;
                if (aIsMicrosoft && !bIsMicrosoft) return -1;
                if (!aIsMicrosoft && bIsMicrosoft) return 1;
                return a.lang.localeCompare(b.lang);
            });
            sourceVoice = sortedVoices[parseInt(e.target.value)];
            if (sourceVoice) {
                updateVoiceInfo('source', sourceVoice);
                console.log('Source voice changed to:', sourceVoice.name);
            } else {
                console.error('âŒ Source voice not found at index:', e.target.value);
            }
        });

        document.getElementById('targetVoiceSelect').addEventListener('change', (e) => {
            // Get sorted voices (same sorting as in loadVoices)
            const sortedVoices = [...allVoices].sort((a, b) => {
                const aIsGoogle = a.name.toLowerCase().includes('google');
                const bIsGoogle = b.name.toLowerCase().includes('google');
                const aIsMicrosoft = a.name.toLowerCase().includes('microsoft');
                const bIsMicrosoft = b.name.toLowerCase().includes('microsoft');
                if (aIsGoogle && !bIsGoogle) return -1;
                if (!aIsGoogle && bIsGoogle) return 1;
                if (aIsMicrosoft && !bIsMicrosoft) return -1;
                if (!aIsMicrosoft && bIsMicrosoft) return 1;
                return a.lang.localeCompare(b.lang);
            });
            targetVoice = sortedVoices[parseInt(e.target.value)];
            if (targetVoice) {
                updateVoiceInfo('target', targetVoice);
                console.log('Target voice changed to:', targetVoice.name);
            } else {
                console.error('âŒ Target voice not found at index:', e.target.value);
            }
        });

        // Gender-based voice selection handlers - WRAPPED IN FUNCTION FOR DOMContentLoaded
        function initializeVoiceSelectionHandlers() {
            const germanGenderSelect = document.getElementById('germanGenderSelect');
            const englishGenderSelect = document.getElementById('englishGenderSelect');

            if (germanGenderSelect) {
                germanGenderSelect.addEventListener('change', (e) => {
                    const gender = e.target.value;
                    // Get voices for source voice's language
                    const sourceLang = sourceVoice ? sourceVoice.lang.split('-')[0] : 'de';
                    const languageVoices = allVoices.filter(voice => voice.lang.startsWith(sourceLang));

                    // Try to find a voice matching the gender preference
                    let selectedVoice;
                    if (gender === 'female') {
                        // Female voices often have these patterns
                        selectedVoice = languageVoices.find(v =>
                            v.name.toLowerCase().includes('katja') ||
                            v.name.toLowerCase().includes('hedda') ||
                            v.name.toLowerCase().includes('female') ||
                            v.name.toLowerCase().includes('woman')
                        ) || languageVoices.find(v => v.name.toLowerCase().includes('google')) || languageVoices[0];
                    } else {
                        // Male voices
                        selectedVoice = languageVoices.find(v =>
                            v.name.toLowerCase().includes('stefan') ||
                            v.name.toLowerCase().includes('male') ||
                            v.name.toLowerCase().includes('man')
                        ) || languageVoices[1] || languageVoices[0];
                    }

                    if (selectedVoice) {
                        sourceVoice = selectedVoice;
                        // Update the advanced dropdown to match
                        const sortedVoices = [...allVoices].sort((a, b) => {
                            const aIsGoogle = a.name.toLowerCase().includes('google');
                            const bIsGoogle = b.name.toLowerCase().includes('google');
                            const aIsMicrosoft = a.name.toLowerCase().includes('microsoft');
                            const bIsMicrosoft = b.name.toLowerCase().includes('microsoft');
                            if (aIsGoogle && !bIsGoogle) return -1;
                            if (!aIsGoogle && bIsGoogle) return 1;
                            if (aIsMicrosoft && !bIsMicrosoft) return -1;
                            if (!aIsMicrosoft && bIsMicrosoft) return 1;
                            return a.lang.localeCompare(b.lang);
                        });
                        const voiceIndex = sortedVoices.indexOf(selectedVoice);
                        const sourceVoiceSelect = document.getElementById('sourceVoiceSelect');
                        if (sourceVoiceSelect) {
                            sourceVoiceSelect.value = voiceIndex;
                        }
                        updateVoiceInfo('source', sourceVoice);
                        console.log('Source voice changed to:', sourceVoice.name, '(Gender:', gender + ')');
                    }
                });
            }

            if (englishGenderSelect) {
                englishGenderSelect.addEventListener('change', (e) => {
                    const gender = e.target.value;
                    // Get voices for target voice's language
                    const targetLang = targetVoice ? targetVoice.lang.split('-')[0] : 'en';
                    const languageVoices = allVoices.filter(voice => voice.lang.startsWith(targetLang));

                    // Try to find a voice matching the gender preference
                    let selectedVoice;
                    if (gender === 'male') {
                        // Male voices often have these patterns
                        selectedVoice = languageVoices.find(v =>
                            v.name.toLowerCase().includes('david') ||
                            v.name.toLowerCase().includes('mark') ||
                            v.name.toLowerCase().includes('male') ||
                            v.name.toLowerCase().includes('man')
                        ) || languageVoices.find(v => v.name.toLowerCase().includes('google')) || languageVoices[0];
                    } else {
                        // Female voices
                        selectedVoice = languageVoices.find(v =>
                            v.name.toLowerCase().includes('zira') ||
                            v.name.toLowerCase().includes('female') ||
                            v.name.toLowerCase().includes('woman')
                        ) || languageVoices[1] || languageVoices[0];
                    }

                    if (selectedVoice) {
                        targetVoice = selectedVoice;
                        // Update the advanced dropdown to match
                        const sortedVoices = [...allVoices].sort((a, b) => {
                            const aIsGoogle = a.name.toLowerCase().includes('google');
                            const bIsGoogle = b.name.toLowerCase().includes('google');
                            const aIsMicrosoft = a.name.toLowerCase().includes('microsoft');
                            const bIsMicrosoft = b.name.toLowerCase().includes('microsoft');
                            if (aIsGoogle && !bIsGoogle) return -1;
                            if (!aIsGoogle && bIsGoogle) return 1;
                            if (aIsMicrosoft && !bIsMicrosoft) return -1;
                            if (!aIsMicrosoft && bIsMicrosoft) return 1;
                            return a.lang.localeCompare(b.lang);
                        });
                        const voiceIndex = sortedVoices.indexOf(selectedVoice);
                        const targetVoiceSelect = document.getElementById('targetVoiceSelect');
                        if (targetVoiceSelect) {
                            targetVoiceSelect.value = voiceIndex;
                        }
                        updateVoiceInfo('target', targetVoice);
                        console.log('Target voice changed to:', targetVoice.name, '(Gender:', gender + ')');
                    }
                });
            }
        }

        // Speech rate handler
        document.getElementById('speechRate').addEventListener('input', (e) => {
            speechRate = parseFloat(e.target.value);
            document.getElementById('speechRateValue').textContent = speechRate.toFixed(1) + 'x';
        });

        // Pitch handler
        document.getElementById('speechPitch').addEventListener('input', (e) => {
            speechPitch = parseFloat(e.target.value);
            document.getElementById('speechPitchValue').textContent = speechPitch.toFixed(1);
        });

        // Advanced features event listeners - WRAPPED IN FUNCTION FOR DOMContentLoaded
        function initializeAdvancedFeatures() {
            const loopModeCheckbox = document.getElementById('loopMode');
            const repeatSourceSelect = document.getElementById('repeatSourceCount');
            const repeatTargetSelect = document.getElementById('repeatTargetCount');
            const studyTimerCheckbox = document.getElementById('studyTimer');
            const sleepTimerCheckbox = document.getElementById('sleepTimer');

            if (loopModeCheckbox) {
                loopModeCheckbox.addEventListener('change', (e) => {
                    loopModeEnabled = e.target.checked;
                    console.log('Loop Mode:', loopModeEnabled);
                });
            }

            if (repeatSourceSelect) {
                repeatSourceSelect.addEventListener('change', (e) => {
                    repeatSourceCount = parseInt(e.target.value);
                    console.log('Repeat Source Count:', repeatSourceCount);
                });
            }

            if (repeatTargetSelect) {
                repeatTargetSelect.addEventListener('change', (e) => {
                    repeatTargetCount = parseInt(e.target.value);
                    console.log('Repeat Target Count:', repeatTargetCount);
                });
            }

            if (studyTimerCheckbox) {
                studyTimerCheckbox.addEventListener('change', (e) => {
                    studyTimerEnabled = e.target.checked;
                    console.log('Study Timer:', studyTimerEnabled);
                    if (!e.target.checked && timerInterval) {
                        stopAllTimers();
                    }
                });
            }

            if (sleepTimerCheckbox) {
                sleepTimerCheckbox.addEventListener('change', (e) => {
                    sleepTimerEnabled = e.target.checked;
                    console.log('Sleep Timer:', sleepTimerEnabled);
                    if (!e.target.checked && timerInterval) {
                        stopAllTimers();
                    }
                });
            }
        }

        // Accordion toggle function
        function toggleAccordion(header) {
            const content = header.nextElementSibling;
            const wasActive = header.classList.contains('active');

            // Close all accordions first (optional - remove if you want multiple open)
            // document.querySelectorAll('.accordion-header').forEach(h => {
            //     h.classList.remove('active');
            //     h.nextElementSibling.classList.remove('active');
            // });

            // Toggle current accordion
            if (wasActive) {
                header.classList.remove('active');
                content.classList.remove('active');
            } else {
                header.classList.add('active');
                content.classList.add('active');

                // Auto-scroll to make the expanded section visible
                setTimeout(() => {
                    const settingsMenu = document.getElementById('settingsMenu');
                    const headerRect = header.getBoundingClientRect();
                    const menuRect = settingsMenu.getBoundingClientRect();

                    // Check if header is above the visible area
                    if (headerRect.top < menuRect.top) {
                        header.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }, 100);
            }
        }

        // Settings menu toggle
        document.getElementById('settingsToggleBtn').addEventListener('click', function() {
            const menu = document.getElementById('settingsMenu');
            const isVisible = menu.style.display === 'block';

            if (isVisible) {
                menu.style.display = 'none';
                this.classList.remove('active');
            } else {
                menu.style.display = 'block';
                this.classList.add('active');
            }
        });

        // Focus Mode button
        document.getElementById('focusModeBtn').addEventListener('click', () => {
            enterFocusMode();
            // Clone the current flashcard to focus mode
            const mainCard = document.getElementById('flashcard');
            const focusCard = document.getElementById('focusFlashcard');
            focusCard.innerHTML = mainCard.innerHTML;
        });

        // Navigation
        prevBtn.addEventListener('click', () => {
            stopAutoPlay(); // Stop auto-play on manual navigation
            if (currentIndex > 0) {
                currentIndex--;
                showFlashcard();
            }
        });

        nextBtn.addEventListener('click', () => {
            stopAutoPlay(); // Stop auto-play on manual navigation
            if (currentIndex < filteredCards.length - 1) {
                currentIndex++;
                showFlashcard();
            }
        });

        // Jump to specific card by entering card number
        const currentCardInput = document.getElementById('currentCardInput');
        let jumpTimeout = null;

        if (currentCardInput) {
            const jumpToCard = () => {
                stopAutoPlay(); // Stop auto-play on manual navigation
                const cardNumber = parseInt(currentCardInput.value);

                // Validate input
                if (isNaN(cardNumber) || cardNumber < 1) {
                    currentCardInput.value = currentIndex + 1;
                    alert('âš ï¸ Please enter a valid card number (minimum: 1)');
                    return;
                }

                if (cardNumber > filteredCards.length) {
                    currentCardInput.value = currentIndex + 1;
                    alert(`âš ï¸ Card number cannot exceed ${filteredCards.length}`);
                    return;
                }

                // Jump to the card (convert to 0-based index)
                currentIndex = cardNumber - 1;
                showFlashcard();
            };

            // Auto-update as you type (with 800ms delay after you stop typing)
            currentCardInput.addEventListener('input', () => {
                // Clear previous timeout
                if (jumpTimeout) clearTimeout(jumpTimeout);

                // Set new timeout - updates 800ms after you stop typing
                jumpTimeout = setTimeout(() => {
                    jumpToCard();
                }, 800);
            });

            // Also handle Enter key for immediate jump
            currentCardInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    if (jumpTimeout) clearTimeout(jumpTimeout);
                    jumpToCard();
                }
            });

            // Handle blur (clicking outside) for immediate jump
            currentCardInput.addEventListener('blur', () => {
                if (jumpTimeout) clearTimeout(jumpTimeout);
                jumpToCard();
            });
        }

        // Shuffle cards
        shuffleBtn.addEventListener('click', () => {
            for (let i = flashcards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [flashcards[i], flashcards[j]] = [flashcards[j], flashcards[i]];
            }
            currentIndex = 0;
            showFlashcard();
        });

        // Mark as learned/unlearned
        learnedBtn.addEventListener('click', () => {
            if (filteredCards.length === 0) return;

            // First reveal the English meaning if not visible
            if (!alwaysShowMeanings && !englishSection.classList.contains('revealed')) {
                revealEnglish();
                // Give user a moment to see the meaning before marking
                setTimeout(() => {
                    markCardAsLearned();
                }, 300);
            } else {
                markCardAsLearned();
            }
        });

        // Mark as unlearned button
        const unlearnedBtn = document.getElementById('unlearnedBtn');
        unlearnedBtn.addEventListener('click', () => {
            if (filteredCards.length === 0) return;

            // First reveal the English meaning if not visible
            if (!alwaysShowMeanings && !englishSection.classList.contains('revealed')) {
                revealEnglish();
                // Give user a moment to see the meaning before marking
                setTimeout(() => {
                    markCardAsUnlearned();
                }, 300);
            } else {
                markCardAsUnlearned();
            }
        });

        function markCardAsLearned() {
            const card = filteredCards[currentIndex];

            if (!card.learned) {
                // Mark as learned and apply spaced repetition
                // Quality 4 = good recall (default when marking as learned)
                const reviewData = calculateNextReview(card, 4);
                card.learned = true;
                card.repetitions = reviewData.repetitions;
                card.easeFactor = reviewData.easeFactor;
                card.interval = reviewData.interval;
                card.reviewDate = reviewData.reviewDate;
            } else {
                // Unmark as learned and reset spaced repetition
                card.learned = false;
                card.repetitions = 0;
                card.interval = 1;
                card.reviewDate = null;
            }

            updateStats();
            showFlashcard();

            // Auto-advance to next unlearned card if in "show only unlearned" mode
            if (showOnlyUnlearned && card.learned) {
                if (filteredCards.length > 0) {
                    showFlashcard();
                }
            }
        }

        function markCardAsUnlearned() {
            const card = filteredCards[currentIndex];

            // Always mark as unlearned and reset spaced repetition
            card.learned = false;
            card.repetitions = 0;
            card.interval = 1;
            card.reviewDate = null;

            updateStats();
            showFlashcard();
            saveProgress();
        }

        // Repeat button - show dropdown
        const repeatDropdown = document.getElementById('repeatDropdown');

        repeatBtn.addEventListener('click', (e) => {
            if (filteredCards.length === 0) return;
            e.stopPropagation();
            repeatDropdown.classList.toggle('show');
        });

        // Handle repeat dropdown item clicks
        document.querySelectorAll('.repeat-dropdown-item').forEach(item => {
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                const action = item.getAttribute('data-action');
                repeatDropdown.classList.remove('show');

                // Stop any ongoing auto-play
                if (isAutoPlaying) {
                    stopAutoPlay('manual');
                }

                switch (action) {
                    case 'all':
                        // Repeat all cards
                        currentIndex = 0;
                        filteredCards = [...flashcards];
                        showFlashcard();
                        updateStats();
                        alert('âœ… Repeating all cards!\n\nStarting from the first card.');
                        break;

                    case 'learned':
                        // Repeat marked as learned
                        const learnedCards = flashcards.filter(card => card.learned === true);
                        if (learnedCards.length === 0) {
                            alert('âš ï¸ No learned cards found!');
                            return;
                        }
                        currentIndex = 0;
                        filteredCards = learnedCards;
                        showFlashcard();
                        updateStats();
                        alert(`âœ… Repeating ${learnedCards.length} learned cards!\n\nStarting from the first learned card.`);
                        break;

                    case 'unlearned':
                        // Repeat marked as unlearned
                        const unlearnedCards = flashcards.filter(card => card.learned === false);
                        if (unlearnedCards.length === 0) {
                            alert('âš ï¸ No unlearned cards found!');
                            return;
                        }
                        currentIndex = 0;
                        filteredCards = unlearnedCards;
                        showFlashcard();
                        updateStats();
                        alert(`âœ… Repeating ${unlearnedCards.length} unlearned cards!\n\nStarting from the first unlearned card.`);
                        break;

                    case 'current':
                        // Repeat current card (replay audio)
                        const card = filteredCards[currentIndex];

                        // Pronounce the source word
                        if (card.lang1) {
                            speakText(card.lang1, sourceLang);
                        }

                        // After delay, pronounce the target word if visible
                        setTimeout(() => {
                            if (englishSection.classList.contains('revealed') && card.lang2) {
                                speakText(card.lang2, targetLang);
                            }
                        }, parseInt(delayBetween.value));

                        // Visual feedback
                        repeatBtn.style.transform = 'scale(0.95)';
                        setTimeout(() => {
                            repeatBtn.style.transform = 'scale(1)';
                        }, 200);
                        break;
                }
            });
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.repeat-dropdown')) {
                repeatDropdown.classList.remove('show');
            }
        });

        // Delete current record
        deleteRecordBtn.addEventListener('click', () => {
            if (filteredCards.length === 0) return;

            // Get current card
            const card = filteredCards[currentIndex];

            // Create confirmation message with card details
            const confirmMessage = `âš ï¸ DELETE CONFIRMATION âš ï¸\n\n` +
                `Are you sure you want to permanently delete this flashcard?\n\n` +
                `ðŸ“– Source: ${card.lang1 || 'N/A'}\n` +
                `   Example: ${card.lang1Extended || 'N/A'}\n\n` +
                `ðŸŽ¯ Target: ${card.lang2 || 'N/A'}\n` +
                `   Example: ${card.lang2Extended || 'N/A'}\n\n` +
                `âš ï¸ This action CANNOT be undone!\n` +
                `The record will be removed from your file.`;

            if (confirm(confirmMessage)) {
                // Stop any ongoing auto-play
                if (isAutoPlaying) {
                    stopAutoPlay('manual');
                }

                // Find the card in the original flashcards array
                const originalIndex = flashcards.findIndex(c =>
                    c.lang1 === card.lang1 &&
                    c.lang2 === card.lang2 &&
                    c.lang1Extended === card.lang1Extended &&
                    c.lang2Extended === card.lang2Extended
                );

                if (originalIndex !== -1) {
                    // Remove from original array
                    flashcards.splice(originalIndex, 1);

                    // Save the updated flashcards to localStorage
                    saveProgress();

                    // Sync to cloud immediately
                    if (isCloudEnabled && cloudUser) {
                        uploadToCloud().then(() => {
                            console.log('âœ… Deletion synced to cloud');
                        }).catch(err => {
                            console.warn('âš ï¸ Cloud sync failed:', err);
                        });
                    }

                    // Update stats
                    updateStats();

                    // Recalculate filtered cards and adjust index
                    const updatedFilteredCards = getActiveCards();

                    // If we're at or past the end, move back
                    if (currentIndex >= updatedFilteredCards.length && updatedFilteredCards.length > 0) {
                        currentIndex = updatedFilteredCards.length - 1;
                    } else if (updatedFilteredCards.length === 0) {
                        currentIndex = 0;
                    }

                    // Show next card or empty message
                    if (updatedFilteredCards.length > 0) {
                        showFlashcard();
                        alert(`âœ“ Flashcard deleted successfully!\n\nRemaining cards: ${flashcards.length}\n\n${isCloudEnabled ? 'â˜ï¸ Changes synced to cloud' : 'ðŸ’¾ Changes saved locally'}`);
                    } else {
                        alert(`âœ“ Flashcard deleted!\n\nNo more cards to display.`);
                        flashcardContainer.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">No flashcards available. Please load a file.</p>';
                    }
                } else {
                    alert('âŒ Error: Could not find the card to delete.');
                }
            }
        });

        // Reset all progress
        resetBtn.addEventListener('click', () => {
            if (confirm('Reset all progress? This will unmark all learned cards and clear review schedules.')) {
                flashcards.forEach(card => {
                    card.learned = false;
                    card.repetitions = 0;
                    card.interval = 1;
                    card.reviewDate = null;
                });
                updateStats();
                showFlashcard();
            }
        });

        // Toggle filter mode (all â†’ unlearned â†’ learned â†’ all)
        showLearnedBtn.addEventListener('click', () => {
            // Cycle through modes
            if (filterMode === 'all') {
                filterMode = 'unlearned';
                showOnlyUnlearned = true; // Keep for backwards compatibility
                showLearnedBtn.textContent = 'ðŸ‘ Unlearned Only';
                showLearnedBtn.style.background = '#ef4444';
                showLearnedBtn.style.color = 'white';
                showLearnedBtn.classList.add('active');
            } else if (filterMode === 'unlearned') {
                filterMode = 'learned';
                showOnlyUnlearned = false;
                showLearnedBtn.textContent = 'ðŸ‘ Learned Only';
                showLearnedBtn.style.background = '#10b981';
                showLearnedBtn.style.color = 'white';
                showLearnedBtn.classList.add('active');
            } else {
                filterMode = 'all';
                showOnlyUnlearned = false;
                showLearnedBtn.textContent = 'ðŸ‘ Show All';
                showLearnedBtn.style.background = '';
                showLearnedBtn.style.color = '';
                showLearnedBtn.classList.remove('active');
            }

            currentIndex = 0;
            showFlashcard();
        });

        // Remap columns button - show format selector again
        document.getElementById('remapColumnsBtn').addEventListener('click', () => {
            if (!rawFileData) {
                alert('Please load a file first!');
                return;
            }
            const lines = rawFileData.split('\n').filter(line => line.trim() !== '');
            showFormatSelector(lines, detectedSeparator);
        });

        // Recording event listeners
        document.getElementById('stopRecordingBtn').addEventListener('click', () => {
            stopRecording();
        });

        document.getElementById('downloadRecordingBtn').addEventListener('click', () => {
            downloadRecording();
        });

        document.getElementById('playRecordingBtn').addEventListener('click', () => {
            playRecording();
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (flashcards.length === 0) return;

            switch(e.key) {
                case 'ArrowLeft':
                    // Handle based on current mode
                    if (flashcardViewMode === 'transcript') {
                        previousTranscriptCard();
                    } else {
                        stopAutoPlay(); // Stop auto-play on manual navigation
                        if (currentIndex > 0) {
                            currentIndex--;
                            showFlashcard();
                        }
                    }
                    break;
                case 'ArrowRight':
                    // Handle based on current mode
                    if (flashcardViewMode === 'transcript') {
                        nextTranscriptCard();
                    } else {
                        stopAutoPlay(); // Stop auto-play on manual navigation
                        if (currentIndex < filteredCards.length - 1) {
                            currentIndex++;
                            showFlashcard();
                        }
                    }
                    break;
                case ' ':
                case 'Enter':
                    e.preventDefault();
                    if (!alwaysShowMeanings && !englishSection.classList.contains('revealed')) {
                        revealEnglish();
                    }
                    break;
                case 'l':
                case 'L':
                    // Quick keyboard shortcut for marking as learned
                    if (filteredCards.length > 0) {
                        // First reveal the English meaning if not visible
                        if (!alwaysShowMeanings && !englishSection.classList.contains('revealed')) {
                            revealEnglish();
                            setTimeout(() => {
                                markCardAsLearned();
                            }, 300);
                        } else {
                            markCardAsLearned();
                        }
                    }
                    break;
                case 'p':
                case 'P':
                    // Quick keyboard shortcut for German pronunciation
                    if (filteredCards.length > 0) {
                        const card = filteredCards[currentIndex];
                        pronounceGerman(card.lang1);
                    }
                    break;
                case 'e':
                case 'E':
                    // Quick keyboard shortcut for English pronunciation
                    if (filteredCards.length > 0) {
                        const card = filteredCards[currentIndex];
                        pronounceEnglish(card.lang2);
                    }
                    break;
            }
        });

        // ============================================
        // PRACTICE MODE FUNCTIONALITY
        // ============================================
        let isPracticeMode = false;

        function togglePracticeMode() {
            isPracticeMode = !isPracticeMode;
            const body = document.body;
            const btn = document.getElementById('practiceModeBtn');

            if (isPracticeMode) {
                // Enter practice mode
                body.classList.add('practice-mode');
                btn.classList.add('active');
                btn.textContent = 'â¹ï¸ Stop Practice Mode';

                // Scroll to flashcard and center it
                const flashcardContainer = document.getElementById('flashcardContainer');
                if (flashcardContainer) {
                    setTimeout(() => {
                        flashcardContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 100);
                }

                // Auto-hide English section to start fresh
                const englishSection = document.getElementById('englishSection');
                if (englishSection && englishSection.classList.contains('revealed')) {
                    englishSection.classList.remove('revealed');
                }
            } else {
                // Exit practice mode
                body.classList.remove('practice-mode');
                btn.classList.remove('active');
                btn.textContent = 'ðŸŽ¯ Start Practice Mode - Focus Only on Flashcards';

                // Scroll back to top smoothly
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        // Add keyboard shortcut for practice mode (Ctrl+P or Cmd+P)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
                e.preventDefault();
                if (flashcards.length > 0) {
                    togglePracticeMode();
                }
            }
        });

        // ============================================
        // MINIMIZE MODE (YouTube-style PIP)
        // ============================================
        let isMinimized = false;

        window.toggleMinimizeMode = function() {
            const container = document.getElementById('flashcardContainer');
            const navigation = document.getElementById('navigation');
            const minimizeBtn = document.getElementById('minimizeBtn');

            isMinimized = !isMinimized;

            if (isMinimized) {
                container.classList.add('minimized');
                navigation.classList.add('hidden');
                if (minimizeBtn) {
                    minimizeBtn.innerHTML = 'â¬†ï¸ Restore';
                    minimizeBtn.title = 'Restore flashcard to full size';
                }
                console.log('ðŸ“¦ Minimized');
            } else {
                container.classList.remove('minimized');
                navigation.classList.remove('hidden');
                if (minimizeBtn) {
                    minimizeBtn.innerHTML = 'â¬‡ï¸ Minimize';
                    minimizeBtn.title = 'Minimize flashcard to corner';
                }
                console.log('ðŸ“¤ Restored');
            }
        };

        // Keyboard shortcut: M key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'm' || e.key === 'M') {
                const container = document.getElementById('flashcardContainer');
                if (container && container.style.display !== 'none') {
                    window.toggleMinimizeMode();
                }
            }
        });

        // ============================================
        // SESSION STATS COLLAPSE/EXPAND FUNCTIONALITY
        // ============================================
        function toggleSessionStats() {
            const content = document.getElementById('sessionStatsContent');
            const toggle = document.getElementById('sessionStatsToggle');

            if (content.classList.contains('collapsed')) {
                // Expand
                content.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                toggle.textContent = 'â–¼';
            } else {
                // Collapse
                content.classList.add('collapsed');
                toggle.classList.add('collapsed');
                toggle.textContent = 'â–¶';
            }
        }

        // Check for tracking prevention on page load
        function checkTrackingPrevention() {
            try {
                localStorage.setItem('_test', '1');
                localStorage.removeItem('_test');
                return false; // No tracking prevention
            } catch (e) {
                console.error('âš ï¸ TRACKING PREVENTION DETECTED!');
                console.error('Browser is blocking localStorage. Please:');
                console.error('1. If using Microsoft Edge: Settings â†’ Privacy â†’ Tracking Prevention â†’ Change to "Basic"');
                console.error('2. OR use Chrome/Firefox for local file testing');
                console.error('3. OR host the file on a web server (http://localhost)');
                return true; // Tracking prevention active
            }
        }

        // Initialize cloud sync on page load
        window.addEventListener('DOMContentLoaded', function() {
            // Check for tracking prevention
            const hasTrackingPrevention = checkTrackingPrevention();
            if (hasTrackingPrevention) {
                // Show warning message to user
                alert('âš ï¸ Browser Tracking Prevention is blocking storage!\n\n' +
                      'Please change your browser settings:\n' +
                      'â€¢ Microsoft Edge: Settings â†’ Privacy â†’ Change "Strict" to "Basic"\n' +
                      'â€¢ OR use Chrome/Firefox\n' +
                      'â€¢ OR host on a web server\n\n' +
                      'The app may not work correctly until this is fixed.');
            }

            checkExistingLogin();

            // Initialize all event listeners that depend on DOM elements
            console.log('ðŸš€ Initializing advanced features and voice selection handlers...');
            initializeAdvancedFeatures();
            initializeVoiceSelectionHandlers();
            console.log('âœ… All event listeners initialized successfully!');

            // Note: Auto-load will run ONLY after successful login (not on page load)
        });

        // ========================================
        // TRANSCRIPT MODE FUNCTIONS (New Feature)
        // ========================================

        /**
         * Switch between Card Mode and Transcript Mode
         */
        function switchViewMode(mode) {
            console.log(`ðŸ”„ Switching to ${mode} mode`);

            flashcardViewMode = mode;

            const cardModeBtn = document.getElementById('cardModeBtn');
            const transcriptModeBtn = document.getElementById('transcriptModeBtn');
            const flashcardContainer = document.getElementById('flashcardContainer');
            const transcriptView = document.getElementById('transcriptView');
            const navigation = document.getElementById('navigation');
            const quickActions = document.getElementById('quickActions');

            if (mode === 'card') {
                // Show card view
                flashcardContainer.style.display = 'block';
                navigation.style.display = 'flex';
                quickActions.style.display = 'block';

                // Hide transcript view
                transcriptView.style.display = 'none';
                document.getElementById('transcriptNavigation').style.display = 'none';

                // Update button states
                cardModeBtn.classList.add('active');
                transcriptModeBtn.classList.remove('active');

                // Stop any transcript playback
                stopTranscriptPlayback();

                // Show the current card (uses saved currentIndex)
                showFlashcard();

            } else if (mode === 'transcript') {
                // Hide card view
                flashcardContainer.style.display = 'none';
                navigation.style.display = 'none';
                quickActions.style.display = 'none';

                // Show transcript view
                transcriptView.style.display = 'block';
                document.getElementById('transcriptNavigation').style.display = 'flex';

                // Update button states
                cardModeBtn.classList.remove('active');
                transcriptModeBtn.classList.add('active');

                // Generate transcript from current flashcards
                generateTranscriptView();

                // Update transcript navigation numbers and highlight current position (uses saved transcriptCurrentIndex)
                updateTranscriptProgress();
                highlightTranscriptPair(transcriptCurrentIndex);
            }
        }

        /**
         * Generate transcript view from loaded flashcards
         */
        function generateTranscriptView() {
            console.log('ðŸ“œ Generating transcript view...');
            console.log('ðŸ“Š filteredCards:', filteredCards);
            console.log('ðŸ“Š filteredCards.length:', filteredCards ? filteredCards.length : 'undefined');

            const transcriptContainer = document.getElementById('transcriptContainer');
            console.log('ðŸ“¦ transcriptContainer element:', transcriptContainer);

            // Check if we have flashcards loaded (use filteredCards like the main display)
            if (!filteredCards || filteredCards.length === 0) {
                console.warn('âš ï¸ No filteredCards available!');
                transcriptContainer.innerHTML = `
                    <div class="transcript-empty">
                        ðŸ“œ No flashcards loaded<br>
                        <small style="color: #ccc;">Load a CSV file first, then switch to Transcript Mode</small>
                    </div>
                `;
                return;
            }

            console.log('âœ… filteredCards found, generating HTML...');

            // Create transcript header (use simple labels since lang1Label/lang2Label don't exist)
            let html = `
                <div class="transcript-header">
                    <div>ðŸ“– Source Language</div>
                    <div>ðŸŽ¯ Target Language</div>
                </div>
            `;

            // Add all flashcard pairs (using filteredCards to respect current filter)
            filteredCards.forEach((card, index) => {
                const learnedBadge = card.learned ? '<span style="color: #10b981; font-weight: bold; margin-right: 5px;">âœ“</span>' : '';
                html += `
                    <div class="transcript-pair" data-index="${index}" onclick="jumpToTranscriptSentence(${index})">
                        <div class="transcript-text source">${learnedBadge}${card.lang1 || ''}</div>
                        <div class="transcript-text target">${card.lang2 || ''}</div>
                    </div>
                `;
            });

            console.log('ðŸ“ Generated HTML length:', html.length);
            console.log('ðŸ”§ Setting innerHTML...');
            transcriptContainer.innerHTML = html;
            console.log('âœ… innerHTML set!');

            console.log(`âœ… Transcript generated with ${filteredCards.length} pairs`);

            // Update progress
            updateTranscriptProgress();
        }

        /**
         * Toggle transcript playback
         */
        function toggleTranscriptPlayback() {
            if (transcriptPlaying) {
                pauseTranscriptPlayback();
            } else {
                startTranscriptPlayback();
            }
        }

        /**
         * Start sequential playback of transcript
         */
        function startTranscriptPlayback() {
            console.log('â–¶ï¸ Starting transcript playback...');

            if (!filteredCards || filteredCards.length === 0) {
                alert('No flashcards loaded!');
                return;
            }

            // Log all active settings
            console.log('ðŸ“‹ Active Settings:', {
                totalCards: filteredCards.length,
                speechRate: speechRate,
                speechPitch: speechPitch,
                pronounceTarget: autoplayEnglishEnabled,
                delayBetweenLangs: delayBetweenLangs + 'ms',
                delayBeforeNext: delayBeforeNext + 'ms',
                repeatSource: repeatSourceCount + ' times',
                repeatTarget: repeatTargetCount + ' times',
                loopMode: loopModeEnabled,
                studyTimer: studyTimerEnabled ? document.getElementById('studyDuration').value + ' min' : 'off',
                sleepTimer: sleepTimerEnabled ? document.getElementById('sleepDuration').value + ' min' : 'off'
            });

            transcriptPlaying = true;

            // Update button states
            document.getElementById('transcriptPlayBtn').style.display = 'none';
            document.getElementById('transcriptPauseBtn').style.display = 'inline-flex';

            // Start timers if enabled
            if (studyTimerEnabled && !timerInterval) {
                startStudyTimer();
            }
            if (sleepTimerEnabled && !timerInterval) {
                startSleepTimer();
            }

            // Start from current index or beginning
            playNextTranscriptSentence();
        }

        /**
         * Play next sentence in transcript (entry point)
         */
        function playNextTranscriptSentence() {
            // Check if we should stop (end reached or timers)
            if (!transcriptPlaying) {
                stopTranscriptPlayback();
                return;
            }

            // Check if reached end
            if (transcriptCurrentIndex >= filteredCards.length) {
                if (loopModeEnabled) {
                    // Loop back to beginning
                    transcriptCurrentIndex = 0;
                    console.log('ðŸ” Loop Mode: Restarting transcript from beginning');
                } else {
                    // Stop playback
                    console.log('âœ… Transcript completed!');
                    stopTranscriptPlayback();
                    return;
                }
            }

            const card = filteredCards[transcriptCurrentIndex];

            console.log(`\nðŸ“ Card ${transcriptCurrentIndex + 1}/${filteredCards.length}:`);
            console.log(`   Source: ${card.lang1.substring(0, 50)}...`);
            console.log(`   Target: ${card.lang2.substring(0, 50)}...`);

            // Highlight current pair
            highlightTranscriptPair(transcriptCurrentIndex);

            // Update progress
            updateTranscriptProgress();

            // Reset repeat counters for this card
            transcriptSourceRepeat = 0;
            transcriptTargetRepeat = 0;

            // Start playing source language (with repeats)
            playTranscriptSourceLanguage(card);
        }

        /**
         * Play source language with repeat support
         */
        function playTranscriptSourceLanguage(card) {
            if (!transcriptPlaying) return;

            console.log(`   ðŸ—£ï¸ Source repeat ${transcriptSourceRepeat + 1}/${repeatSourceCount}`);

            // Play source language once
            speakTranscriptLanguage(card.lang1, sourceVoice, detectedSourceLang, () => {
                if (!transcriptPlaying) return;

                transcriptSourceRepeat++;

                if (transcriptSourceRepeat < repeatSourceCount) {
                    // Continue repeating source
                    console.log(`   â±ï¸ Waiting 500ms before next source repeat...`);
                    transcriptTimeout = setTimeout(() => {
                        if (!transcriptPlaying) return;
                        playTranscriptSourceLanguage(card);
                    }, 500);
                } else {
                    // Source repeats complete, add delay before target
                    console.log(`   â±ï¸ Waiting ${delayBetweenLangs}ms before target language...`);
                    transcriptTimeout = setTimeout(() => {
                        if (!transcriptPlaying) return;

                        // Check if target language should be played
                        if (autoplayEnglishEnabled) {
                            playTranscriptTargetLanguage(card);
                        } else {
                            console.log(`   â­ï¸ Skipping target language`);
                            console.log(`   â±ï¸ Waiting ${delayBeforeNext}ms before next card...`);
                            // Skip target, move to next card after delay
                            transcriptTimeout = setTimeout(() => {
                                if (!transcriptPlaying) return;
                                handleTranscriptCardCompletion();
                            }, delayBeforeNext);
                        }
                    }, delayBetweenLangs);
                }
            });
        }

        /**
         * Play target language with repeat support
         */
        function playTranscriptTargetLanguage(card) {
            if (!transcriptPlaying) return;

            console.log(`   ðŸ—£ï¸ Target repeat ${transcriptTargetRepeat + 1}/${repeatTargetCount}`);

            // Play target language once
            speakTranscriptLanguage(card.lang2, targetVoice, detectedTargetLang, () => {
                if (!transcriptPlaying) return;

                transcriptTargetRepeat++;

                if (transcriptTargetRepeat < repeatTargetCount) {
                    // Continue repeating target
                    console.log(`   â±ï¸ Waiting 500ms before next target repeat...`);
                    transcriptTimeout = setTimeout(() => {
                        if (!transcriptPlaying) return;
                        playTranscriptTargetLanguage(card);
                    }, 500);
                } else {
                    // All repeats complete, move to next card after delay
                    console.log(`   â±ï¸ Waiting ${delayBeforeNext}ms before next card...`);
                    transcriptTimeout = setTimeout(() => {
                        if (!transcriptPlaying) return;
                        handleTranscriptCardCompletion();
                    }, delayBeforeNext);
                }
            });
        }

        /**
         * Handle card completion - move to next card
         */
        function handleTranscriptCardCompletion() {
            if (!transcriptPlaying) return;

            // Move to next card
            transcriptCurrentIndex++;

            // Save progress after moving to next card
            saveProgress();

            // Continue with next sentence
            playNextTranscriptSentence();
        }

        /**
         * Speak a single language in transcript mode
         * @param {string} text - Text to speak
         * @param {SpeechSynthesisVoice} voice - Voice to use
         * @param {string} fallbackLang - Fallback language code
         * @param {Function} callback - Called when speech completes
         */
        function speakTranscriptLanguage(text, voice, fallbackLang, callback) {
            // Cancel any ongoing speech
            synth.cancel();

            const utterance = new SpeechSynthesisUtterance(text);

            // Set language code
            utterance.lang = voice ? voice.lang : fallbackLang;

            // Only set voice if it's not virtual (virtual voices use lang code only)
            if (voice && !voice.isVirtual) {
                utterance.voice = voice;
            }

            // Apply user settings
            utterance.rate = speechRate;
            utterance.pitch = speechPitch;

            console.log('ðŸŽ¤ Transcript Speech:', {
                text: text.substring(0, 30) + '...',
                lang: utterance.lang,
                rate: utterance.rate,
                pitch: utterance.pitch,
                voice: utterance.voice ? utterance.voice.name : 'default'
            });

            utterance.onend = () => {
                if (callback) callback();
            };

            utterance.onerror = (event) => {
                // "interrupted" error is normal when pausing/stopping, so don't log it as error
                if (event.error !== 'interrupted') {
                    console.error('âŒ Transcript speech error:', event);
                }
                if (callback) callback();
            };

            synth.speak(utterance);
        }

        /**
         * Highlight a transcript pair during playback
         */
        function highlightTranscriptPair(index) {
            // Remove all existing highlights
            const allPairs = document.querySelectorAll('.transcript-pair');
            allPairs.forEach(pair => pair.classList.remove('playing'));

            // Add highlight to current pair
            const currentPair = document.querySelector(`.transcript-pair[data-index="${index}"]`);
            if (currentPair) {
                currentPair.classList.add('playing');

                // Scroll into view
                currentPair.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center'
                });
            }
        }

        /**
         * Pause transcript playback
         */
        function pauseTranscriptPlayback() {
            console.log('â¸ï¸ Pausing transcript playback...');

            transcriptPlaying = false;
            synth.cancel();

            // Clear any pending timeouts
            if (transcriptTimeout) {
                clearTimeout(transcriptTimeout);
                transcriptTimeout = null;
            }

            // Update button states
            document.getElementById('transcriptPlayBtn').style.display = 'inline-flex';
            document.getElementById('transcriptPauseBtn').style.display = 'none';
        }

        /**
         * Stop transcript playback
         */
        function stopTranscriptPlayback() {
            console.log('â¹ï¸ Stopping transcript playback...');

            transcriptPlaying = false;
            synth.cancel();

            // Clear any pending timeouts
            if (transcriptTimeout) {
                clearTimeout(transcriptTimeout);
                transcriptTimeout = null;
            }

            // Stop timers
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
                timerEndTime = null;
                document.getElementById('timerDisplay').style.display = 'none';
            }

            // Update button states
            document.getElementById('transcriptPlayBtn').style.display = 'inline-flex';
            document.getElementById('transcriptPauseBtn').style.display = 'none';

            // Remove all highlights
            const allPairs = document.querySelectorAll('.transcript-pair');
            allPairs.forEach(pair => pair.classList.remove('playing'));

            // Update progress
            updateTranscriptProgress();
        }

        /**
         * Jump to specific sentence in transcript
         */
        function jumpToTranscriptSentence(index) {
            console.log(`â­ï¸ Jumping to sentence ${index + 1}`);

            transcriptCurrentIndex = index;

            // If playing, continue from this point
            if (transcriptPlaying) {
                synth.cancel();
                playNextTranscriptSentence();
            } else {
                // Just highlight
                highlightTranscriptPair(index);
                updateTranscriptProgress();
            }
        }

        /**
         * Update transcript progress display
         */
        function updateTranscriptProgress() {
            const progressEl = document.getElementById('transcriptProgress');

            if (!filteredCards || filteredCards.length === 0) {
                progressEl.textContent = 'No flashcards loaded';
                return;
            }

            // Update navigation numbers (matching card mode)
            const currentInputEl = document.getElementById('transcriptCurrentInput');
            const totalCardsEl = document.getElementById('transcriptTotalCards');
            const prevBtn = document.getElementById('transcriptPrevBtn');
            const nextBtn = document.getElementById('transcriptNextBtn');

            if (currentInputEl) {
                currentInputEl.value = transcriptCurrentIndex + 1;
                currentInputEl.max = filteredCards.length;
            }
            if (totalCardsEl) totalCardsEl.textContent = filteredCards.length;

            // Update button states
            if (prevBtn) prevBtn.disabled = transcriptCurrentIndex === 0;
            if (nextBtn) nextBtn.disabled = transcriptCurrentIndex === filteredCards.length - 1;

            if (transcriptPlaying) {
                progressEl.textContent = `Playing: ${transcriptCurrentIndex + 1} / ${filteredCards.length}`;
            } else if (transcriptCurrentIndex > 0) {
                progressEl.textContent = `Paused at: ${transcriptCurrentIndex + 1} / ${filteredCards.length}`;
            } else {
                progressEl.textContent = `Ready to play ${filteredCards.length} sentences - Press Space or click Play`;
            }
        }

        // Navigate to previous transcript card
        function previousTranscriptCard() {
            if (transcriptCurrentIndex > 0) {
                transcriptCurrentIndex--;
                updateTranscriptProgress();
                highlightTranscriptPair(transcriptCurrentIndex);
                saveProgress();
                console.log('â† Previous transcript card:', transcriptCurrentIndex + 1);
            }
        }

        // Navigate to next transcript card
        function nextTranscriptCard() {
            if (transcriptCurrentIndex < filteredCards.length - 1) {
                transcriptCurrentIndex++;
                updateTranscriptProgress();
                highlightTranscriptPair(transcriptCurrentIndex);
                saveProgress();
                console.log('â†’ Next transcript card:', transcriptCurrentIndex + 1);
            }
        }

        // Event listeners for transcript navigation buttons
        const transcriptPrevBtn = document.getElementById('transcriptPrevBtn');
        const transcriptNextBtn = document.getElementById('transcriptNextBtn');

        if (transcriptPrevBtn) {
            transcriptPrevBtn.addEventListener('click', () => {
                if (transcriptPlaying) stopTranscriptPlayback(); // Stop playback on manual navigation
                previousTranscriptCard();
            });
        }

        if (transcriptNextBtn) {
            transcriptNextBtn.addEventListener('click', () => {
                if (transcriptPlaying) stopTranscriptPlayback(); // Stop playback on manual navigation
                nextTranscriptCard();
            });
        }

        // Jump to specific card by entering card number in transcript mode
        const transcriptCurrentInput = document.getElementById('transcriptCurrentInput');
        let transcriptJumpTimeout = null;

        if (transcriptCurrentInput) {
            const jumpToTranscriptCard = () => {
                if (transcriptPlaying) stopTranscriptPlayback(); // Stop playback on manual navigation
                const cardNumber = parseInt(transcriptCurrentInput.value);

                // Validate input
                if (isNaN(cardNumber) || cardNumber < 1) {
                    transcriptCurrentInput.value = transcriptCurrentIndex + 1;
                    alert('âš ï¸ Please enter a valid card number (minimum: 1)');
                    return;
                }

                if (cardNumber > filteredCards.length) {
                    transcriptCurrentInput.value = transcriptCurrentIndex + 1;
                    alert(`âš ï¸ Card number cannot exceed ${filteredCards.length}`);
                    return;
                }

                // Jump to the card (convert to 0-based index)
                transcriptCurrentIndex = cardNumber - 1;
                updateTranscriptProgress();
                highlightTranscriptPair(transcriptCurrentIndex);
                saveProgress();
                console.log('ðŸŽ¯ Jumped to transcript card:', transcriptCurrentIndex + 1);
            };

            // Auto-update as you type (with 800ms delay after you stop typing)
            transcriptCurrentInput.addEventListener('input', () => {
                // Clear previous timeout
                if (transcriptJumpTimeout) clearTimeout(transcriptJumpTimeout);

                // Set new timeout - updates 800ms after you stop typing
                transcriptJumpTimeout = setTimeout(() => {
                    jumpToTranscriptCard();
                }, 800);
            });

            // Also handle Enter key for immediate jump
            transcriptCurrentInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    if (transcriptJumpTimeout) clearTimeout(transcriptJumpTimeout);
                    jumpToTranscriptCard();
                }
            });

            // Handle blur (clicking outside) for immediate jump
            transcriptCurrentInput.addEventListener('blur', () => {
                if (transcriptJumpTimeout) clearTimeout(transcriptJumpTimeout);
                jumpToTranscriptCard();
            });
        }

        /**
         * Shuffle transcript order
         */
        function shuffleTranscript() {
            console.log('ðŸ”€ Shuffling transcript...');

            // Stop playback if playing
            if (transcriptPlaying) {
                pauseTranscriptPlayback();
            }

            // Shuffle filteredCards using Fisher-Yates algorithm
            for (let i = filteredCards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [filteredCards[i], filteredCards[j]] = [filteredCards[j], filteredCards[i]];
            }

            // Reset to beginning
            transcriptCurrentIndex = 0;

            // Regenerate transcript view with new order
            generateTranscriptView();

            console.log('âœ… Transcript shuffled!');
        }

        /**
         * Remap columns - swap source and target languages in transcript
         */
        function remapTranscriptColumns() {
            console.log('ðŸŽ¯ Remapping columns in transcript...');

            // Stop playback if playing
            if (transcriptPlaying) {
                pauseTranscriptPlayback();
            }

            // Swap lang1 and lang2 for all filtered cards
            filteredCards.forEach(card => {
                const temp = card.lang1;
                card.lang1 = card.lang2;
                card.lang2 = temp;

                // Also swap extended content if exists
                if (card.lang1Extended || card.lang2Extended) {
                    const tempExt = card.lang1Extended;
                    card.lang1Extended = card.lang2Extended;
                    card.lang2Extended = tempExt;
                }
            });

            // Also need to swap in the main flashcards array for the same files
            Object.keys(allFlashcards).forEach(filename => {
                allFlashcards[filename].forEach(card => {
                    const temp = card.lang1;
                    card.lang1 = card.lang2;
                    card.lang2 = temp;

                    if (card.lang1Extended || card.lang2Extended) {
                        const tempExt = card.lang1Extended;
                        card.lang1Extended = card.lang2Extended;
                        card.lang2Extended = tempExt;
                    }
                });
            });

            // Swap voices
            const tempVoice = sourceVoice;
            sourceVoice = targetVoice;
            targetVoice = tempVoice;

            // Swap detected languages
            const tempLang = detectedSourceLang;
            detectedSourceLang = detectedTargetLang;
            detectedTargetLang = tempLang;

            // Regenerate transcript view with swapped columns
            generateTranscriptView();

            // Save changes
            saveProgress();

            console.log('âœ… Columns remapped! Source â†” Target');
        }

        /**
         * Delete currently highlighted card in transcript mode
         */
        function deleteCurrentTranscriptCard() {
            if (!filteredCards || filteredCards.length === 0) {
                alert('No cards to delete!');
                return;
            }

            // Use transcriptCurrentIndex or find the playing card
            let indexToDelete = transcriptCurrentIndex;

            // If nothing is highlighted, default to first card
            if (indexToDelete >= filteredCards.length) {
                indexToDelete = 0;
            }

            const cardToDelete = filteredCards[indexToDelete];

            // Confirm deletion
            const confirmMsg = `Delete this card?\n\nSource: ${cardToDelete.lang1}\nTarget: ${cardToDelete.lang2}`;
            if (!confirm(confirmMsg)) {
                return;
            }

            console.log('ðŸ—‘ï¸ Deleting card from transcript:', cardToDelete);

            // Stop playback if playing
            if (transcriptPlaying) {
                pauseTranscriptPlayback();
            }

            // Remove from filteredCards
            filteredCards.splice(indexToDelete, 1);

            // Remove from main flashcards array
            // Find the card in flashcards array by matching lang1 and lang2
            const mainIndex = flashcards.findIndex(c =>
                c.lang1 === cardToDelete.lang1 && c.lang2 === cardToDelete.lang2
            );

            if (mainIndex !== -1) {
                flashcards.splice(mainIndex, 1);
                console.log(`   Removed from flashcards array at index ${mainIndex}`);
            }

            // Check if we have any cards left
            if (flashcards.length === 0) {
                console.log('   No more cards, clearing file...');
                clearFile();
                return;
            }

            // Adjust current index if needed
            if (transcriptCurrentIndex >= filteredCards.length) {
                transcriptCurrentIndex = Math.max(0, filteredCards.length - 1);
            }

            // Update stats
            updateStats();

            // Regenerate transcript view
            generateTranscriptView();

            // Save changes
            saveProgress();

            console.log(`âœ… Card deleted! Remaining: ${flashcards.length} total, ${filteredCards.length} filtered`);
        }

        /**
         * Enhanced keyboard shortcuts for transcript mode
         */
        document.addEventListener('keydown', function(e) {
            // Only handle when in transcript mode
            if (flashcardViewMode !== 'transcript') return;

            // Don't interfere with input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            switch(e.code) {
                case 'Space':
                    e.preventDefault();
                    toggleTranscriptPlayback();
                    break;

                case 'ArrowRight':
                    e.preventDefault();
                    if (!transcriptPlaying) {
                        transcriptCurrentIndex = Math.min(transcriptCurrentIndex + 1, filteredCards.length - 1);
                        jumpToTranscriptSentence(transcriptCurrentIndex);
                    }
                    break;

                case 'ArrowLeft':
                    e.preventDefault();
                    if (!transcriptPlaying) {
                        transcriptCurrentIndex = Math.max(transcriptCurrentIndex - 1, 0);
                        jumpToTranscriptSentence(transcriptCurrentIndex);
                    }
                    break;

                case 'KeyL':
                    e.preventDefault();
                    // Mark current transcript card as learned/unlearned
                    if (filteredCards.length > 0) {
                        const card = filteredCards[transcriptCurrentIndex];
                        if (!card.learned) {
                            // Mark as learned and apply spaced repetition
                            const reviewData = calculateNextReview(card, 4);
                            card.learned = true;
                            card.repetitions = reviewData.repetitions;
                            card.easeFactor = reviewData.easeFactor;
                            card.interval = reviewData.interval;
                            card.reviewDate = reviewData.reviewDate;
                            console.log(`âœ“ Card ${transcriptCurrentIndex + 1} marked as learned`);
                        } else {
                            // Unmark as learned
                            card.learned = false;
                            card.repetitions = 0;
                            card.interval = 1;
                            card.reviewDate = null;
                            console.log(`âœ— Card ${transcriptCurrentIndex + 1} unmarked as learned`);
                        }
                        updateStats();
                        saveProgress(); // Save position
                        saveFlashcardsToCloud(); // Save flashcard data to cloud
                        // Regenerate transcript to show updated learned status
                        generateTranscriptView();
                        updateTranscriptProgress();
                        highlightTranscriptPair(transcriptCurrentIndex);
                    }
                    break;

                case 'Escape':
                    e.preventDefault();
                    stopTranscriptPlayback();
                    break;
            }
        });

        console.log('âœ… Transcript mode functions initialized!');
    </script>

    <!-- Focus Mode Overlay -->
    <div class="focus-mode" id="focusMode">
        <button class="focus-exit-btn" onclick="exitFocusMode()">âœ• Exit Focus Mode</button>
        <div class="flashcard-container">
            <div class="flashcard" id="focusFlashcard">
                <!-- Will be cloned from main flashcard -->
            </div>
        </div>
    </div>

</body>
</html>
